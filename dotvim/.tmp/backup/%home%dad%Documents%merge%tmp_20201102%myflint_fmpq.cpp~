#include "myflint_fmpq.hpp"

Fmpq::Fmpq()
{
  fmpq_init(number);
}

Fmpq::Fmpq(const string in_string) : Fmpq()
{
  fmpq_set_str(number, in_string.c_str(), 10);
}

// integers
Fmpq::Fmpq(const fmpq_t& in_number) : Fmpq()
{
  fmpq_set(number, in_number);
}

Fmpq::Fmpq(const int64_t& in_number) : Fmpq()
{
  fmpq_set_si(number, in_number, 1);
}

// fractions as numerator,denominator
Fmpq::Fmpq(const int64_t& num, const int64_t& den) : Fmpq()
{
  fmpq_set_si(number, num, den);
}

Fmpq::Fmpq(const fmpz_t& num, const fmpz_t& den) : Fmpq()
{
  fmpq_set_fmpz_frac(number, num, den);
}

// two Fmpzs
Fmpq::Fmpq(const Fmpz &num, const Fmpz &den) : Fmpq(num.number, den.number) {}

// mix of fmpz_t and int64_t
Fmpq::Fmpq(const fmpz_t& num, const int64_t& den) : Fmpq(num, Fmpz(den)) {}
Fmpq::Fmpq(const int64_t& num, const fmpz_t& den) : Fmpq(Fmpz(num), den) {}

// mix of Fmpz and int64_t
Fmpq::Fmpq(const Fmpz& num, const int64_t& den) : Fmpq(num.number, den) {}
Fmpq::Fmpq(const int64_t& num, const Fmpz& den) : Fmpq(num, den.number) {}

// integer which isn't handled directly
Fmpq::Fmpq(const fmpz_t& in_number) : Fmpq(in_number, 1) {}
Fmpq::Fmpq(const Fmpz &in_number) : Fmpq(in_number.number) {}

Fmpq::Fmpq(const Fmpq &other) : Fmpq()
{
  fmpq_set(number, other.number);
}

Fmpq& Fmpq::operator=(const Fmpq &other)
{
  if(*this != other) fmpq_set(number, other.number);
  return *this;
}

Fmpq& Fmpq::operator=(const Fmpz &other)
{
  fmpq_set_fmpz_frac(number, other.number, Fmpz(1).number);
  return *this;
}

Fmpq& Fmpq::operator=(const int64_t &other)
{
  fmpq_set_si(number, other, 1);
  return *this;
}

Fmpq::~Fmpq()
{
  fmpq_clear(number);
}

auto Fmpq::numerator() const
{
  return Fmpz(number->num);
}

auto Fmpq::denominator() const
{
  return Fmpz(number->den);
}

auto Fmpq::fraction() const
{
  auto result = tuple(Fmpz(number->num), Fmpz(number->den));

  return result;
}

// addition
Fmpq& Fmpq::operator+=(const Fmpq &rhs)
{
  fmpq_add(number, number, rhs.number);
  return *this;
}

Fmpq& Fmpq::operator+=(const int64_t &rhs)
{
  fmpq_add_si(number, number, rhs);
  return *this;
}

Fmpq& Fmpq::operator+=(const Fmpz &rhs)
{
  fmpq_add_fmpz(number, number, rhs.number);
  return *this;
}

Fmpq Fmpq::operator+(const Fmpq &rhs) const
{
  auto result = Fmpq();
  fmpq_add(result.number, number, rhs.number);
  return result;
}

Fmpq Fmpq::operator+(const int64_t &rhs) const
{
  auto result = Fmpq();
  fmpq_add_si(result.number, number, rhs);
  return result;
}

Fmpq Fmpq::operator+(const Fmpz &rhs) const
{
  auto result = Fmpq();
  fmpq_add_fmpz(result.number, number, rhs.number);
  return result;
}

// subtraction
Fmpq& Fmpq::operator-=(const Fmpq &rhs)
{
  fmpq_sub(number, number, rhs.number);
  return *this;
}

Fmpq& Fmpq::operator-=(const int64_t &rhs)
{
  fmpq_sub_si(number, number, rhs);
  return *this;
}

Fmpq& Fmpq::operator-=(const Fmpz &rhs)
{
  fmpq_sub_fmpz(number, number, rhs.number);
  return *this;
}

Fmpq Fmpq::operator-(const Fmpq &rhs) const
{
  auto result = Fmpq();
  fmpq_sub(result.number, number, rhs.number);
  return result;
}

Fmpq Fmpq::operator-(const int64_t &rhs) const
{
  auto result = Fmpq();
  fmpq_sub_si(result.number, number, rhs);
  return result;
}

Fmpq Fmpq::operator-(const Fmpz &rhs) const
{
  auto result = Fmpq();
  fmpq_sub_fmpz(result.number, number, rhs.number);
  return result;
}

Fmpq Fmpq::operator-() const
{
  auto result = Fmpq();
  fmpq_neg(result.number, number);
  return result;
}

// multiplication
Fmpq& Fmpq::operator*=(const Fmpq &rhs)
{
  fmpq_mul(number, number, rhs.number);
  return *this;
}

Fmpq& Fmpq::operator*=(const int64_t &rhs)
{
  fmpq_mul_si(number, number, rhs);
  return *this;
}

Fmpq& Fmpq::operator*=(const Fmpz &rhs)
{
  fmpq_mul_fmpz(number, number, rhs.number);
  return *this;
}

Fmpq Fmpq::operator*(const Fmpq &rhs) const
{
  auto result = Fmpq();
  fmpq_mul(result.number, number, rhs.number);
  return result;
}

Fmpq Fmpq::operator*(const int64_t &rhs) const
{
  auto result = Fmpq();
  fmpq_mul_si(result.number, number, rhs);
  return result;
}

Fmpq Fmpq::operator*(const Fmpz &rhs) const
{
  auto result = Fmpq();
  fmpq_mul_fmpz(result.number, number, rhs.number);
  return result;
}

// addmul
void Fmpq::addmul(const Fmpq& in0, const Fmpq& in1)
{
  fmpq_addmul(number, in0.number, in1.number);
}

void Fmpq::addmul(const Fmpq& in0, const Fmpz& in1) {addmul(in0, Fmpq(in1));}
void Fmpq::addmul(const Fmpq& in0, const int64_t& in1) {addmul(in0, Fmpq(in1));}
void Fmpq::addmul(const Fmpz& in0, const Fmpq& in1) {addmul(Fmpq(in0), in1);}
void Fmpq::addmul(const int64_t& in0, const Fmpq& in1) {addmul(Fmpq(in0), in1);}

void Fmpq::addmul(const Fmpz& in0, const Fmpz& in1) {addmul(Fmpq(in0), Fmpq(in1));}
void Fmpq::addmul(const Fmpz& in0, const int64_t& in1) {addmul(Fmpq(in0), Fmpq(in1));}
void Fmpq::addmul(const int64_t& in0, const Fmpz& in1) {addmul(Fmpq(in0), Fmpq(in1));}
void Fmpq::addmul(const int64_t& in0, const int64_t& in1) {addmul(Fmpq(in0), Fmpq(in1));}

void Fmpq::submul(const Fmpq& in0, const Fmpq& in1)
{
  fmpq_submul(number, in0.number, in1.number);
}

void Fmpq::submul(const Fmpq& in0, const Fmpz& in1) {submul(in0, Fmpq(in1));}
void Fmpq::submul(const Fmpq& in0, const int64_t& in1) {submul(in0, Fmpq(in1));}

void Fmpq::submul(const Fmpz& in0, const Fmpq& in1) {submul(Fmpq(in0), in1);}
void Fmpq::submul(const int64_t& in0, const Fmpq& in1) {submul(Fmpq(in0), in1);}

void Fmpq::submul(const Fmpz& in0, const Fmpz& in1) {submul(Fmpq(in0), Fmpq(in1));}
void Fmpq::submul(const Fmpz& in0, const int64_t& in1) {submul(Fmpq(in0), Fmpq(in1));}
void Fmpq::submul(const int64_t& in0, const Fmpz& in1) {submul(Fmpq(in0), Fmpq(in1));}
void Fmpq::submul(const int64_t& in0, const int64_t& in1) {submul(Fmpq(in0), Fmpq(in1));}

// comparison
bool Fmpq::operator==(const Fmpq &rhs) const
{
  return (fmpq_cmp(number, rhs.number)==0);
}

bool Fmpq::operator==(const int64_t &rhs) const
{
  return (fmpq_cmp_si(number, rhs)==0);
}

bool Fmpq::operator==(const Fmpz &rhs) const
{
  return (fmpq_cmp_fmpz(number, rhs.number) == 0);
}

bool Fmpq::operator!=(const Fmpq &rhs) const
{
  return !(*this == rhs);
}

bool Fmpq::operator!=(const Fmpz &rhs) const
{
  return !(*this == rhs);
}

bool Fmpq::operator!=(const int64_t &rhs) const
{
  return !(*this == rhs);
}

bool Fmpq::operator>(const Fmpq &rhs) const
{
  return (fmpq_cmp(number, rhs.number) > 0);
}
bool Fmpq::operator>(const Fmpz &rhs) const
{
  return (fmpq_cmp_fmpz(number, rhs.number) > 0);
}
bool Fmpq::operator>(const int64_t &rhs) const
{
  return (fmpq_cmp_si(number,rhs) > 0);
}

bool Fmpq::operator>=(const Fmpq &rhs) const
{
  return (fmpq_cmp(number, rhs.number) >= 0);
}
bool Fmpq::operator>=(const Fmpz &rhs) const
{
  return (fmpq_cmp_fmpz(number, rhs.number) >= 0);
}
bool Fmpq::operator>=(const int64_t &rhs) const
{
  return (fmpq_cmp_si(number,rhs) >= 0);
}

bool Fmpq::operator<=(const Fmpq &rhs) const
{
  return (fmpq_cmp(number, rhs.number) <= 0);
}
bool Fmpq::operator<=(const Fmpz &rhs) const
{
  return (fmpq_cmp_fmpz(number, rhs.number) <= 0);
}
bool Fmpq::operator<=(const int64_t &rhs) const
{
  return (fmpq_cmp_si(number,rhs) <= 0);
}

bool Fmpq::operator<(const Fmpq &rhs) const
{
  return (fmpq_cmp(number, rhs.number) < 0);
}
bool Fmpq::operator<(const Fmpz &rhs) const
{
  return (fmpq_cmp_fmpz(number, rhs.number) < 0);
}
bool Fmpq::operator<(const int64_t &rhs) const
{
  return (fmpq_cmp_si(number,rhs) < 0);
}

bool operator==(const Fmpz& lhs, const Fmpq& rhs)
{
  return (rhs>lhs);
}
bool operator==(const int64_t& lhs, const Fmpq& rhs)
{
  return (rhs>lhs);
}
bool operator!=(const Fmpz& lhs, const Fmpq& rhs)
{
  return (rhs>lhs);
}
bool operator!=(const int64_t& lhs, const Fmpq& rhs)
{
  return (rhs>lhs);
}

bool operator<(const Fmpz& lhs, const Fmpq& rhs)
{
  return (rhs>lhs);
}
bool operator<(const int64_t& lhs, const Fmpq& rhs)
{
  return (rhs>lhs);
}
bool operator<=(const Fmpz& lhs, const Fmpq& rhs)
{
  return (rhs>=lhs);
}
bool operator<=(const int64_t& lhs, const Fmpq& rhs)
{
  return (rhs>=lhs);
}
bool operator>=(const Fmpz& lhs, const Fmpq& rhs)
{
  return (rhs<=lhs);
}
bool operator>=(const int64_t& lhs, const Fmpq& rhs)
{
  return (rhs<=lhs);
}
bool operator>(const Fmpz& lhs, const Fmpq& rhs)
{
  return (rhs<lhs);
}
bool operator>(const int64_t& lhs, const Fmpq& rhs)
{
  return (rhs<lhs);
}

// division
Fmpq& Fmpq::operator/=(const Fmpq &rhs)
{
  if(fmpq_is_zero(rhs.number))
  {
    throw invalid_argument("Divison by zero!");
  }

  fmpq_div(number, number, rhs.number);

  return *this;
}

Fmpq& Fmpq::operator/=(const Fmpz &rhs)
{
  if(fmpz_is_zero(rhs.number))
  {
    throw invalid_argument("Divison by zero!");
  }

  fmpq_div_fmpz(number, number, rhs.number);

  return *this;
}

Fmpq& Fmpq::operator/=(const int64_t &rhs)
{
  *this /= Fmpz(rhs);
  return *this;
}

Fmpq Fmpq::operator/(const Fmpq& rhs) const
{
  if(fmpq_is_zero(rhs.number))
  {
    throw invalid_argument("Divison by zero!");
  }

  auto result = Fmpq();
  fmpq_div(result.number, number, rhs.number);

  return result;
}

Fmpq Fmpq::operator/(const Fmpz& rhs) const
{
  if(fmpz_is_zero(rhs.number))
  {
    throw invalid_argument("Divison by zero!");
  }

  auto result = Fmpq();
  fmpq_div_fmpz(result.number, number, rhs.number);

  return result;
}

Fmpq Fmpq::operator/(const int64_t& rhs) const
{
  auto result = *this / Fmpq(rhs);
  return result;
}

// other stuff
Fmpq Fmpq::abs() const
{
  auto result = Fmpq();
  fmpq_abs(result.number, number);
  return result;
}

ostream& operator<<(ostream& os, const Fmpq& f)
{

  char *out_string = fmpq_get_str(NULL, 10, f.number);
  os << out_string;
  free(out_string);

  return os;
}

// define all the operators with rational on rhs
Fmpq operator+(const Fmpz &lhs, const Fmpq &rhs)
{
  return rhs + lhs;
}
Fmpq operator+(const int64_t &lhs, const Fmpq &rhs)
{
  return rhs + lhs;
}
Fmpq operator-(const Fmpz &lhs, const Fmpq &rhs)
{
  return -(rhs - lhs);
}
Fmpq operator-(const int64_t &lhs, const Fmpq &rhs)
{
  return -(rhs - lhs);
}
Fmpq operator*(const Fmpz &lhs, const Fmpq &rhs)
{
  return rhs * lhs;
}
Fmpq operator*(const int64_t &lhs, const Fmpq &rhs)
{
  return rhs * lhs;
}
Fmpq operator/(const Fmpz &lhs, const Fmpq &rhs)
{
  auto result = Fmpq();
  fmpq_inv(result.number, rhs.number);
  result *= lhs;
  return result;
}
Fmpq operator/(const int64_t &lhs, const Fmpq &rhs)
{
  auto result = Fmpq();
  fmpq_inv(result.number, rhs.number);
  result *= lhs;
  return result;
}

// divide integers to get rationals
Fmpq operator/(int64_t &lhs, Fmpz &rhs)
{
  return Fmpq(lhs)/rhs;
}
Fmpq operator/(Fmpz &lhs, int64_t &rhs)
{
  return Fmpq(lhs)/rhs;
}
Fmpq operator/(Fmpz &lhs, Fmpz &rhs)
{
  return Fmpq(lhs)/rhs;
}

auto pow(Fmpq base, int64_t exponent)
{
  auto result = Fmpq();
  fmpq_pow_si(result.number, base.number, exponent);

  return result;
}
