#include "op_temporaries.hpp"

using namespace std;

#include <fmt/core.h>
#include <fmt/ostream.h>

using fmt::print;
using fmt::format;

ZZ::ZZ() { fmpz_init((fmpz*) *this); }

ZZ::ZZ(const int64_t &in_number) { fmpz_init_set_si((fmpz*) *this, in_number); }

ZZ::ZZ(const fmpz_t &in_number) { fmpz_init_set((fmpz*) *this, (const fmpz*) in_number); }

ZZ::ZZ(const ZZ_ptr &ptr) { fmpz_init_set((fmpz*) *this, (const fmpz*) ptr); }

ZZ::ZZ(const string in_string) : ZZ() {
  fmpz_set_str((fmpz*) *this, in_string.c_str(), 10);
}

ZZ::ZZ(const ZZ &other) : ZZ(other.number) {} // copy constructor

ZZ::ZZ(ZZ &&other) noexcept : ZZ() { // move constructor
  fmpz_swap((fmpz*) *this, (fmpz*) other);
}

ZZ &ZZ::operator=(const ZZ &other) { // copy assignment
  fmpz_set((fmpz*) *this, (const fmpz*) other);
  return *this;
}

ZZ &ZZ::operator=(ZZ &&other) noexcept { // move assignment
  fmpz_swap((fmpz*) *this, (fmpz*) other);
  return *this;
}

ZZ &ZZ::operator=(const ZZ_add &rhs) { // copy assignment
  fmpz_add((fmpz*) *this, rhs.a, rhs.b);
  return *this;
}

ZZ::~ZZ() { // destructor
  fmpz_clear((fmpz*) *this);
}

ZZ& ZZ::apply_fmpz_fun_eq(const ZZ &rhs,
    const function<void(fmpz_t, fmpz_t, const fmpz_t)>& fun) {
  fun((fmpz*) *this,(fmpz*) *this, (const fmpz*) rhs);
  return *this;
}

ZZ& ZZ::apply_fmpz_fun_eq(const function<void(fmpz_t, fmpz_t)>& fun) {
  fun((fmpz*) *this, (fmpz*) *this);
  return *this;
}

ZZ& ZZ::apply_fmpz_fun_eq(int64_t in, const function<void(fmpz_t, fmpz_t, int64_t)>& fun) {
  fun((fmpz*) *this, (fmpz*) *this, in);
  return *this;
}


ZZ apply_fmpz_fun(
    const ZZ &lhs,
    const ZZ &rhs,
    const function<void(fmpz_t, const fmpz_t, const fmpz_t)>& fun) {
  auto result = ZZ();
  fun((fmpz*) result, (const fmpz*) lhs, (const fmpz*) rhs);
  return result;
}

ZZ apply_fmpz_fun(const ZZ &lhs, function<void(fmpz_t, const fmpz_t)> fun) {
  auto result = ZZ();
  fun((fmpz*) result, (const fmpz*) lhs);
  return result;
}

ZZ apply_fmpz_fun(const ZZ &lhs, int64_t in, function<void(fmpz_t, const fmpz_t, int64_t)> fun) {
  auto result = ZZ();
  fun((fmpz*) result, (const fmpz*) lhs, in);
  return result;
}

ZZ &ZZ::operator+=(const ZZ &rhs) { return apply_fmpz_fun_eq(rhs, fmpz_add); }

//ZZ ZZ::operator+(const ZZ &rhs) const { return apply_fmpz_fun(*this, rhs, fmpz_add); }
ZZ_add ZZ::operator+(const ZZ &rhs) const {
  printf("putting into a ZZ_add\n");
  return ZZ_add((const fmpz*) *this,(const fmpz*) rhs);
}

ZZ &ZZ::operator+=(const ZZ_add &rhs) {
  fmpz_add((fmpz*) *this, (fmpz*) *this, rhs.a);
  fmpz_add((fmpz*) *this, (fmpz*) *this, rhs.b);
  return *this;
}

ZZ &ZZ::operator-=(const ZZ &rhs) { return apply_fmpz_fun_eq(rhs, fmpz_sub); }
ZZ ZZ::operator-(const ZZ &rhs) const { return apply_fmpz_fun(*this, rhs, fmpz_sub); }
ZZ &ZZ::operator*=(const ZZ &rhs) { return apply_fmpz_fun_eq(rhs, fmpz_mul); }
ZZ ZZ::operator*(const ZZ &rhs) const { return apply_fmpz_fun(*this, rhs, fmpz_mul); }
ZZ &ZZ::operator%=(const ZZ &rhs) { return apply_fmpz_fun_eq(rhs, fmpz_mod); }
ZZ ZZ::operator%(const ZZ &rhs) const { return apply_fmpz_fun(*this, rhs, fmpz_mod); }
ZZ &ZZ::operator/=(const ZZ &rhs) {
  return apply_fmpz_fun_eq(rhs, fmpz_divexact);
}
ZZ ZZ::operator/(const ZZ &rhs) const {
  return apply_fmpz_fun(*this, rhs, fmpz_divexact);
}
ZZ& ZZ::operator-() { return apply_fmpz_fun_eq(fmpz_neg); }
ZZ ZZ::operator-() const { return apply_fmpz_fun(*this, fmpz_neg); }

ZZ& ZZ::addmul(const ZZ &in0, const ZZ &in1) {
  fmpz_addmul((fmpz*) *this, (const fmpz*) in0, (const fmpz*) in1);
  return *this;
}
ZZ& ZZ::submul(const ZZ &in0, const ZZ &in1) {
  fmpz_submul((fmpz*) *this, (const fmpz*) in0, (const fmpz*) in1);
  return *this;
}

bool ZZ::operator==(const ZZ &rhs) const {
  return (bool)fmpz_equal((const fmpz*) *this, (const fmpz*) rhs);
}
#if 0
bool ZZ::operator!=(const ZZ &rhs) const {
  return !(fmpz_equal((fmpz*) *this, (fmpz*) rhs));
}
#endif

strong_ordering ZZ::operator<=>(const ZZ &rhs) const{
  return (fmpz_cmp((const fmpz*) *this,(const fmpz*) rhs))<=>0;
}

bool ZZ::is_divisible_by(const ZZ &poss_factor) const {
  return fmpz_divisible((const fmpz*) *this, (const fmpz*) poss_factor);
}

ZZ abs(const ZZ &in) { return apply_fmpz_fun(in,fmpz_abs); }

bool is_prime(const ZZ &in) {
  auto result = fmpz_is_prime((const fmpz*) in);
  return (result != 0);
}

ZZ pow(ZZ base, int64_t exponent) {
  if (exponent < 0) {
    throw invalid_argument("Negative exponentiation not supported for ZZ");
  }

  auto result = ZZ();
  fmpz_pow_ui((fmpz*) result, (const fmpz*) base, (uint64_t)exponent);

  return result;
}

ostream &operator<<(ostream &os, const ZZ &f) {
  char *out_string = fmpz_get_str(NULL, 10, (const fmpz*) f);
  os << out_string;
  free(out_string);

  return os;
}

ZZ gcd(const ZZ &a, const ZZ &b){
  return apply_fmpz_fun(a,b,fmpz_gcd);
}

ZZ& ZZ::next_prime(){
  return apply_fmpz_fun_eq(0,fmpz_nextprime);
}

ZZ next_prime(const ZZ &a){
  return apply_fmpz_fun(a,0,fmpz_nextprime);
}
