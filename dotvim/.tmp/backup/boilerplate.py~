#!/usr/bin/python3

from enum import Enum, auto
import itertools

class P(Enum):
    si = auto()
    ui = auto()
    su = auto()
    d = auto()
    f = auto()
    df = auto()
    st = auto()

types = {}

types[P.si] = [f"int{2**i}_t" for i in range(3,7)]
types[P.ui] = [f"uint{2**i}_t" for i in range(3,7)]

#types[P.si] = ["slong"]
#types[P.ui] = ["ulong"]

types[P.su] = types[P.si] + types[P.ui]
types[P.d] = ["double"]
types[P.f] = ["float"]
types[P.df] = types[P.d] + types[P.f]
types[P.st] = ["std::string"]

def typemacro_decl(typemacro,typename):

    if isinstance(typemacro, list):

        if not isinstance(typename, list):
            typename = [typename] * len(list)
        elif len(typename) != len(typemacro):
            raise ValueError("lengths of inputs don't match")

        results = [typemacro_decl(m,n) for m,n in zip(typemacro,typename)]
        head =  "".join([_[0] for _ in results])
        foot =  "".join([_[1] for _ in results])
        return head, foot

    head = f"#define {typemacro} {typename}\n"
    foot = f"#undef {typemacro}\n"

    return head, foot

def repeat_on_types(t,include_fname,typemacro="_TYPE_IN"):

    if not t in types:
        raise ValueError("Unknown type")

    out = ""
    for typename in types[t]:

        head,foot = typemacro_decl(typemacro,typename)

        #out += f"#define {typemacro} {typename}\n"
        out += head
        out += f"#include \"{include_fname}\"\n"
        #out += f"#undef {typemacro}\n"
        out += foot

    return out

def fun_NN_star():

    name = "fun_NN_star"

    for ext in ['cpp', 'hpp']:

        with open(f"{name}.{ext}", "w") as f:

            for T1,T2 in itertools.product(["_TYPE_NEW","_TYPE_PTR"], repeat=2):

                f.write(f"#define _TYPE_IN_1 {T1}\n")
                f.write(f"#define _TYPE_IN_2 {T2}\n")
                f.write(f"#include \"fun_NN.{ext}\"\n")
                f.write(f"#undef _TYPE_IN_2\n")
                f.write(f"#undef _TYPE_IN_1\n")
                f.write(f"\n")

def fun_N_types():

    for ext,suffix in itertools.product(['hpp','cpp'],['si','ui']):

        fname = f"fun_N{suffix}.{ext}"

        all_types = types[eval(f"P.{suffix}")]

        with open(fname, "w") as f:
            for t in ["_TYPE_NEW", "_TYPE_PTR"]:
                f.write(f"#define _TYPE_IN_1 {t}\n")
                for tt in all_types:
                    f.write(f"#define _TYPE_IN_2 {tt}\n")
                    f.write(f"#include \"fun_NB.{ext}\"\n")
                    f.write(f"#undef _TYPE_IN_2\n")
                f.write(f"#undef _TYPE_IN_1\n")
                f.write(f"\n")

def gen_builtin_files():

    for ext,suffix in itertools.product(['hpp','cpp'],['si','ui','df']):

        fname = f"fun_{suffix}_eq.{ext}"
        include_fname = f"fun_B_eq.{ext}"
        with open(fname, "w") as f:
            f.write(repeat_on_types(eval(f"P.{suffix}"),include_fname))

        fname = f"copys_{suffix}.{ext}"
        include_fname = f"copys_B.{ext}"
        with open(fname, "w") as f:
            f.write(repeat_on_types(eval(f"P.{suffix}"),include_fname))

        fname = f"cast_{suffix}.{ext}"
        include_fname = f"cast.{ext}"
        with open(fname, "w") as f:
            f.write(repeat_on_types(eval(f"P.{suffix}"),include_fname,typemacro="_CAST"))

def gen_ZZ_top():

    name = "ZZ_auto"

    hpp_name = f"ZZ/{name}_init.hpp"
    cpp_name = f"ZZ/{name}_init.cpp"

    hpp_lines = []
    cpp_lines = []

    for ext in ['hpp', 'cpp']:

        out  = f"#include \"../rule_of_five.{ext}\"\n"
        out += f"\n"
        out += f"#define _setfun _fun_paster(_ftype,set_si)\n"
        out += f"#include \"../copys_si.{ext}\"\n"
        out += f"#undef _setfun\n"
        out += f"\n"
        out += f"#define _setfun _fun_paster(_ftype,set_ui)\n"
        out += f"#include \"../copys_ui.{ext}\"\n"
        out += f"#undef _setfun\n"
        out += f"\n"
        out += f"#define _setfun _fun_paster(_ftype,set_d)\n"
        out += f"#include \"../copys_df.{ext}\"\n"
        out += f"#undef _setfun\n"
        out += f"\n"
        out += f"#define _setfun _fun_paster(_ftype,set_str)\n"
        out += f"#include \"../copy_string.{ext}\"\n"
        out += f"#undef _setfun\n"
        out += f"\n"
        out += f"#define _getfun _fun_paster(_ftype,get_str)\n"
        out += f"#include \"../cast_string.{ext}\"\n"
        out += f"#undef _getfun\n"
        out += f"\n"
        out += f"#define _getfun _fun_paster(_ftype,get_si)\n"
        out += f"#include \"../cast_si.{ext}\"\n"
        out += f"#undef _getfun\n"
        out += f"\n"
        out += f"#define _getfun _fun_paster(_ftype,get_ui)\n"
        out += f"#include \"../cast_ui.{ext}\"\n"
        out += f"#undef _getfun\n"
        out += f"\n"
        out += f"#define _getfun _fun_paster(_ftype,get_d)\n"
        out += f"#include \"../cast_df.{ext}\"\n"
        out += f"#undef _getfun\n"

        eval(f"{ext}_lines").append(out)

        with open(eval(f"{ext}_name"), "w") as f:
            f.write(out)

def gen_QQ_top():

    t = "QQ"

    name = f"{t}_auto"

    hpp_name = f"{t}/{name}_init.hpp"
    cpp_name = f"{t}/{name}_init.cpp"

    hpp_lines = []
    cpp_lines = []

    for ext in ['hpp', 'cpp']:

        out  = f"#include \"../rule_of_five.{ext}\"\n"
        out += f"\n"
        out += f"#define _setfun _fun_paster(_ftype,set_str)\n"
        out += f"#include \"../copy_string.{ext}\"\n"
        out += f"#undef _setfun\n"
        out += f"\n"
        out += f"#define _getfun _fun_paster(_ftype,get_str)\n"
        out += f"#include \"../cast_string.{ext}\"\n"
        out += f"#undef _getfun\n"
        out += f"\n"
        out += f"#define _getfun _fun_paster(_ftype,get_d)\n"
        out += f"#include \"../cast_df.{ext}\"\n"
        out += f"#undef _getfun\n"
        out += f"\n"

        eval(f"{ext}_lines").append(out)

        with open(eval(f"{ext}_name"), "w") as f:
            f.write(out)

def gen_QQ_fracs():

    t = "QQ"

    name = f"{t}_auto"

    hpp_name = f"{t}/{name}_copy_fracs.hpp"
    cpp_name = f"{t}/{name}_copy_fracs.cpp"

    hpp_lines = []
    cpp_lines = []

    for ext in ['hpp', 'cpp']:

        lines = eval(f"{ext}_lines")

        for t in ["ZZ", "ZZ_ptr"]:
            lines.append(f"#define _ZZ_TYPE {t}\n")
            lines.append(f"#include \"copy_fracs.{ext}\"\n")
            lines.append(f"#undef _ZZ_TYPE\n")

        for t in types[P.ui]:
            lines.append(f"#define _UI_TYPE {t}\n")
            lines.append(f"#include \"copy_fracs_ui.{ext}\"\n")
            lines.append(f"#undef _UI_TYPE\n")

        for t in types[P.si]:
            lines.append(f"#define _SI_TYPE {t}\n")
            lines.append(f"#include \"copy_fracs_si.{ext}\"\n")
            lines.append(f"#undef _SI_TYPE\n")

        for t1,t2 in itertools.product(["ZZ", "ZZ_ptr"],repeat=2):
            lines.append(f"#define _ZZ_TYPE_1 {t1}\n")
            lines.append(f"#define _ZZ_TYPE_2 {t2}\n")
            lines.append(f"#include \"copy_fracs_N_N.{ext}\"\n")
            lines.append(f"#undef _ZZ_TYPE_2\n")
            lines.append(f"#undef _ZZ_TYPE_1\n")

        for t1,t2 in itertools.product(types[P.ui],repeat=2):
            lines.append(f"#define _UI_TYPE_1 {t1}\n")
            lines.append(f"#define _UI_TYPE_2 {t2}\n")
            lines.append(f"#include \"copy_fracs_u_u.{ext}\"\n")
            lines.append(f"#undef _UI_TYPE_2\n")
            lines.append(f"#undef _UI_TYPE_1\n")

        for t1,t2 in itertools.product(types[P.si],repeat=2):
            lines.append(f"#define _SI_TYPE_1 {t1}\n")
            lines.append(f"#define _SI_TYPE_2 {t2}\n")
            lines.append(f"#include \"copy_fracs_s_s.{ext}\"\n")
            lines.append(f"#undef _SI_TYPE_2\n")
            lines.append(f"#undef _SI_TYPE_1\n")

        for s,u in itertools.product(types[P.si],types[P.ui]):
            lines.append(f"#define _SI_TYPE {s}\n")
            lines.append(f"#define _UI_TYPE {u}\n")
            lines.append(f"#include \"copy_fracs_s_u.{ext}\"\n")
            lines.append(f"#undef _UI_TYPE\n")
            lines.append(f"#undef _SI_TYPE\n")

        for t,s in itertools.product(["ZZ","ZZ_ptr"],types[P.su]):
            lines.append(f"#define _ZZ_TYPE {t}\n")
            lines.append(f"#define _SU_TYPE {s}\n")
            lines.append(f"#include \"copy_fracs_N_su.{ext}\"\n")
            lines.append(f"#undef _SU_TYPE\n")
            lines.append(f"#undef _ZZ_TYPE\n")

        with open(eval(f"{ext}_name"), "w") as f:
            for line in lines:
                f.write(line)

def gen_ZZ_funs():

    name = "ZZ_auto"

    hpp_name = f"ZZ/{name}_struct.hpp"
    cpp_name = f"ZZ/{name}_struct.cpp"
    foot_name = f"ZZ/{name}_funs.hpp"
    fun_name = f"ZZ/{name}_funs.cpp"

    hpp_lines = []
    cpp_lines = []
    foot_lines = []
    fun_lines = []

    # operators
    for token, name in [["+","add"],["-","sub"],["*","mul"], ["%", "mod"]]:

        head  = f"#define _TYPE_OUT _TYPE\n"
        head += f"#define _funname_eq operator{token}=\n"
        head += f"#define _funnative _fun_paster(_ftype,{name})\n"
        foot  = f"#undef _funnative\n"
        foot += f"#undef _funname_eq\n"
        foot += f"#undef _TYPE_OUT\n"
        foot += f"\n"

        for ext in ["hpp","cpp"]:

            out  = head
            out += f"#include \"../fun_NN_eq_star.{ext}\"\n"
            out += foot

            eval(f"{ext}_lines.append(out)")

        head  = f"#define _funname operator{token}\n"
        head += f"#define _funnative _fun_paster(_ftype,{name})\n"
        foot  = f"#undef _funnative\n"
        foot += f"#undef _funname\n"
        foot += f"\n"

        for ext in ["hpp","cpp"]:

            out  = head
            out += f"#include \"../fun_NN_star.{ext}\"\n"
            out += foot

            if ext=="cpp":
                fun_lines.append(out)
            else:
                foot_lines.append(out)

    # operators si/ui
    for token, name in [["+","add"],["-","sub"],["*","mul"]]:

        for prefix in ["si","ui"]:

            head  = f"#define _TYPE_OUT _TYPE\n"
            head += f"#define _funname_eq operator{token}=\n"
            head += f"#define _funnative _fun_paster(_ftype,{name}_{prefix})\n"
            foot  = f"#undef _funnative\n"
            foot += f"#undef _funname_eq\n"
            foot += f"#undef _TYPE_OUT\n"
            foot += f"\n"

            for ext in ["hpp","cpp"]:

                out  = head
                out += f"#include \"../fun_{prefix}_eq.{ext}\"\n"
                out += foot

                eval(f"{ext}_lines.append(out)")

            head  = f"#define _TYPE_OUT _TYPE\n"
            head += f"#define _funname operator{token}=\n"
            head += f"#define _funnative _fun_paster(_ftype,{name}_{prefix})\n"
            foot  = f"#undef _funnative\n"
            foot += f"#undef _funname\n"
            foot += f"#undef _TYPE_OUT\n"
            foot += f"\n"

            for ext in ["hpp","cpp"]:

                out  = head
                out += f"#include \"../fun_N{prefix}.{ext}\"\n"
                out += foot

                if ext=="cpp":
                    fun_lines.append(out)
                else:
                    foot_lines.append(out)


    # other functions: (N,N) -> N
    for name in ["cdiv_q", "fdiv_q", "tdiv_q", "divexact", "gcd"]:

        head  = f"#define _funname_eq _fun_eq_paster({name})\n"
        head += f"#define _funnative _fun_paster(_ftype,{name})\n"
        foot  = "#undef _funnative\n"
        foot += "#undef _funname_eq\n"
        foot += f"\n"

        for ext in ["hpp","cpp"]:

            out  = head
            out += f"#include \"../fun_NN_eq_star.{ext}\"\n"
            out += foot

            eval(f"{ext}_lines.append(out)")

    # other functions: (N,si/ui) -> N  (non-commutative)
    # TODO: I am here
    for name in ["cdiv_q", "fdiv_q", "tdiv_q", "divexact"]:

        for prefix in ['si','ui']:
            head  = f"#define _TYPE_OUT _TYPE\n"
            head += f"#define _funname_eq _fun_eq_paster({name})\n"
            head += f"#define _funnative _fun_paster(_ftype,{name}_{prefix})\n"
            foot  = "#undef _funnative\n"
            foot += "#undef _funname_eq\n"
            foot += f"#undef _TYPE_OUT\n"
            foot += f"\n"

            for ext in ["hpp","cpp"]:

                out  = head
                out += f"#include \"../fun_{prefix}_eq.{ext}\"\n"
                out += foot

                eval(f"{ext}_lines.append(out)")

            head  = f"#define _funname {name}\n"
            head += f"#define _funnative _fun_paster(_ftype,{name}_{prefix})\n"
            head += f"#define _noncommute\n"
            foot  = f"#undef _noncommute\n"
            foot += f"#undef _funnative\n"
            foot += f"#undef _funname\n"
            foot += f"\n"

            for ext in ["hpp","cpp"]:

                out  = head
                out += f"#include \"../fun_N{prefix}.{ext}\"\n"
                out += foot

                if ext=="cpp":
                    fun_lines.append(out)
                else:
                    foot_lines.append(out)

    # other functions: (N,ui) -> N
    for fun_name_eq,native in [["pow_eq","pow"],["operator%=","mod"]]:

        prefix = 'ui'

        head  = f"#define _TYPE_OUT _TYPE\n"
        head += f"#define _funname_eq {fun_name_eq}\n"
        head += f"#define _funnative _fun_paster(_ftype,{native}_{prefix})\n"
        foot  = "#undef _funnative\n"
        foot += "#undef _funname_eq\n"
        foot += f"#undef _TYPE_OUT\n"
        foot += f"\n"

        for ext in ["hpp","cpp"]:

            out  = head
            out += f"#include \"../fun_{prefix}_eq.{ext}\"\n"
            out += foot

            eval(f"{ext}_lines.append(out)")

    for name,native in [["pow","pow"],["operator%","mod"]]:

        prefix = 'ui'

        head  = f"#define _funname {name}\n"
        head += f"#define _funnative _fun_paster(_ftype,{native}_{prefix})\n"
        head += f"#define _noncommute\n"
        foot  = f"#undef _noncommute\n"
        foot += f"#undef _funnative\n"
        foot += f"#undef _funname\n"
        foot += f"\n"

        for ext in ["hpp","cpp"]:

            out  = head
            out += f"#include \"../fun_N{prefix}.{ext}\"\n"
            out += foot

            if ext=="cpp":
                fun_lines.append(out)
            else:
                foot_lines.append(out)

    # functions N -> N
    for name in ["abs"]:

        head  = f"#define _funname_eq _fun_eq_paster({name})\n"
        head += f"#define _funnative _fun_paster(_ftype,{name})\n"
        foot  = "#undef _funnative\n"
        foot += "#undef _funname_eq\n"
        foot += f"\n"

        for ext in ["hpp","cpp"]:

            out  = head
            out += f"#include \"../fun_N_eq.{ext}\"\n"
            out += foot

            eval(f"{ext}_lines.append(out)")

        for t in ["_TYPE_NEW", "_TYPE_PTR"]:
            head  = f"#define _funname {name}\n"
            head += f"#define _funnative _fun_paster(_ftype,{name})\n"
            head += f"#define _TYPE_IN {t}\n"
            foot  = f"#undef _TYPE_IN\n"
            foot += f"#undef _funnative\n"
            foot += f"#undef _funname\n"
            foot += f"\n"

            for ext in ["hpp","cpp"]:

                out  = head
                out += f"#include \"../fun_N.{ext}\"\n"
                out += foot

                if ext=="cpp":
                    fun_lines.append(out)
                else:
                    foot_lines.append(out)

    # functions with templates
    for fname in ["is_divisible_by"]:

        for type_in in ["_TYPE_NEW", "_TYPE_PTR"]:
            head  = f"#define _TYPE_IN {type_in}\n"
            foot  = "#undef _TYPE_IN\n"
            foot += f"\n"

            for ext in ["hpp","cpp"]:

                out  = head
                out += f"#include \"{fname}.{ext}\"\n"
                out += foot

                eval(f"{ext}_lines.append(out)")

    for lines,fname in [[hpp_lines,hpp_name], [cpp_lines,cpp_name],
                        [foot_lines,foot_name], [fun_lines,fun_name]]:
        with open(fname, "w") as f:
            for line in lines:
                f.write(line)


def addmul():

    name = "addmul_star"

    hpp_lines = []
    cpp_lines = []

    for ext in ["cpp", "hpp"]:
        lines = eval(f"{ext}_lines")
        for T1,T2 in itertools.product(["_TYPE_NEW", "_TYPE_PTR"], repeat=2):
            for op in ['add','sub']:
                lines.append(f"#define _ADDMUL {op}mul\n")
                lines.append(f"#define _native_addmul _fun_paster(_ftype,{op}mul)\n")
                lines.append(f"#define _TYPE_IN_1 {T1}\n")
                lines.append(f"#define _TYPE_IN_2 {T2}\n")
                lines.append(f"#include \"addmul.{ext}\"\n")
                lines.append(f"#undef _TYPE_IN_2\n")
                lines.append(f"#undef _TYPE_IN_1\n")
                lines.append(f"#undef _native_addmul\n")
                lines.append(f"#undef _ADDMUL\n")
                lines.append(f"\n")

        for T_NEW,T_UI,op in itertools.product(["_TYPE_NEW", "_TYPE_PTR"],
                                            types[P.ui],['add','sub']):

            lines.append(f"#define _ADDMUL {op}mul\n")
            lines.append(f"#define _native_addmul_ui _fun_paster(_ftype,{op}mul_ui)\n")
            lines.append(f"#define _TYPE_IN_NEW {T_NEW}\n")
            lines.append(f"#define _TYPE_IN_UI {T_UI}\n")
            lines.append(f"#include \"addmul_ui.{ext}\"\n")
            lines.append(f"#undef _TYPE_IN_UI\n")
            lines.append(f"#undef _TYPE_IN_NEW\n")
            lines.append(f"#undef _native_addmul_ui\n")
            lines.append(f"#undef _ADDMUL\n")
            lines.append(f"\n")

        for T_NEW,T_SI,op in itertools.product(["_TYPE_NEW", "_TYPE_PTR"],
                                               types[P.si],['add','sub']):
            opposite = 'sub' if op == 'add' else 'add'
            lines.append(f"#define _ADDMUL {op}mul\n")
            lines.append(f"#define _native_addmul_ui _fun_paster(_ftype,{op}mul_ui)\n")
            lines.append(f"#define _native_opmul_ui _fun_paster(_ftype,{opposite}mul_ui)\n")
            lines.append(f"#define _TYPE_IN_NEW {T_NEW}\n")
            lines.append(f"#define _TYPE_IN_SI {T_SI}\n")
            lines.append(f"#include \"addmul_si.{ext}\"\n")
            lines.append(f"#undef _TYPE_IN_SI\n")
            lines.append(f"#undef _TYPE_IN_NEW\n")
            lines.append(f"#undef _native_opmul_ui\n")
            lines.append(f"#undef _native_addmul_ui\n")
            lines.append(f"#undef _ADDMUL\n")
            lines.append(f"\n")

        for T_I_1,T_I_2,op in itertools.product(types[P.su], types[P.su],['add','sub']):
            lines.append(f"#define _ADDMUL {op}mul\n")
            lines.append(f"#define _TYPE_IN_INT_1 {T_I_1}\n")
            lines.append(f"#define _TYPE_IN_INT_2 {T_I_2}\n")
            lines.append(f"#include \"addmul_II.{ext}\"\n")
            lines.append(f"#undef _TYPE_IN_INT_2\n")
            lines.append(f"#undef _TYPE_IN_INT_1\n")
            lines.append(f"#undef _ADDMUL\n")
            lines.append(f"\n")

    for t in ["cpp", "hpp"]:
        with open(f"{name}.{t}", "w") as f:
            for line in eval(f"{t}_lines"):
                f.write(line)

def compare():

    name = "compare_star"

    hpp_name = f"{name}_eq.hpp"
    cpp_name = f"{name}_eq.cpp"

    hpp_lines = []
    cpp_lines = []

    for ext in ["cpp", "hpp"]:
        lines = eval(f"{ext}_lines")
        for T in ["_TYPE_NEW", "_TYPE_PTR"]:
            lines.append(f"#define _TYPE_IN {T}\n")
            lines.append(f"#define _equalfun _fun_paster(_ftype,equal)\n")
            lines.append(f"#define _cmpfun _fun_paster(_ftype,cmp)\n")
            lines.append(f"#include \"compare.{ext}\"\n")
            lines.append(f"#undef _cmpfun\n")
            lines.append(f"#undef _equalfun\n")
            lines.append(f"#undef _TYPE_IN\n")
            lines.append(f"\n")

        with open(f"{name}.{ext}", "w") as f:
            for line in lines:
                f.write(line)

def fmma():

    for mid in ["","_eq"]:

        name = f"fmma{mid}_star"

        hpp_lines = []
        cpp_lines = []

        # way too many possible (really slow compilation)
        #all_types = ['_TYPE_NEW', '_TYPE_PTR'] + types[P.su]

        all_types = ['_TYPE_NEW', '_TYPE_PTR']

        for ext in ["cpp", "hpp"]:
            lines = eval(f"{ext}_lines")
            for tup in itertools.product(all_types, repeat=4):
                for op in ['a','s']:
                    lines.append(f"#define _FMMA fmm{op}{mid}\n")
                    lines.append(f"#define _native_fmma _fun_paster(_ftype,fmm{op})\n")
                    for index,t in enumerate(tup):
                        lines.append(f"#define _TYPE_IN_{index+1} {t}\n")
                    lines.append(f"#include \"fmma{mid}.{ext}\"\n")
                    for index,_ in enumerate(tup):
                        lines.append(f"#undef _TYPE_IN_{index+1}\n")
                    lines.append(f"#undef _native_fmma\n")
                    lines.append(f"#undef _FMMA\n")
                    lines.append(f"\n")

        for t in ["cpp", "hpp"]:
            with open(f"{name}.{t}", "w") as f:
                for line in eval(f"{t}_lines"):
                    f.write(line)

def gen_QQ_funs():

    t = "QQ"

    name = f"{t}_auto"

    hpp_name = f"{t}/{name}_struct.hpp"
    cpp_name = f"{t}/{name}_struct.cpp"
    foot_name = f"{t}/{name}_funs.hpp"
    fun_name = f"{t}/{name}_funs.cpp"

    hpp_lines = []
    cpp_lines = []
    foot_lines = []
    fun_lines = []

    # operators
    for token, name in [["+","add"],["-","sub"],["*","mul"],["/","div"]]:

        for ext in ["hpp","cpp"]:

            out  = f"#define _TYPE_OUT _TYPE\n"
            out += f"#define _funname_eq operator{token}=\n"
            out += f"#define _funnative _fun_paster(_ftype,{name})\n"
            out += f"#include \"../fun_NN_eq_star.{ext}\"\n"
            out += f"#undef _funnative\n"
            out += f"#undef _funname_eq\n"
            out += f"#undef _TYPE_OUT\n"
            out += f"\n"

            eval(f"{ext}_lines.append(out)")

            out  = f"#define _funname operator{token}\n"
            out += f"#define _funnative _fun_paster(_ftype,{name})\n"
            out += f"#include \"../fun_NN_star.{ext}\"\n"
            out += f"#undef _funnative\n"
            out += f"#undef _funname\n"
            out += f"\n"

            if ext=="cpp":
                fun_lines.append(out)
            else:
                foot_lines.append(out)

    for token, name in [["+","add"],["-","sub"],["*","mul"],["/","div"]]:
        for ext in ["hpp","cpp"]:
            for t in ["ZZ","ZZ_ptr"]:

                out  = f"#define _TYPE_IN {t}\n"
                out += f"#define _funname_eq operator{token}=\n"

                suffix = f"{name}_fmpz"

                out += f"#define _funnative _fun_paster(_ftype,{suffix})\n"
                out += f"#include \"../fun_NN_eq.{ext}\"\n"
                out += f"#undef _funnative\n"
                out += f"#undef _funname_eq\n"
                out += f"#undef _TYPE_IN\n"
                out += f"\n"

                eval(f"{ext}_lines.append(out)")

            if name in ["div"]:
                for t in types[P.su]:

                    out  = f"#define _TYPE_OUT _TYPE\n"
                    out += f"#define _TYPE_IN {t}\n"
                    out += f"#define _funname_eq operator{token}=\n"
                    out += f"#define _noncommute\n"
                    out += f"#include \"../fun_B_coerce_eq.{ext}\"\n"
                    out += f"#undef _noncommute\n"
                    out += f"#undef _funname_eq\n"
                    out += f"#undef _TYPE_IN\n"
                    out += f"#undef _TYPE_OUT\n"
                    out += f"\n"

                    eval(f"{ext}_lines.append(out)")
            else:
                for suffix in ["si","ui"]:
                    for t in types[eval(f"P.{suffix}")]:

                        out  = f"#define _TYPE_OUT _TYPE\n"
                        out += f"#define _TYPE_IN {t}\n"
                        out += f"#define _funname_eq operator{token}=\n"

                        out += f"#define _funnative _fun_paster(_ftype,{name}_{suffix})\n"
                        out += f"#include \"../fun_B_eq.{ext}\"\n"
                        out += f"#undef _funnative\n"
                        out += f"#undef _funname_eq\n"
                        out += f"#undef _TYPE_IN\n"
                        out += f"#undef _TYPE_OUT\n"
                        out += f"\n"

                        eval(f"{ext}_lines.append(out)")

            for q,z in itertools.product(["QQ","QQ_ptr"],["ZZ","ZZ_ptr"]):

                out  = f"#define _funname operator{token}\n"
                out += f"#define _funnative _fun_paster(_ftype,{name}_fmpz)\n"
                out += f"#define _TYPE_QQ {q}\n"
                out += f"#define _TYPE_ZZ {z}\n"

                if name in ["div"]:
                    out += f"#define _noncommute\n"

                out += f"#include \"fun_QZ.{ext}\"\n"

                if name in ["div"]:
                    out += f"#undef _noncommute\n"

                out += f"#undef _TYPE_ZZ\n"
                out += f"#undef _TYPE_QQ\n"
                out += f"#undef _funnative\n"
                out += f"#undef _funname\n"
                out += f"\n"

                if ext=="cpp":
                    fun_lines.append(out)
                else:
                    foot_lines.append(out)

    #for token, name in [["+","add"],["-","sub"],["*","mul"],["/","div"]]:
    for token, name in [["+","add"],["-","sub"],["*","mul"]]:
        for ext in ["hpp","cpp"]:
            for suffix in ["si","ui"]:
                for q,z in itertools.product(["QQ","QQ_ptr"],types[eval(f"P.{suffix}")]):

                    out  = f"#define _funname operator{token}\n"
                    out += f"#define _funnative _fun_paster(_ftype,{name}_{suffix})\n"
                    out += f"#define _TYPE_QQ {q}\n"
                    out += f"#define _TYPE_B {z}\n"

                    if name in ["div"]:
                        out += f"#define _noncommute\n"

                    out += f"#include \"fun_QB.{ext}\"\n"

                    if name in ["div"]:
                        out += f"#undef _noncommute\n"

                    out += f"#undef _TYPE_B\n"
                    out += f"#undef _TYPE_QQ\n"
                    out += f"#undef _funnative\n"
                    out += f"#undef _funname\n"
                    out += f"\n"

                    if ext=="cpp":
                        fun_lines.append(out)
                    else:
                        foot_lines.append(out)

    # functions N -> N
    for name in ["abs"]:

        head  = f"#define _funname_eq _fun_eq_paster({name})\n"
        head += f"#define _funnative _fun_paster(_ftype,{name})\n"
        foot  = "#undef _funnative\n"
        foot += "#undef _funname_eq\n"
        foot += f"\n"

        for ext in ["hpp","cpp"]:

            out  = head
            out += f"#include \"../fun_N_eq.{ext}\"\n"
            out += foot

            eval(f"{ext}_lines.append(out)")

        for t in ["_TYPE_NEW", "_TYPE_PTR"]:
            head  = f"#define _funname {name}\n"
            head += f"#define _funnative _fun_paster(_ftype,{name})\n"
            head += f"#define _TYPE_IN {t}\n"
            foot  = f"#undef _TYPE_IN\n"
            foot += f"#undef _funnative\n"
            foot += f"#undef _funname\n"
            foot += f"\n"

            for ext in ["hpp","cpp"]:

                out  = head
                out += f"#include \"../fun_N.{ext}\"\n"
                out += foot

                if ext=="cpp":
                    fun_lines.append(out)
                else:
                    foot_lines.append(out)

    for lines,fname in [[hpp_lines,hpp_name], [cpp_lines,cpp_name],
                        [foot_lines,foot_name], [fun_lines,fun_name]]:
        with open(fname, "w") as f:
            for line in lines:
                f.write(line)

def pow_QQ():

    t = "QQ"

    fname = f"{t}_auto_struct"

if __name__ == "__main__":

    gen_builtin_files()

    fun_NN_star()

    fun_N_types()

    gen_ZZ_top()
    gen_ZZ_funs()

    gen_QQ_top()
    gen_QQ_fracs()
    gen_QQ_funs()

    addmul()
    compare()
    fmma()
