#pragma once

#include "myflint_fmpz.hpp"

// flint
#include <flint/flint.h>
#include <flint/fmpz_factor.h>


template<typename T>
class Factorization
{
  public:
    vector<tuple<T,int64_t>> prime_factors;
    vector<tuple<T,int64_t>> other_factors;

    Factorization();
    Factorization(const T& in);
    Factorization(const vector<tuple<T,int64_t>>& in);
    Factorization(const Factorization<T>& other);

    Factorization<T>& operator=(const Factorization<T>& other);

    Factorization<T>& operator*=(const Factorization<T>& rhs);
    Factorization<T>& operator*(const Factorization<T>& rhs) const;

    Factorization<T>& operator/=(const Factorization<T>& rhs);
    Factorization<T>& operator/(const Factorization<T>& rhs) const;

    T product() const;
};

  template <typename T>
Factorization<T>::Factorization()
{
  prime_factors = {};
  other_factors = {};
}

  template <typename T>
Factorization<T>::Factorization(const Factorization<T>& other)
{
  prime_factors = other.prime_factors;
  other_factors = other.other_factors;
}

  template <typename T>
Factorization<T>& Factorization<T>::operator=(const Factorization<T>& other)
{
  prime_factors = other.prime_factors;
  other_factors = other.other_factors;

  return *this;
}


ostream& operator<<(ostream& os, const Factorization<Fmpz>& factors);


class Factor
{
  public:
    fmpz_factor_t data;
    slong bits;

    Factor();
    Factor(slong in_bits);

    // do not duplicate a factor object
    Factor(const Factor &other) = delete;
    Factor& operator=(const Factor &other) = delete;

    Factorization<Fmpz> operator()(const Fmpz& in);

    ~Factor();

};

//ostream& operator<<(ostream& os, const Factor& f);


tuple<int64_t,Fmpz> root_perfect_power(const Fmpz& in);

