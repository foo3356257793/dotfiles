#pragma once

#include <algorithm>
#include <functional>
#include <iomanip>
#include <iostream>
#include <memory>
#include <numeric>
#include <tuple>
#include <vector>

using namespace std;

#include <fmt/core.h>
#include <fmt/ostream.h>

using fmt::print;

// flint
#include <flint/flint.h>
#include <flint/fmpz.h>

class ZZ {
public:
  fmpz_t number;

  ZZ() { fmpz_init(number); }

  ZZ(const int64_t &in_number) { fmpz_init_set_si(number, in_number); }

  ZZ(const fmpz_t &in_number) { fmpz_init_set(number, in_number); }

  ZZ(const string in_string) : ZZ() {
    fmpz_set_str(number, in_string.c_str(), 10);
  }

  ZZ(const ZZ &other) : ZZ(other.number) {} // copy constructor

  ZZ(ZZ &&other) noexcept : ZZ() { // move constructor
    swap(number, other.number);
  }

  ZZ &operator=(const ZZ &other) { // copy assignment
    fmpz_set(number, other.number);
    return *this;
  }

  ZZ &operator=(ZZ &&other) noexcept { // move assignment
    swap(number, other.number);
    return *this;
  }

  ~ZZ() { // destructor
    fmpz_clear(number);
  }

  ZZ &apply_fmpz_fun_eq(const ZZ &rhs,
                        const function<void(fmpz_t, fmpz_t, const fmpz_t)>& fun) {
    fun(number, number, rhs.number);
    return *this;
  }

  ZZ apply_fmpz_fun(
      const ZZ &rhs,
      const function<void(fmpz_t, const fmpz_t, const fmpz_t)>& fun) const {
    auto result = ZZ();
    fun(result.number, number, rhs.number);
    return result;
  }

  ZZ apply_fmpz_fun(function<void(fmpz_t, const fmpz_t)> fun) const {
    auto result = ZZ();
    fun(result.number, number);
    return result;
  }

  ZZ &operator+=(const ZZ &rhs) { return apply_fmpz_fun_eq(rhs, fmpz_add); }
  ZZ operator+(const ZZ &rhs) const { return apply_fmpz_fun(rhs, fmpz_add); }
  ZZ &operator-=(const ZZ &rhs) { return apply_fmpz_fun_eq(rhs, fmpz_sub); }
  ZZ operator-(const ZZ &rhs) const { return apply_fmpz_fun(rhs, fmpz_sub); }
  ZZ &operator*=(const ZZ &rhs) { return apply_fmpz_fun_eq(rhs, fmpz_mul); }
  ZZ operator*(const ZZ &rhs) const { return apply_fmpz_fun(rhs, fmpz_mul); }
  ZZ &operator%=(const ZZ &rhs) { return apply_fmpz_fun_eq(rhs, fmpz_mod); }
  ZZ operator%(const ZZ &rhs) const { return apply_fmpz_fun(rhs, fmpz_mod); }
  ZZ &operator/=(const ZZ &rhs) {
    return apply_fmpz_fun_eq(rhs, fmpz_divexact);
  }
  ZZ operator/(const ZZ &rhs) const {
    return apply_fmpz_fun(rhs, fmpz_divexact);
  }
  ZZ operator-() const { return apply_fmpz_fun(fmpz_neg); }
  void addmul(const ZZ &in0, const ZZ &in1) {
    fmpz_addmul(number, in0.number, in1.number);
  }
  void submul(const ZZ &in0, const ZZ &in1) {
    fmpz_submul(number, in0.number, in1.number);
  }
  bool operator==(const ZZ &rhs) const {
    return (bool)fmpz_equal(number, rhs.number);
  }
  bool operator!=(const ZZ &rhs) const {
    return !(fmpz_equal(number, rhs.number));
  }
  bool operator>(const ZZ &rhs) const {
    return (fmpz_cmp(number, rhs.number) > 0);
  }
  bool operator>=(const ZZ &rhs) const {
    return (fmpz_cmp(number, rhs.number) >= 0);
  }
  bool operator<=(const ZZ &rhs) const {
    return (fmpz_cmp(number, rhs.number) <= 0);
  }
  bool operator<(const ZZ &rhs) const {
    return (fmpz_cmp(number, rhs.number) < 0);
  }

  bool is_divisible_by(const ZZ &poss_factor) const {
    return fmpz_divisible(number, poss_factor.number);
  }
};

ZZ abs(const ZZ &in) { return in.apply_fmpz_fun(fmpz_abs); }

bool is_prime(const ZZ &in) {
  auto result = fmpz_is_prime(in.number);
  return (result != 0);
}

ZZ pow(ZZ base, int64_t exponent) {
  if (exponent < 0) {
    throw invalid_argument("Negative exponentiation not supported for ZZ");
  }

  auto result = ZZ();
  fmpz_pow_ui(result.number, base.number, (uint64_t)exponent);

  return result;
}

ostream &operator<<(ostream &os, const ZZ &f) {
  char *out_string = fmpz_get_str(NULL, 10, f.number);
  os << out_string;
  free(out_string);

  return os;
}
