#!/usr/bin/sage

import itertools

def find_completions(base, e_c):

    if e_c == 1:

        return [base]

    fac_e_c = factor(e_c)

    prime_factors = [tup[0] for tup in fac_e_c if tup[0] > 1]

    p = prime_factors[-1]

    e_c /= p

    if e_c % p != 0:

        # need to include p in base
        base *= p^2

        new_e_c = (p-1) * e_c

        G = gcd(base, new_e_c)

        while G > 1:

            new_e_c /= G

            G = gcd(G, new_e_c)

        return find_completions(base, new_e_c)

    # need to branch on whether to include p
    while e_c % p == 0:
        e_c /= p

    base_w_p = base * p^2

    new_e_c = (p-1) * e_c

    G = gcd(base, new_e_c)

    while G > 1:

        new_e_c /= G

        G = gcd(G, new_e_c)

    ret_w_p = find_completions(base_w_p, new_e_c)

    ret_w_no_p = find_completions(base, e_c)

    return ret_w_p + ret_w_no_p

def check_achilles(C):

    fac_C = factor(C)

    gcd_coeffs = gcd([tup[1] for tup in fac_C if tup[0] > 1])

    return (gcd_coeffs == 1)

def check_strong_achilles(C):

    if check_achilles(C):

        return check_achilles(euler_phi(C))

    return False

def branch_strong_achilles(C, n, base_primes, index):

    if C > n:
        return []

    if index >= len(base_primes):
        # done
        if check_strong_achilles(C):
            return [C]
        return []

    ret = []
    for extra_pow in range(3):

        ret += branch_strong_achilles(C, n, base_primes, index+1)
        C *= base_primes[index]
        if C >= n:
            break

    return ret

def find_strong_achilles_forms(C, base, n):

    fac_C = factor(C)

    if len(fac_C) <= 1:
        # can't do it
        return []

    fac_base = factor(base)
    base_primes = [tup[0] for tup in fac_base if tup[0] > 1]

    return branch_strong_achilles(C, n, base_primes, 0)


if __name__ == "__main__":

    n = 10**8

    max_cube_part = floor(n**(1/3))

    strong_achilles_numbers = []

    for c in range(1,max_cube_part+1):

        if c % (10) == 0:
            print('c=%d...' % c)

        e_c = euler_phi(c)

        # get piece which is coprime to c

        G = gcd(e_c, c)

        while G > 1:

            e_c /= G

            G = gcd(e_c, G)

        compl = find_completions(c, e_c)

        for C in compl:

            C *= c^2

            if C <= n:

                ret = find_strong_achilles_forms(C, c, n)

                for val in ret:

                    if not val in strong_achilles_numbers:

                        strong_achilles_numbers.append(val)

    print("found %d strong achilles below %d" % (len(strong_achilles_numbers),
        n))
