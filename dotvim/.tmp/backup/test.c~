#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define DIM 10

#define PRINTROW(a) for(int ipr=0; ipr<DIM; ipr++){\
    printf("%2d ", (a)[ipr]);\
}\
printf("\n")

inline int div_mod_m(int a, int b, int m)
{
    // requires m to be odd

    int c = 0; int d = m;

    int tmp;
    while(b > 0)
    {
        if(!(b&1))
        {
            a += (a&1) ? m : 0;
            a>>=1;
            b>>=1;
        }
        c -= a;
        d -= b;
        c += (c<0) ? m : 0;
        if(!(d&1))
        {
            c += (c&1) ? m : 0;
            c>>=1;
            d>>=1;
        }
        if(d < b)
        {
            tmp=a; a=c; c=tmp;
            tmp=b; b=d; d=tmp;
        }
    }

    c += (c<=0) ? m : 0;

    return c/d;

}

inline void swap_rows(int * restrict a, int * restrict b, int * restrict tmp)
{
    for(int s=0; s<DIM; s++)
    {
        tmp[s] = a[s];
        a[s] = b[s];
        b[s] = tmp[s];
    }
}

int main(int argc, char *argv[])
{

    srand(time(NULL));

    int p = 3;
    int M = p * p * p * p;

    int __attribute__((aligned(64))) a[DIM][DIM];

    int __attribute__((aligned(64))) ker[DIM][DIM];

    #if 0
    for(int i=0; i<DIM; i++)
    {
        for(int j=0; j<DIM; j++)
        {
            a[i][j] = random() % M;
        }
    }
    #endif
    for(int j=0; j<DIM; j++)
    {
        a[0][j] = 1;
    }

    for(int j=0; j<DIM; j++)
    {
        a[1][j] = j;
    }

    for(int i=2; i<DIM; i++)
    {
        for(int j=0; j<DIM; j++)
        {
            a[i][j] = (a[i-1][j] * j) % M;
        }
    }

    printf("Here is mat\n");
    for(int i=0; i<DIM; i++)
    {
        PRINTROW(a[i]);
    }

    int __attribute__((aligned(64))) tmp[DIM];

    // put in HNF
    int col = 0;
    int row = 0;
    while(col < (DIM-1))
    {
        // at this point, working with submatrix starting at ('row','col')

        // find a nonzero row in the col
        int tmp_row = row;
        while(a[tmp_row][col] == 0 && tmp_row < DIM)
        {
            tmp_row++;
        }
        // if we found a nonzero, proceed
        if(tmp_row < DIM){
            // swap rows so that nonzero at the head
            if(tmp_row > row)
            {
                swap_rows(a[row], a[tmp_row], tmp);
            }

            // divide out by 2 as much as possible
            while(!(a[row][col] & 1))
            {
                for(int s=col; s<DIM; s++)
                {
                    a[row][s] += (a[row][s] & 1) ? M : 0;
                    a[row][s] >>= 1;
                }
            }

            // make each row have 0 in col
            for(int tmp_row = row+1; tmp_row < DIM; tmp_row++)
            {
                // divide out by 2 as much as possible
                while(a[tmp_row][col] && !(a[row][col] & 1))
                {
                    for(int s=col; s<DIM; s++)
                    {
                        a[row][s] += (a[row][s] & 1) ? M : 0;
                        a[row][s] >>= 1;
                    }
                }

                // if nonzero and less than leading value, swap
                if(a[tmp_row][col] && a[tmp_row][col] < a[row][col])
                {
                    swap_rows(a[row], a[tmp_row], tmp);
                }
                while(a[tmp_row][col])
                {
                    // at this point, a[tmp_row][col] >= a[row][col]
                    for(int s=col; s<DIM; s++)
                    {
                        a[tmp_row][s] -= a[row][s];
                        a[tmp_row][s] += (a[tmp_row][s] < 0) ? M : 0;
                    }

                    // divide out by 2 as much as possible
                    while(a[tmp_row][col] && !(a[tmp_row][col] && 1))
                    {
                        for(int s=col; s<DIM; s++)
                        {
                            a[tmp_row][s] += (a[tmp_row][s] & 1) ? M : 0;
                            a[tmp_row][s] >>= 1;
                        }
                    }

                    // if nonzero and smaller, swap
                    if(a[tmp_row][col] && a[tmp_row][col] < a[row][col])
                    {
                        swap_rows(a[row], a[tmp_row], tmp);
                    }
                }
            }
            row++;
        }
        col++;
    }

    row=0;
    col=0;
    while(col < DIM)
    {
        if(a[row][col]==0)
        {
            printf("zero row\n");
            // then diag element at col = 'row' works
            for(int s=0; s<DIM; s++)
            {
                ker[col][s] = (s==row) ? 1 : 0;
                ker[s][row] = (s==col) ? 1 : 0;
            }
        }
        else
        {
            for(int s = col+1; s<DIM; s++)
            {
                ker[col][s] = 0;
            }
            int tmp_row = row;
            int tmp_col = col;
            while(tmp_row >= 0)
            {
                // find start of column
                while(tmp_col>0 && a[tmp_row][tmp_col-1] != 0)
                {
                    tmp_col--;
                }

                int part_sum = 0;
                for(int s=col; s>tmp_col; s--)
                {
                    part_sum -= a[tmp_row][s] * ker[col][s];
                }
                int div = a[tmp_row][tmp_col];
                while(part_sum < 0)
                {
                    part_sum += (part_sum&1) ? M : 0;
                    div += (div&1) ? M : 0;
                    part_sum >>= 1;
                    div >>= 1;
                }
                part_sum = (part_sum) ? part_sum : M;

                ker[col][tmp_col] = div_mod_m(part_sum,div,M);
                if(ker[col][tmp_col] == M && col > tmp_col)
                    ker[col][tmp_col] = 0;

                tmp_row--;
            }
            if(ker[col][col]==0)
                ker[col][col] = M;

            row++;
        }

        col++;

    }

    printf("Here is mat after reduction\n");
    for(int i=0; i<DIM; i++)
    {
        PRINTROW(a[i]);
    }

    printf("Here is ker\n");
    for(int i=0; i<DIM; i++)
    {
        PRINTROW(ker[i]);
    }

    exit(0);
}

