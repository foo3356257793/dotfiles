#!/usr/bin/sage

import itertools

def flip_on_point(mat, i, j):

    for k in range(N):

        mat[k,j] += 1

    for k in range(N):

        mat[i,k] += 1

    mat[i,j] += 1


if __name__ == "__main__":

    # 1 : 1
    # 2 : 1
    # 3 : 3
    # 4 : 6
    # 5 : 3
    # 6 : 17
    # 7 : 0
    # 8 : 23
    # 9 : 0
    # 10 : 29

    for N in [2^i - i for i in range(3,6)]:

        GF2 = GF(2)

        mat = matrix(GF2, N, N)

        for x in range(N):
            for y in range(N):

                len_sq = x*x + y*y

                if (N-1)*(N-1) <= len_sq and len_sq < N*N:

                    mat[x,y] = 1

        #print(mat)

        # N = 5 moves
        # flip_on_point(mat, 4, 3)
        # flip_on_point(mat, 3, 4)
        # flip_on_point(mat, 3, 3)

        # flip row 4, 3, 3 -> 4
        # flip col 3, 4, 3 -> 4
        # flip pts (3,3), (4,3), (3,4)

        """
        # N = 10 moves
        moves = [[9,5],[8,6],[6,8],[5,9],[8,8],[5,5],[6,6]]

        for pt in moves:
            flip_on_point(mat, pt[0], pt[1])

        print("")
        print(mat)
        """

        # try to solve by LA
        sol_mat = matrix(GF2, N*N, N*N)
        i = 0
        for tup in itertools.product(range(N), repeat=2):

            x = tup[0]
            y = tup[1]

            for k in range(N):

                sol_mat[i, N*x+k] = 1
                sol_mat[i, N*k+y] = 1

            i += 1

        target_vec = vector(GF2, N*N)

        for i in range(N):
            for j in range(N):
                target_vec[N*i+j] = mat[i,j]

        try:
            sol_vec = sol_mat.solve_left(target_vec)

            num_moves = 0
            for i in range(N*N):
                if sol_vec[i] == 1:
                    num_moves += 1

                    pt = [i//N, i%N]
                    #print(pt)

            print('N=%d : takes %d moves' % (N,num_moves))

        except:

            print('N=%d : 0' % (N))
