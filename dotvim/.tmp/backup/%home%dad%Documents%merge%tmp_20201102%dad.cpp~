// stl
#include <algorithm>
#include <iostream>
#include <memory>
#include <numeric>
#include <tuple>
#include <vector>
#include <sstream>

using namespace std;

// fmt
#include <fmt/core.h>
#include <fmt/ostream.h>

using fmt::print;

// pybind11
#include <pybind11/pybind11.h>
#include <pybind11/stl.h>
#include <pybind11/complex.h>

#include <pybind11/functional.h>
#include <pybind11/chrono.h>
#include <pybind11/operators.h>

namespace py = pybind11;

// flint
#include <flint/flint.h>
#include <flint/fmpzxx.h>
#include <flint/fmpqxx.h>

using flint::fmpzxx;
using flint::fmpqxx;

// easy printing of vectors
template <typename T>
std::ostream& operator<< (std::ostream& out, const std::vector<T>& v) {
  if ( !v.empty() ) {
    out << '[';
    std::copy (v.begin(), v.end(), std::ostream_iterator<T>(out, ", "));
    out << "\b\b]";
  }
  return out;
}

vector<tuple<fmpzxx,int64_t>> factor_and_parse(const fmpzxx &number)
{

  if(number == 0)
  {
    throw invalid_argument("factoring 0 not defined.");
  }

  if(number == 1 || number == -1) return {};

  auto factorization = factor(number);

  auto num_factors = factorization.size();

  vector<tuple<fmpzxx,int64_t>> result = {};

  // TODO: double check that everything is a factor
  // of the input
  // see if there is stuff left over

  for(ulong index=0; index<num_factors; index++)
  {
    auto base = factorization.p(index);
    auto exponent = factorization.exp(index);

    result.push_back(make_tuple(fmpzxx(base),exponent));
  }

  return result;
}

vector<tuple<fmpzxx,int64_t>> merge_factorization_vectors(
    vector<tuple<fmpzxx,int64_t>> in_0,
    vector<tuple<fmpzxx,int64_t>> in_1)
{
  auto it_0 = in_0.begin();
  const auto end_0 = in_0.end();

  auto it_1 = in_1.begin();
  const auto end_1 = in_1.end();

  vector<tuple<fmpzxx,int64_t>> result = {};

  while(it_0 < end_0 && it_1 < end_1)
  {
    const auto[number_0,exponent_0] = *it_0;
    const auto[number_1,exponent_1] = *it_1;

    if(number_0 < number_1)
    {
      result.insert(result.end(), it_0, it_0+1);
      ++it_0;
    }
    else if(number_0 > number_1)
    {
      result.insert(result.end(), it_1, it_1+1);
      ++it_1;
    }
    else
    {
      auto exponent = exponent_0 + exponent_1;
      if(exponent != 0)
      {
        result.push_back(make_tuple(number_0,exponent));
      }
      ++it_0;
      ++it_1;
    }
  }

  // insert leftovers
  // at least one of these does nothing
  result.insert(result.end(), it_0, end_0);
  result.insert(result.end(), it_1, end_1);

  return result;

}
vector<tuple<fmpzxx,int64_t>> merge_divide_factorization_vectors(
    vector<tuple<fmpzxx,int64_t>> in_0,
    vector<tuple<fmpzxx,int64_t>> in_1)
{
  auto it_0 = in_0.begin();
  const auto end_0 = in_0.end();

  auto it_1 = in_1.begin();
  const auto end_1 = in_1.end();

  vector<tuple<fmpzxx,int64_t>> result = {};

  while(it_0 < end_0 && it_1 < end_1)
  {
    const auto[number_0,exponent_0] = *it_0;
    const auto[number_1,exponent_1] = *it_1;

    if(number_0 < number_1)
    {
      result.insert(result.end(), it_0, it_0+1);
      ++it_0;
    }
    else if(number_0 > number_1)
    {
      result.push_back(make_tuple(number_1,-exponent_1));
      ++it_1;
    }
    else
    {
      auto exponent = exponent_0 - exponent_1;
      if(exponent != 0)
      {
        result.push_back(make_tuple(number_0,exponent));
      }
      ++it_0;
      ++it_1;
    }
  }

  // insert leftovers
  // at least one of these does nothing
  result.insert(result.end(), it_0, end_0);

  while(it_1 < end_1)
  {
    const auto[number_1,exponent_1] = *it_1;
    result.push_back(make_tuple(number_1,-exponent_1));
    ++it_1;
  }

  return result;

}

vector<tuple<fmpzxx,int64_t>> pow_factorization_vector(
    vector<tuple<fmpzxx,int64_t>> in,
    int64_t exponent)
{
  if(exponent==1) return in;

  vector<tuple<fmpzxx,int64_t>> result = {};

  for(auto &tup : in)
  {
    auto[base, orig_exponent] = tup;
    result.push_back(make_tuple(base, orig_exponent * exponent));
  }

  return result;

}


fmpqxx product_factors(vector<tuple<fmpzxx,int64_t>> in_factors)
{
  fmpqxx result;
  result.set_one();

  for(auto &tup : in_factors)
  {
    auto[base, exponent] = tup;

    // TODO: can I define this conversion from fmpzxx to fmpqxx?
    fmpqxx base_q;
    base_q.set_integer(base);

    result *= pow(base_q, exponent);
  }

  return result;
}

// call flint's factor and put everything into a vector
vector<tuple<fmpzxx,int64_t>> factor_and_parse(const fmpqxx &number)
{

  auto numer_factors = factor_and_parse(fmpzxx(number.num()));
  auto denom_factors = factor_and_parse(fmpzxx(number.den()));

  auto result = merge_divide_factorization_vectors(numer_factors, denom_factors);

  return result;
}

vector<tuple<fmpzxx,int64_t>> parse_but_dont_process(const fmpqxx &number)
{
  auto num = fmpzxx(number.num());
  if(num < 0) num = -num;

  auto den = fmpzxx(number.den());
  if(den < 0) den = -den;

  vector<tuple<fmpzxx,int64_t>> result = {};

  if(num != 1)
  {
    result.push_back(make_tuple(num, 1));
  }
  if(den != 1)
  {
    result.push_back(make_tuple(den, -1));
  }

  return result;
}

auto fmpzxx_to_string(fmpzxx a)
{
  stringstream ss;
  ss << a;
  return ss.str();
}

auto factors_vec_to_strings(vector<tuple<fmpzxx,int64_t>> vec)
{
  auto result = vector<tuple<string,int64_t>>();

  for(auto &tup : vec)
  {
    auto[factor,exponent] = tup;
    auto string_tup = make_tuple(fmpzxx_to_string(factor),exponent);
    result.push_back(string_tup);
  }

  return result;
}

class Factorization {
  public:
    fmpqxx number;
    vector<tuple<fmpzxx,int64_t>> factors;
    vector<tuple<fmpzxx,int64_t>> unprocessed_factors;

    Factorization() {}

    Factorization(int64_t in_number)
    {
      if(in_number == 0)
      {
        throw invalid_argument("Factorization of 0 not defined.");
      }

      number.set_integer(in_number);

      //factors = factor_and_parse(number);
      factors = {};
      unprocessed_factors = parse_but_dont_process(number);

    }

    Factorization(int64_t in_num, int64_t in_den)
    {

      if(in_den == 0)
      {
        throw invalid_argument("Can't use 0 as denominator.");
      }

      number = fmpqxx::frac(in_num, in_den);

      //factors = factor_and_parse(number);
      factors = {};
      unprocessed_factors = parse_but_dont_process(number);
    }

    Factorization(fmpzxx in_number)
    {
      number.set_integer(in_number);

      //factors = factor_and_parse(number);
      factors = {};
      unprocessed_factors = parse_but_dont_process(number);
    }

    Factorization(fmpqxx in_number)
    {
      number = in_number;

      //factors = factor_and_parse(number);
      factors = {};
      unprocessed_factors = parse_but_dont_process(number);
    }

    Factorization(vector<tuple<fmpzxx,int64_t>> in_factors)
    {
      number = product_factors(in_factors);
      factors = in_factors;
      unprocessed_factors = {};
    }

    Factorization(vector<tuple<fmpzxx,int64_t>> in_factors,
        vector<tuple<fmpzxx,int64_t>> in_unprocessed_factors)
    {
      number = product_factors(in_factors);
      factors = in_factors;
      unprocessed_factors = in_unprocessed_factors;
    }

    Factorization& operator*=(const Factorization &rhs)
    {

      number *= rhs.number;
      factors = merge_factorization_vectors(factors,rhs.factors);
      unprocessed_factors = merge_factorization_vectors(unprocessed_factors,rhs.unprocessed_factors);

      return *this;
    }

    Factorization& operator/=(const Factorization &rhs)
    {

      number /= rhs.number;
      factors = merge_divide_factorization_vectors(factors,rhs.factors);
      unprocessed_factors = merge_divide_factorization_vectors(unprocessed_factors,rhs.unprocessed_factors);

      return *this;
    }

    // TODO list
    // 2. Lazy factorization
    // 4. More types of objects other than integers/rationals

    void factor()
    {
      for(auto &tup : unprocessed_factors)
      {
        auto[base, exponent] = tup;

        auto processed_factors = factor_and_parse(base);

        processed_factors = pow_factorization_vector(processed_factors, exponent);

        factors = merge_factorization_vectors(factors, processed_factors);
      }

      unprocessed_factors = {};
    }

    // return factorization in strings
    auto to_string_vec()
    {
      auto result= factors_vec_to_strings(factors);
      auto result_unprocessed = factors_vec_to_strings(unprocessed_factors);

      result.insert(result.end(),result_unprocessed.begin(),result_unprocessed.end());

      return result;
    }
};

fmpqxx product_factors(Factorization in)
{
  auto result = product_factors(in.factors);
  result *= product_factors(in.unprocessed_factors);

  return result;
}


Factorization operator*(Factorization lhs, const Factorization &rhs)
{
  return lhs *= rhs;
}

Factorization operator/(Factorization lhs, const Factorization &rhs)
{
  return lhs /= rhs;
}

// easy printing of Factorization objects
ostream& operator<<(ostream& os, const Factorization& factors)
{
  os << "(Factorization of " << factors.number << " = ";

  if((factors.factors.size() + factors.unprocessed_factors.size()) == 0)
  {
    os << "1)";
    return os;
  }

  bool include_times = false;
  for(auto &tup : factors.factors)
  {
    auto[base, exponent] = tup;

    if(exponent == 0) continue;

    if(include_times)
    {
      os << " * ";
    }
    include_times = true;

    os << base;

    if(exponent != 1)
    {
      os << "^" << exponent;
    }
  }
  for(auto &tup : factors.unprocessed_factors)
  {
    auto[base, exponent] = tup;

    if(exponent == 0) continue;

    if(include_times)
    {
      os << " * ";
    }
    include_times = true;

    os << base;

    if(exponent != 1)
    {
      os << "^" << exponent;
    }
  }

  os << ")";

  return os;
}

auto fmpz_to_string(fmpzxx a)
{

  stringstream ss;
  ss << a;
  return ss.str();

  //return a.to_string(10);
}

auto fmpz_add(fmpzxx a, fmpzxx b)
{
  return fmpzxx(a+b);
}


PYBIND11_MODULE(dad, m) {
  m.doc() = "plugin to do dad stuff"; // docstring

  py::class_<fmpzxx>(m, "fmpz")
    .def(py::init<int64_t>())
    //.def(py::self + py::self)
    .def("__add__", &fmpz_add)
    .def(py::self - py::self)
    .def(py::self * py::self)
    .def(py::self / py::self)
    //.def("__repr__", &fmpzxx::to_string);
    .def("__repr__", &fmpz_to_string);

  py::class_<Factorization>(m, "DadFactors")
    .def(py::init<int64_t>())
    .def(py::self * py::self)
    .def(py::self / py::self)
    .def("factor", &Factorization::factor, "Factor unprocessed factors internally")
    .def("factor_vec", &Factorization::to_string_vec, "Return the factorization as a vector of strings");

}

