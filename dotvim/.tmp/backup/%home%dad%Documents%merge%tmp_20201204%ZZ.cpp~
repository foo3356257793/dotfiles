#include "ZZ.hpp"

ZZ::ZZ() { fmpz_init((fmpz*) *this); }

ZZ::ZZ(const fmpz_t &in_number) { fmpz_init_set((fmpz*) *this, (const fmpz*) in_number); }
ZZ::ZZ(const ZZ_ptr &ptr) { fmpz_init_set((fmpz*) *this, (const fmpz*) ptr); }
ZZ::ZZ(const string in_string) : ZZ() {
  fmpz_set_str((fmpz*) *this, in_string.c_str(), 10);
}
ZZ::ZZ(const uint64_t &in_number) { fmpz_init_set_ui((fmpz*) *this, in_number); }
ZZ::ZZ(const int64_t &in_number) { fmpz_init_set_si((fmpz*) *this, in_number); }
ZZ::ZZ(const double &in_number) : ZZ() { fmpz_set_d((fmpz*) *this, in_number); }

ZZ::ZZ(const ZZ &other) : ZZ(other.data) {} // copy constructor
ZZ::ZZ(ZZ &&other) noexcept : ZZ() { // move constructor
  fmpz_swap((fmpz*) *this, (fmpz*) other);
}

ZZ &ZZ::operator=(const ZZ &other) { // copy assignment
  fmpz_set((fmpz*) *this, (const fmpz*) other);
  return *this;
}

ZZ &ZZ::operator=(const ZZ_ptr &other) { // copy assignment
  fmpz_set((fmpz*) *this, (const fmpz*) other);
  return *this;
}
ZZ &ZZ::operator=(const string &other) {
  fmpz_set_str((fmpz*) *this, other.c_str(), 10);
  return *this;
}

ZZ &ZZ::operator=(const uint64_t &other) {
  fmpz_set_ui((fmpz*) *this, other);
  return *this;
}

ZZ &ZZ::operator=(const int64_t &other) {
  fmpz_set_si((fmpz*) *this, other);
  return *this;
}

ZZ &ZZ::operator=(ZZ &&other) noexcept { // move assignment
  fmpz_swap((fmpz*) *this, (fmpz*) other);
  return *this;
}

ZZ::~ZZ() { // destructor
  fmpz_clear((fmpz*) *this);
}

ZZ& ZZ::apply_fmpz_fun_eq(const ZZ &rhs,
    const function<void(fmpz_t, fmpz_t, const fmpz_t)>& fun) {
  fun((fmpz*) *this,(fmpz*) *this, (const fmpz*) rhs);
  return *this;
}

ZZ& ZZ::apply_fmpz_fun_eq(const function<void(fmpz_t, fmpz_t)>& fun) {
  fun((fmpz*) *this, (fmpz*) *this);
  return *this;
}

ZZ& ZZ::apply_fmpz_fun_eq(int64_t in, const function<void(fmpz_t, fmpz_t, int64_t)>& fun) {
  fun((fmpz*) *this, (fmpz*) *this, in);
  return *this;
}


ZZ apply_fmpz_fun(
    const ZZ &lhs,
    const ZZ &rhs,
    const function<void(fmpz_t, const fmpz_t, const fmpz_t)>& fun) {
  auto result = ZZ();
  fun((fmpz*) result, (const fmpz*) lhs, (const fmpz*) rhs);
  return result;
}

ZZ apply_fmpz_fun(const ZZ &lhs, function<void(fmpz_t, const fmpz_t)> fun) {
  auto result = ZZ();
  fun((fmpz*) result, (const fmpz*) lhs);
  return result;
}

ZZ apply_fmpz_fun(const ZZ &lhs, int64_t in, function<void(fmpz_t, const fmpz_t, int64_t)> fun) {
  auto result = ZZ();
  fun((fmpz*) result, (const fmpz*) lhs, in);
  return result;
}

ZZ &ZZ::operator+=(const ZZ &rhs) { return apply_fmpz_fun_eq(rhs, fmpz_add); }

ZZ &ZZ::operator+=(const ZZ_mul &other) {
  fmpz_addmul((fmpz*) (*this), other.lhs, other.rhs);
  return *this;
}

ZZ &ZZ::operator-=(const ZZ &rhs) { return apply_fmpz_fun_eq(rhs, fmpz_sub); }

ZZ &ZZ::operator-=(const ZZ_mul &other) {
  fmpz_submul((fmpz*) (*this), other.lhs, other.rhs);
  return *this;
}

ZZ &ZZ::operator*=(const ZZ &rhs) { return apply_fmpz_fun_eq(rhs, fmpz_mul); }
ZZ &ZZ::operator%=(const ZZ &rhs) { return apply_fmpz_fun_eq(rhs, fmpz_mod); }
ZZ &ZZ::operator/=(const ZZ &rhs) {
  return apply_fmpz_fun_eq(rhs, fmpz_divexact);
}
ZZ& ZZ::operator-() { return apply_fmpz_fun_eq(fmpz_neg); }

ZZ& ZZ::addmul(const ZZ &in0, const ZZ &in1) {
  fmpz_addmul((fmpz*) *this, (const fmpz*) in0, (const fmpz*) in1);
  return *this;
}
ZZ& ZZ::submul(const ZZ &in0, const ZZ &in1) {
  fmpz_submul((fmpz*) *this, (const fmpz*) in0, (const fmpz*) in1);
  return *this;
}

ZZ_add ZZ::operator+(const ZZ &rhs) const {
  return ZZ_add((const fmpz*) (*this), (const fmpz*) rhs);
}
ZZ_sub ZZ::operator-(const ZZ &rhs) const {
  return ZZ_sub((const fmpz*) (*this), (const fmpz*) rhs);
}
ZZ_mul ZZ::operator*(const ZZ &rhs) const {
  return ZZ_mul((const fmpz*) (*this), (const fmpz*) rhs);
}
ZZ ZZ::operator*(const int64_t rhs) const {
  return apply_fmpz_fun(*this, rhs, fmpz_mul_si);
}
ZZ ZZ::operator%(const ZZ &rhs) const { return apply_fmpz_fun(*this, rhs, fmpz_mod); }
ZZ ZZ::operator/(const ZZ &rhs) const {
  return apply_fmpz_fun(*this, rhs, fmpz_divexact);
}
ZZ ZZ::operator-() const { return apply_fmpz_fun(*this, fmpz_neg); }

bool ZZ::operator==(const ZZ &rhs) const {
  return (bool)fmpz_equal((const fmpz*) *this, (const fmpz*) rhs);
}
#if 0
bool ZZ::operator!=(const ZZ &rhs) const {
  return !(fmpz_equal((fmpz*) *this, (fmpz*) rhs));
}
#endif

strong_ordering ZZ::operator<=>(const ZZ &rhs) const{
  return (fmpz_cmp((const fmpz*) *this,(const fmpz*) rhs))<=>0;
}

bool ZZ::is_divisible_by(const ZZ &poss_factor) const {
  return fmpz_divisible((const fmpz*) *this, (const fmpz*) poss_factor);
}

ZZ abs(const ZZ &in) { return apply_fmpz_fun(in,fmpz_abs); }

bool is_prime(const ZZ &in) {
  auto result = fmpz_is_prime((const fmpz*) in);
  return (result != 0);
}

bool is_probabprime(const ZZ &in) {
  auto result = fmpz_is_probabprime((const fmpz*) in);
  return (result != 0);
}

bool is_prime(const ZZ &in, bool proved) {
  if(!proved) return is_probabprime(in);
  return is_prime(in);
}

ZZ pow(ZZ base, int64_t exponent) {
  if (exponent < 0) {
    throw invalid_argument("Negative exponentiation not supported for ZZ");
  }

  auto result = ZZ();
  fmpz_pow_ui((fmpz*) result, (const fmpz*) base, (uint64_t)exponent);

  return result;
}

ostream &operator<<(ostream &os, const ZZ &f) {
  char *out_string = fmpz_get_str(NULL, 10, (const fmpz*) f);
  os << out_string;
  free(out_string);

  return os;
}

ZZ gcd(const ZZ &a, const ZZ &b){
  return apply_fmpz_fun(a,b,fmpz_gcd);
}

ZZ& ZZ::next_prime(){
  return apply_fmpz_fun_eq(0,fmpz_nextprime);
}

ZZ next_prime(const ZZ &a){
  return apply_fmpz_fun(a,0,fmpz_nextprime);
}

ZZ& ZZ::operator=(const ZZ_add &other){
  fmpz_add((fmpz*) (*this), other.lhs, other.rhs);
  return *this;
}

ZZ& ZZ::operator=(const ZZ_sub &other){
  fmpz_sub((fmpz*) (*this), other.lhs, other.rhs);
  return *this;
}

ZZ& ZZ::operator=(const ZZ_mul &other){
  fmpz_mul((fmpz*) (*this), other.lhs, other.rhs);
  return *this;
}

ZZ ZZ::operator*(const ZZ_mul &other) const {
  auto result = ZZ();
  fmpz_mul((fmpz*) result, (const fmpz*) other.lhs, (const fmpz*) other.lhs);
  result *= *this;
  return result;
}

ZZ ZZ_mul::operator*(const ZZ &other) const {
  auto result = ZZ();
  fmpz_mul((fmpz*) result, (const fmpz*) lhs, (const fmpz*) rhs);
  result *= other;
  return result;
}

ZZ ZZ_mul::operator+(const ZZ &rhs) const {
  auto result = ZZ(*this);
  result += rhs;
  return result;
}

