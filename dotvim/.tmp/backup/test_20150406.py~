#!/usr/bin/python3

from random import *

def print_vecs(arr,height,depth):
  for i in range(height):
    for j in range(depth):
      print("%4X " % (arr[depth*i+j]), end = "")
    print("")

seed()

depth = 16
keysize = 4
max_key = (1<<keysize) - 1
height = (1<<keysize)
n = depth*height

arr = [randint(0,max_key) for r in range(n)]

#print(arr)
print_vecs(arr,height,depth)

# #method #1: sort
# for i in range(depth):
#   col = arr[i:n:depth]
#   col.sort()
#   arr[i:n:depth] = col
#
#
# print("")
# print_vecs(arr,height,depth)
#
# #cal pct in correct spot
# num_cor = 0
# for i in range(height):
#   for j in range(depth):
#     if arr[depth*i+j] == i:
#       num_cor += 1
#
# print("%d/%d = %lf correct" % (num_cor, n, num_cor/n))

def dynamic_swap_vecs(arr, depth, row_0, row_1, mean_0, mean_1):
  for j in range(depth):
    no_swap = min(abs(arr[row_0*depth+j]-mean_0),abs(arr[row_1*depth+j]-mean_1))
    swap = min(abs(arr[row_1*depth+j]-mean_0),abs(arr[row_0*depth+j]-mean_1))
    if swap < no_swap:
      arr[row_0*depth+j], arr[row_1*depth+j] = arr[row_1*depth+j], arr[row_0*depth+j]

#method #2: tournament, stick to bins
#
# no_swap = [None] * depth
# swap = [None] * depth
# for level in range(keysize):
#   offset = (1<<(keysize-level-1))
#   block_size = offset << 1
#   for start in range(0,height,block_size):
#     for i in range(0,offset):
#       print("compare %d %d" % (start+i,start+i+offset))
#       mean_0 = start+i+0.5
#       mean_1 = start+i+offset+0.5
#       for j in range(depth):
#         dynamic_swap_vecs(arr, depth, i, i+offset, mean_0, mean_1)
#
# #cal pct in correct spot
# num_cor = 0
# for i in range(height):
#   for j in range(depth):
#     if arr[depth*i+j] == i:
#       num_cor += 1
#
# print("")
# print_vecs(arr,height,depth)
#
# print("%d/%d = %lf correct" % (num_cor, n, num_cor/n))

# method #3 comb sort
# offset = round(0.75*height)
# dir = 0
# while offset > 0:
#   print(offset)
#   if dir == 0:
#     i = 0
#     while i + offset < height:
#       mean_0 = i+0.5
#       mean_1 = i+offset+0.5
#       dynamic_swap_vecs(arr, depth, i, i+offset, mean_0, mean_1)
#       i += 1
#   else:
#     i = height - 1
#     while i - offset >= 0:
#       mean_0 = i-offset+0.5
#       mean_1 = i+0.5
#       dynamic_swap_vecs(arr, depth, i-offset, i, mean_0, mean_1)
#       i -= 1
#   dir ^= 1
#   new_offset = round(0.75*offset)
#   if new_offset >= offset:
#     new_offset = offset-1
#   offset = new_offset
#
# #cal pct in correct spot
# num_cor = 0
# for i in range(height):
#   for j in range(depth):
#     if arr[depth*i+j] == i:
#       num_cor += 1
#
# print("")
# print_vecs(arr,height,depth)
#
# print("%d/%d = %lf correct" % (num_cor, n, num_cor/n))

# method #4 dynamic swapping
p = 0
full_vecs = 0
counts = [0] * height
# skip correct rows
while arr[p*depth] == p:
  while arr[p*depth+counts[p]] == p and counts[p] < 16:
    counts[p] += 1
  if counts[p] == 16:
    full_vecs += 1
    arr[p*depth:(p+1)*depth] = [randint(0,max_key) for r in range(depth)]
    counts[p] = 0
  else:
    p += 1

num_cols = 1
for col in range(num_cols):
  while p < height:
    x = arr[p*depth+col]
    while x != p:
      if arr[x*depth+col] == x:
        while arr[x*depth+counts[x]] == x:
          counts[x] += 1
          if counts[x] == 16:
            full_vecs += 1
            arr[x*depth:(x+1)*depth] = [randint(0,max_key) for r in range(depth)]
            counts[x] = 0
        arr[x*depth+col], arr[x*depth+counts[x]] = arr[x*depth+counts[x]], arr[x*depth+col]
      dynamic_swap_vecs(arr,depth,p,x,p,x)
      x = arr[p*depth+col]
    counts[p] += 1
    p += 1

#cal pct in correct spot
num_cor = 0
for i in range(height):
  for j in range(depth):
    if arr[depth*i+j] == i:
      num_cor += 1

print("")
print("cols = %d" % num_cols)
print_vecs(arr,height,depth)
print("full vecs = %d" % (full_vecs))

print("%d/%d = %lf correct" % (num_cor, n, num_cor/n))
