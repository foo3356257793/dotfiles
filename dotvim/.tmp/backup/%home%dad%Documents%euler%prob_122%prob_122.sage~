#!/usr/bin/sage

import itertools

def _exhaust_patterns_up_to_len(a,pattern,min_max,max_len):

    len_pattern = len(pattern)

    if len_pattern == max_len+1:

        if pattern[-1] == a:
            return [pattern]
        else:
            return []

    ret = []

    for tup in itertools.combinations_with_replacement(pattern,2):

        val = sum(tup)

        if val == a:

            # have a hit
            return [pattern + [val]]

        elif val >= min_max[len_pattern]:

            ret += _exhaust_patterns_up_to_len(a, pattern + [val], min_max, max_len)

    return ret


def exhaust_patterns_up_to_len(target,max_len):

    if max_len == 1:
        if target == 1:
            return [[1]]
        elif target == 2:
            return [[1,2]]
        else:
            return []

    elif max_len == 2:
        if target == 1:
            return [[1]]
        elif target == 2:
            return [[1,2]]
        elif target == 3:
            return [[1,2,3]]
        elif target == 4:
            return [[1,2,4]]
        else:
            return []

    pattern = [1,2]

    min_max = [target]

    b = target

    for i in range(1,max_len+1):

        b = (b+1)//2

        min_max = [b] + min_max

    ret = []

    if min_max[2] <= 4:

        ret += _exhaust_patterns_up_to_len(target, pattern + [4], min_max, max_len)

    if min_max[2] <= 3:
        ret += _exhaust_patterns_up_to_len(target, pattern + [3], min_max, max_len)

    return ret



if __name__ == "__main__":

    #bd = 10
    bd = 200

    m = [0] * 201

    m[1] = 0
    m[2] = 1
    m[3] = 2
    m[4] = 2

    #print(exhaust_patterns_up_to_len(15,5))

    for a in range(5,bd+1):

        print('...%3d' % a)

        if a & 1 == 0:
            m[a] = m[a>>1] + 1
        else:
            m[a] = m[a-1] + 1

        # can we do better than this?
        poss = exhaust_patterns_up_to_len(a,m[a]-1)

        if len(poss) > 0:

            m[a] = min([len(p) for p in poss]) - 1
