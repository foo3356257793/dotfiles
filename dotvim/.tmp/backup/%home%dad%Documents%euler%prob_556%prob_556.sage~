#!/usr/bin/sage

import time

from multiprocessing import Pool

"""
num lattice points:
    314159265350589

    (9 minutes)
"""


def num_lattice_points_simple(n):

    # first pass: don't take advantage of symmetry
    b_max = floor( sqrt(n) )
    b_min = -b_max

    S = 0

    for b in range(b_min, b_max+1):

        a_max = floor( sqrt(n - b*b) )
        S += 2*a_max+1

    return S

def num_lattice_points_on_line(b,n):

    # b and -b points
    a_max = floor( sqrt(n - b*b) )
    return 2*(2*a_max+1)

def process_chunk(tup):

    b_min = tup[0]
    b_max = tup[1]
    n = tup[2]

    S = 0
    for b in range(b_min, b_max):

        a_max = floor( sqrt(n - b*b) )
        S += 2*(2*a_max+1)

    return S


def num_lattice_points(n):

    b_max = floor( sqrt(n) )

    # b = 0 points
    S = 2*b_max+1

    """
    for b in range(1,b_max+1):

        a_max = floor( sqrt(n - b*b) )
        # b and -b points
        S += 2*(2*a_max+1)
    """

    #b_set = [[b,n] for b in range(1,b_max+1)]

    num_chunks = 100
    chunk_width = b_max//num_chunks

    if chunk_width <= 0:
        num_chunks = 1
        chunk_width = b_max-1

    chunks = [[1+i*chunk_width, 1+(i+1)*chunk_width, n] for i in range(num_chunks)]
    if num_chunks * chunk_width < b_max:
        chunks.append([1+num_chunks*chunk_width, b_max+1, n])

    with Pool(4) as p:
        data = p.map(process_chunk, chunks)

    S += sum(data)

    return S

def count_squarefree_pos_int(n):

    num_pts = 0

    c_max = floor(sqrt(n))

    for c in range(1,c_max+1,2):

        coeff = moebius(c)

        #num_pts += coeff * (floor(n//(c*c)))
        num_pts += coeff * (floor((1 + n/(c*c))/2))

    return num_pts


def get_moebius_coeff(c):

    if c == 1:
        return 1

    fac_c = factor(c)

    coeff = 1

    for tup in fac_c:

        p = tup[0]

        if p == 2:
            if tup[1] == 1:
                coeff *= -1 # only one prime with norm 2
            else:
                return 0 # not squarefree

        elif p & 3 == 1:
            if tup[1] > 2:
                return 0 # not squarefree
            elif tup[1] == 2:
                coeff *= 1 # possibility of both of two distinct factors over p
            else:
                coeff *= -2 # use one of two distinct factors over p
        else:
            if tup[1] != 2:
                return 0 # either not squarefree or no solution
            else:
                coeff *= -1 # only one possible factor

    return coeff

def count_squarefree(n):

    c_max = floor(sqrt(n))

    # expensive
    num_pts = 0

    prev_m_max = 0

    for c in range(1,c_max+1):

        coeff = get_moebius_coeff(c)

        if coeff == 0:
            continue

        # count multiples of c^2
        m_max = n//(c*c) # points with norms at most this large

        # exclude the 0 point
        if m_max != prev_m_max:
            num_multiples = (num_lattice_points(m_max) - 1) // 4
            prev_m_max = m_max

        num_pts += coeff * (num_multiples)

    return num_pts

if __name__ == "__main__":

    n = 10**10

    start_tm = time.perf_counter()

    print(count_squarefree(n))

    end_tm = time.perf_counter()
    tot_tm = end_tm-start_tm
    print("TIME = %.3lf" % tot_tm)
