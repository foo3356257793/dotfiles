NUM_WHEAT = 2^2
NUM_TARES = 2^2
NUM_ROUNDS = 2
TARGET_NUM_WHEAT = NUM_WHEATÃ·2

using Random

mutable struct Observation
    values::Array{Float64}
end

mutable struct RoundBoundary
    value::Float64
    index::Int
    location::Ptr{Ptr{Observation}}
end

mutable struct Round
    sorted_data::Array{Observation}
    index::Int
    score_delta::Int
    boundary::RoundBoundary
    next_boundary::RoundBoundary
end

mutable struct DataInRounds
    data::Array{Observation}
    num_rounds::Int
    rounds::Array{Round}
    num_wheat::Int
end

function find_boundaries(wheat, tares, num_rounds, target_num_wheat)

    println("Placing data into the solver...")

    #data = vcat(wheat, tares)
    data = []

    for vec in vcat(wheat,tares)
        obs = Observation(vec)
        push!(data, obs)
    end

    rounds = []
    # TODO: in parallel
    for i in 1:num_rounds
        sorted_data = sort(data, by=x -> x.values[i])

        # figure out the round boundary here and now

        #push!(rounds, Round(sorted_data,i,0,nothing,nothing))
    end

    MyData = DataInRounds(data, num_rounds, rounds, length(wheat))

    return MyData

end

Random.seed!(0)
wheat = [[rand() for i = 1:NUM_ROUNDS] for j = 1:NUM_WHEAT]
tares = [[rand() for i = 1:NUM_ROUNDS] for j = 1:NUM_TARES]

foo = find_boundaries(wheat, tares, NUM_ROUNDS, TARGET_NUM_WHEAT)
