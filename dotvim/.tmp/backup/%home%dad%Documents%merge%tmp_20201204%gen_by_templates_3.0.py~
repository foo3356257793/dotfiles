#!/usr/bin/python3

import os

import itertools

class SourceCode:
    def __init__(self):
        self.head = []
        self.foot = []
        self.cpp = []
        self.structs = {}

    def __call__(self,name,content):
        if name in self.structs:
            self.structs[name].append(content)
        else:
            self.structs[name] = [content]

    def __add__(self,other):
        result = SourceCode()

        result.head = self.head + other.head
        result.foot = self.foot + other.foot
        result.cpp = self.cpp + other.cpp

        result.structs = {}
        for key,value in self.structs.items():
            result[key] = value
            if key in other:
                result[key] += other[key]
        for key,value in other.structs.items():
            if not key in self:
                result[key] = value

        return result

    def __iadd__(self,other):
        self.head += other.head
        self.foot += other.foot
        self.cpp += other.cpp

        for key, value in other.structs.items():
            if key in self.structs:
                self.structs[key] += value
            else:
                self.structs[key] = value

        return self

    def write(self,hpp_fname,cpp_fname):

        with open(hpp_fname,'w') as f:
            f.write("\n\n".join(self.head))
            f.write("\n")

            for key,value in self.structs.items():
                f.write("\n\n".join(value))
                f.write(f"\n}};\n\n")

            f.write("\n\n".join(self.foot))
        os.system(f"clang-format -i --style=Google {hpp_fname}")

        with open(cpp_fname,'w') as f:
            f.write("\n\n".join(self.cpp))
        os.system(f"clang-format -i --style=Google {cpp_fname}")


class FlintName:
    def __init__(self,new_name,flint_name):
        self.new = new_name
        self.flint = flint_name

    def __hash__(self):
        return hash(tuple([self.new,self.flint]))

    def ptr(self):
        return FlintName(f"{self.new}_ptr",self.flint)

    def __eq__(self,other):
        return ((self.new==other.new) and (self.flint==other.flint))

    def init_str(self,is_ptr=False):
        if is_ptr:
            return ""
        return f" : {self.new}()"

class FlintFunc:
    def __init__(self,new_name,flint_name,is_builtin=False):
        self.new = new_name
        self.flint = flint_name
        self.is_builtin = is_builtin

    def new_str(self):
        result = f"{self.new}"
        if self.is_builtin:
            result = f"operator{result}"
        return result

    def new_str_eq(self):
        if self.is_builtin:
            return f"operator{self.new}="
        return f"{self.new}_eq"

def decl_ptr_struct(name):


    name_ptr = name.ptr()

    output = SourceCode()

    output.head.append(f"struct {name_ptr.new};\n")

    output(name_ptr,f"struct {name_ptr.new} {{\n"
                  + f"\n"
                  + f"{name_ptr.flint}* data;\n")

    return output

def decl_struct(name):

    output = SourceCode()

    output.head.append(f"struct {name.new};\n")
    output(name,f"struct {name.new} {{\n"
              + f"{name.flint}_t data;\n")

    return output

def rule_of_five(name):

    output = SourceCode()

    output(name,f"{name.new}();")

    output.cpp.append(f"{name.new}::{name.new}() {{\n"
                    + f"{name.flint}_init(data);\n"
                    + f"}}\n")

    output(name,f"{name.new}(const {name.new} &in);\n")

    output.cpp.append(f"{name.new}::{name.new}(const {name.new} &in) : {name.new}() {{\n"
                    + f"{name.flint}_set(data,in.data);\n"
                    + f"}}\n")

    output(name,f"{name.new}& operator=(const {name.new} &in);\n")

    output.cpp.append(f"{name.new}& {name.new}::operator=(const {name.new} &in) {{\n"
                    + f"{name.flint}_set(data,in.data);\n"
                    + f"return *this;\n"
                    + f"}}\n")

    output(name,f"{name.new}({name.new} &&in) noexcept;\n")

    output.cpp.append(f"{name.new}::{name.new}({name.new} &&in) noexcept : {name.new}() {{\n"
                    + f"swap(data,in.data);\n"
                    + f"}}\n")

    output(name,f"{name.new}& operator=({name.new} &&in) noexcept;\n")

    output.cpp.append(f"{name.new}& {name.new}::operator=({name.new} &&in) noexcept {{\n"
                    + f"swap(data,in.data);\n"
                    + f"return *this;\n"
                    + f"}}\n")

    output(name,f"~{name.new}();")

    output.cpp.append(f"{name.new}::~{name.new}() {{\n"
                    + f"{name.flint}_clear(data);\n"
                    + f"}}\n")


    name_ptr = name.ptr()

    output(name_ptr,f"{name_ptr.new}({name_ptr.flint}_t in);")

    output.cpp.append(f"{name_ptr.new}::{name_ptr.new}({name_ptr.flint}_t in) {{\n"
                      + f"data = in;\n"
                      + f"}}\n")

    output(name_ptr,f"{name_ptr.new}(const {name.new} &in);\n")

    output.cpp.append(f"{name_ptr.new}::{name_ptr.new}(const {name.new} &in) {{\n"
                      + f"{name_ptr.flint}_set(data,in.data);\n"
                      + f"}}\n")

    output(name_ptr,f"{name_ptr.new}& operator=(const {name.new} &in);\n")

    output.cpp.append(f"{name_ptr.new}& {name_ptr.new}::operator=(const {name.new} &in) {{\n"
                      + f"{name_ptr.flint}_set(data,in.data);\n"
                      + f"return *this;\n"
                      + f"}}\n")

    output(name_ptr,f"{name_ptr.new}({name_ptr.new} &&in) noexcept = delete;\n")

    output(name_ptr,f"{name_ptr.new}& operator=({name_ptr.new} &&in) noexcept = delete;\n")

    output(name_ptr,f"~{name_ptr.new}();")

    output.cpp.append(f"{name_ptr.new}::~{name_ptr.new}() {{}}\n")

    return output

def get_suffix(builtin_type):

    if "int" in builtin_type:
        if builtin_type[0] == "u":
            return "ui"
        return "si"

    if builtin_type == "float":
        return "d"

    if builtin_type == "double":
        return "d"

    if builtin_type == "string":
        return "str"

    else:
        raise ValueError(f"Cannot find suffix for {builtin_type}")

def copy_builtin(name,builtin_type,suffix=None,is_ptr=False):

    if suffix is None:
        suffix = get_suffix(builtin_type)

    output = SourceCode()

    output(name,f"{name.new}(const {builtin_type} in);\n")

    init_str = name.init_str(is_ptr)

    output.cpp.append(f"{name.new}::{name.new}(const {builtin_type} in) {init_str} {{\n"
                    + f"{name.flint}_set_{suffix}(data,in);\n"
                    + f"}}\n")

    output(name,f"{name.new}& operator=(const {builtin_type} in);\n")

    output.cpp.append(f"{name.new}& {name.new}::operator=(const {builtin_type} in) {{\n"
                    + f"{name.flint}_set_{suffix}(data,in);\n"
                    + f"return *this;\n"
                    + f"}}\n")

    return output

def get_int_types(si=True,ui=True):

    result = []

    if si:
        result += [f"int{b}_t" for b in [2**i for i in range(3,7)]]
    if ui:
        result += [f"uint{b}_t" for b in [2**i for i in range(3,7)]]

    return result

def copy_int(name,si=True,ui=True,is_ptr=False):

    output = SourceCode()

    for int_type in get_int_types(si,ui):
        output += copy_builtin(name,int_type,is_ptr=is_ptr)

    return output

def copy_intfrac(name,sifrac=True,uifrac=True,ZZfrac=True,is_ptr=False):

    output = SourceCode()
    
    den_types = get_int_types(si=False,ui=True)
    num_types = get_int_types(si=sifrac,ui=uifrac)

    init_str = name.init_str(is_ptr)

    for num_type,den_type in itertools.product(num_types,den_types):
        suffix = get_suffix(num_type)

        output(name,f"{name.new}(const {num_type} num, const {den_type} den);\n")

        output.cpp.append(f"{name.new}::{name.new}"
                          + f"(const {num_type} num, const {den_type} den) {init_str} {{\n"
                          + f"{name.flint}_set_{suffix}(data,num,den);\n"
                          + f"}}\n")

    den_types = get_int_types(si=True,ui=False)

    for num_type,den_type in itertools.product(num_types,den_types):
        suffix = get_suffix(num_type)

        output(name,f"{name.new}(const {num_type} num, const {den_type} den);\n")

        output.cpp.append(f"{name.new}::{name.new}"
                          + f"(const {num_type} num, const {den_type} den) {init_str} {{\n"
                          + f"if(den<0){{\n"
                          + f"{name.flint}_set_{suffix}(data,-num,(uint64_t) (-den));\n"
                          + f"}}\n"
                          + f"else {{\n"
                          + f"{name.flint}_set_{suffix}(data,num,(uint64_t) den);\n"
                          + f"}}\n"
                          + f"}}\n")

    # now pull in ZZ
    if ZZfrac:

        suffix = "fmpz_frac"

        for num_type,den_type in itertools.product(["ZZ","ZZ_ptr"],repeat=2):
            output(name,f"{name.new}(const {num_type} &num, const {den_type} &den);\n")

            output.cpp.append(f"{name.new}::{name.new}"
                              + f"(const {num_type} &num, const {den_type} &den) {init_str} {{\n"
                              + f"{name.flint}_set_{suffix}(data,num.data,den.data);\n"
                              + f"}}\n")

        # now crazy!
        int_types = get_int_types(si=True,ui=True)
        for type0,type1 in itertools.product(["ZZ","ZZ_ptr"],int_types):
            output(name,f"{name.new}(const {type0} &num, const {type1} den);\n")
            output(name,f"{name.new}(const {type1} num, const {type0} &den);\n")

            output.cpp.append(f"{name.new}::{name.new}"
                              + f"(const {type0} &num, const {type1} den) {init_str} {{\n"
                              + f"{name.flint}_set_{suffix}(data,num.data,ZZ(den).data);\n"
                              + f"}}\n")
            output.cpp.append(f"{name.new}::{name.new}"
                              + f"(const {type1} num, const {type0} &den) {init_str} {{\n"
                              + f"{name.flint}_set_{suffix}(data,ZZ(num).data,den.data);\n"
                              + f"}}\n")

    return output


def copy_float(name,is_ptr=False):

    output = SourceCode()

    for float_type in ["float","double"]:
        output = copy_builtin(name,float_type,is_ptr=is_ptr)

    return output

def copy_string(name,is_ptr=False):

    output = SourceCode()

    output(name,f"{name.new}(const std::string in);\n")

    init_str = name.init_str(is_ptr)

    output.cpp.append(f"{name.new}::{name.new}(const string in) {init_str} {{\n"
                    + f"{name.flint}_set_str(data,in.c_str(),10);\n"
                    + f"}}\n")

    output(name,f"{name.new}& operator=(const std::string in);\n")

    output.cpp.append(f"{name.new}& {name.new}::operator=(const string in) {{\n"
                    + f"{name.flint}_set_str(data,in.c_str(),10);\n"
                    + f"return *this;\n"
                    + f"}}\n")

    return output

def copy_ptr(name,is_ptr=False):

    output = SourceCode()

    name_ptr = name.ptr()
    if is_ptr:
        name_ptr = name

    output(name,f"{name.new}(const {name_ptr.new} &in);\n")

    init_str = name.init_str(is_ptr)

    output.cpp.append(f"{name.new}::{name.new}(const {name_ptr.new} &in) {init_str} {{\n"
                    + f"{name.flint}_set(data,in.data);\n"
                    + f"}}\n")

    output(name,f"{name.new}& operator=(const {name_ptr.new} in);\n")

    output.cpp.append(f"{name.new}& {name.new}::operator=(const {name_ptr.new} in) {{\n"
                    + f"{name.flint}_set(data,in.data);\n"
                    + f"return *this;\n"
                    + f"}}\n")

    return output

def copy_types(name,si=True,ui=True,sifrac=False,uifrac=False,ZZfrac=False,d=True,string=True,ptr=True,other=None,is_ptr=False):

    output = SourceCode()

    if si or ui:
        output += copy_int(name,si=si,ui=ui,is_ptr=is_ptr)

    if sifrac or uifrac or ZZfrac:
        output += copy_intfrac(name,sifrac=sifrac,uifrac=uifrac,ZZfrac=ZZfrac,is_ptr=is_ptr)

    if d:
        output += copy_float(name,is_ptr=is_ptr)

    if string:
        output += copy_string(name,is_ptr=is_ptr)

    if ptr:
        output += copy_ptr(name,is_ptr=is_ptr)

    if other:
        for type_name in other:
            if isinstance(type_name,FlintName):
                raise NotImplementedError(f"Don't know how to cast to {type_name}")

            raise NotImplementedError(f"Don't know how to cast to {type_name}")

    return output

def cast_raw(name):

    output = SourceCode()

    output(name,f"explicit operator {name.flint}*();\n")
    output(name,f"explicit operator const {name.flint}*() const;\n")

    output.cpp.append(f"{name.new}::operator {name.flint}*() {{"
                    + f"return ({name.flint}*) data; }}\n")
    output.cpp.append(f"{name.new}::operator const {name.flint}*() const {{"
                    + f"return (const {name.flint}*) data; }}\n")

    return output

def cast_builtin(name,builtin_type):

    suffix = get_suffix(builtin_type)

    output = SourceCode()

    output(name,f"explicit operator {builtin_type}() const;\n")
    output.cpp.append(f"{name.new}::operator {builtin_type}() const {{ "
                    + f"return {name.flint}_get_{suffix}(data); }}\n")

    return output

def cast_int_all(name,si=True,ui=True):

    output = SourceCode()

    for int_type in get_int_types(si,ui):
        output += cast_builtin(name,int_type)

    return output

def cast_float_all(name):

    output = SourceCode()

    for float_type in ["float","double"]:
        output += cast_builtin(name,float_type)

    return output

def cast_string(name):

    output = SourceCode()

    output(name,"explicit operator std::string() const;\n")

    output.cpp.append(f"{name.new}::operator string() const {{ "
                    + f"stringstream ss;\n"
                    + f"char *tmp = {name.flint}_get_str(NULL, 10, data);\n"
                    + f"ss << tmp;\n"
                    + f"free(tmp);\n"
                    + f"return ss.str();\n"
                    + f"}}\n")

    return output

def cast(name,raw=True,si=True,ui=True,d=True,string=True,other=None):

    output = SourceCode()

    if raw:
        output += cast_raw(name)

    output += cast_int_all(name,si=si,ui=ui)

    if d:
        output += cast_float_all(name)

    if string:
        output += cast_string(name)

    if other:
        for type_name in other:

            if isinstance(type_name,FlintName):
                raise NotImplementedError(f"Don't know how to cast to {type_name}")

            output += cast_builtin(name, type_name)

    return output


def compare(name,si=True,ui=True):

    output = SourceCode()

    name_ptr = name.ptr()

    for name0, name1 in itertools.product([name,name_ptr],repeat=2):

        output(name0,f"bool operator==(const {name1.new} &other) const;\n")

        output.cpp.append(f"bool {name0.new}::operator==(const {name1.new} &other) const {{\n"
                        + f"return ((bool) {name.flint}_equal(data,other.data));\n"
                        + f"}}\n")

        output(name0,f"std::strong_ordering operator<=>(const {name1.new} &other) const;\n")

        output.cpp.append(f"strong_ordering {name0.new}::operator<=>(const {name1.new} &other) const {{"
                        + f"return ({name.flint}_cmp(data,other.data))<=>0;\n"
                        + f"}}\n")

    int_types = get_int_types(si=si,ui=ui)

    for int_type in int_types:

        suffix = get_suffix(int_type)

        for name0 in [name,name_ptr]:

            output(name0,f"bool operator==(const {int_type} other) const;\n")

            output.cpp.append(f"bool {name0.new}::operator==(const {int_type} other) const {{\n"
                            + f"return ((bool) {name.flint}_equal_{suffix}(data,other));\n"
                            + f"}}\n")

            output(name0,f"std::strong_ordering operator<=>(const {int_type} other) const;\n")

            output.cpp.append(f"strong_ordering {name0.new}::operator<=>(const {int_type} other) const {{"
                            + f"return ({name.flint}_cmp_{suffix}(data,other))<=>0;\n"
                            + f"}}\n")

    return output

def translate_fun(name,ffun,template):

    name_ptr = name.ptr()

    output = SourceCode()

    if template in ["void(name:out,name,name)",
            "void(name:out,name,name/si/ui):commutes",
            "void(name:out,name,name/si/ui)",
            "void(name:out,name,name/ui)",
            "int(name:out,name,name)",
            "void(name:out,name,name/ZZ)",
            "void(name:out,name,name/si/ui/ZZ):commutes"]:

        for name0,name1 in itertools.product([name,name_ptr],repeat=2):

            # output, input

            output(name0, f"{name0.new} &{ffun.new_str_eq()}(const {name1.new} &in);\n")

            tmp = f"{name0.new} &{name0.new}::{ffun.new_str_eq()}(const {name1.new} &in) {{\n"

            if template in ["int(name:out,name,name)"]:
                tmp += "int error = "

            tmp += f"{name.flint}_{ffun.flint}(data,data,in.data);\n"

            if template in ["int(name:out,name,name)"]:
                tmp += f"if(error==0) {{\n"
                tmp += f'throw invalid_argument("{ffun.new_str_eq()} failed");\n'
                tmp += f"}}\n"

            tmp += f"return *this;\n"
            tmp += f"}}\n"

            output.cpp.append(tmp)

            # output (must be name), input, input

            output.foot.append(f"{name.new} {ffun.new_str()}("
                + f"const {name0.new} &in_1, const {name1.new} &in_2);\n")

            tmp  = f"{name.new} {ffun.new_str()}("
            tmp += f"const {name0.new} &in_1, const {name1.new} &in_2) {{\n"
            tmp += f"auto result = {name.new}();\n"

            if template in ["int(name:out,name,name)"]:
                tmp += "int error = "

            tmp += f"{name.flint}_{ffun.flint}(result.data,in_1.data,in_2.data);\n"

            if template in ["int(name:out,name,name)"]:
                tmp += f"if(error==0) {{\n"
                tmp += f'throw invalid_argument("{ffun.new_str()} failed");\n'
                tmp += f"}}\n"

            tmp += f"return result;\n"
            tmp += f"}}\n"

            output.cpp.append(tmp)

    si = False
    ui = False

    if template == "void(name:out,name,name/si/ui)":
        si = True
        ui = True

    if template == "void(name:out,name,name/ui)":
        ui = True

    if template in ["void(name:out,name,name/si/ui):commutes",
                    "void(name:out,name,name/si/ui/ZZ):commutes"]:
        si = True
        ui = True

    if template == "void(name:out,name,ui)":
        ui = True

    if template == "void(name:out,name,si)":
        si = True

    if template in ["void(name:out,name,name/si/ui)",
                    "void(name:out,name,name/ui)",
                    "void(name:out,name,name/si/ui):commutes",
                    "void(name:out,name,name/si/ui/ZZ):commutes",
                    "void(name:out,name,ui)",
                    "void(name:out,name,si)",
                    ]:

        int_types = get_int_types(si=si,ui=ui)

        for int_type in int_types:

            suffix = f"_{get_suffix(int_type)}"

            if template in ["void(name:out,name,ui)"]:
                suffix = ""

            for name0 in [name,name_ptr]:

                output(name0,
                        f"{name0.new} &{ffun.new_str_eq()}(const {int_type} in);\n")

                output.cpp.append(f"{name0.new} &{name0.new}::{ffun.new_str_eq()}("
                                + f"const {int_type} in) {{\n"
                                + f"{name.flint}_{ffun.flint}{suffix}(data,data,in);\n"
                                + f"return *this;\n"
                                + f"}}\n")

                output.foot.append(f"{name.new} {ffun.new_str()}("
                    + f"const {name0.new} &in_1, const {int_type} in_2);\n")

                output.cpp.append(f"{name.new} {ffun.new_str()}("
                                + f"const {name0.new} &in_1, const {int_type} in_2) {{\n"
                                + f"auto result = {name.new}();\n"
                                + f"{name.flint}_{ffun.flint}{suffix}(result.data,in_1.data,in_2);\n"
                                + f"return result;\n"
                                + f"}}\n")

    if template in ["void(name:out,name,name/si/ui):commutes",
                    "void(name:out,name,name/si/ui/ZZ):commutes"]:

        int_types = get_int_types(si=si,ui=ui)

        for int_type in int_types:

            suffix = get_suffix(int_type)

            for name0 in [name, name_ptr]:

                output.foot.append(f"{name.new} {ffun.new_str()}("
                        + f"const {int_type} in_1, const {name0.new} in_2);\n")

                output.cpp.append(
                        f"{name.new} {ffun.new_str()}("
                      + f"const {int_type} in_1, const {name0.new} in_2) {{\n"
                      + f"auto result = {name.new}();\n"
                      + f"{name.flint}_{ffun.flint}_{suffix}(result.data,in_2.data,in_1);\n"
                      + f"return result;\n"
                      + f"}}\n")

    if template == "void(name:out,name)":

        for name0 in [name, name_ptr]:

            output(name0, f"{name0.new} &{ffun.new_str_eq()}();\n")

            output.cpp.append(f"{name0.new} &{name0.new}::{ffun.new_str_eq()}() {{\n"
                            + f"{name.flint}_{ffun.flint}(data,data);\n"
                            + f"return *this;\n"
                            + f"}}\n")

            output.foot.append(f"{name.new} {ffun.new_str()}("
                               + f"const {name0.new} &in);\n")

            output.cpp.append(f"{name.new} {ffun.new_str()}("
                            + f"const {name0.new} &in) {{\n"
                            + f"auto result = {name.new}();\n"
                            + f"{name.flint}_{ffun.flint}(result.data,in.data);\n"
                            + f"return result;\n"
                            + f"}}\n")

    if template == "void(name:out,name,int:default=0)":

        for name0 in [name,name_ptr]:

            output(name0,
                    f"{name0.new} &{ffun.new_str_eq()}(const int in);\n")

            output.cpp.append(f"{name0.new} &{name0.new}::{ffun.new_str_eq()}(const int in) {{\n"
                + f"{name.flint}_{ffun.flint}(data,data,in);\n"
                + f"return *this;\n"
                + f"}}\n")

            output(name0, f"{name0.new} &{ffun.new_str_eq()}();\n")

            output.cpp.append(f"{name0.new} &{name0.new}::{ffun.new_str_eq()}() {{\n"
                + f"return {ffun.new_str_eq()}(0);\n"
                + f"}}\n")

            output.foot.append(f"{name.new} {ffun.new_str()}("
                             + f"const {name0.new} &in_1, const int in_2);\n")

            output.cpp.append(f"{name.new} {ffun.new_str()}("
                + f"const {name0.new} &in_1, const int in_2) {{\n"
                + f"auto result = {name.new}();\n"
                + f"{name.flint}_{ffun.flint}(result.data,in_1.data,in_2);\n"
                + f"return result;\n"
                + f"}}\n")

            output.foot.append(f"{name.new} {ffun.new_str()}("
                              + f"const {name0.new} &in);\n")

            output.cpp.append(f"{name.new} {ffun.new_str()}("
                + f"const {name0.new} &in) {{\n"
                + f"return {ffun.new_str()}(in,0);\n"
                + f"}}\n")

    if template == "bool(name,name/si):memonly":

        for name0,name1 in itertools.product([name,name_ptr],repeat=2):

            output(name0,f"bool {ffun.new_str()}(const {name1.new} &in) const;\n")

            output.cpp.append(f"bool {name0.new}::{ffun.new_str()}("
                + f"const {name1.new} &in) const {{\n"
                + f"return {name.flint}_{ffun.flint}(data,in.data);\n"
                + f"}}\n")

        si=True

        int_types = get_int_types(si=si,ui=ui)

        for int_type in int_types:

            suffix = get_suffix(int_type)

            for name0 in [name,name_ptr]:

                output(name0,f"bool {ffun.new_str()}(const {int_type} in) const;\n")

                output.cpp.append(f"bool {name0.new}::{ffun.new_str()}("
                    + f"const {int_type} in) const {{\n"
                    + f"return {name.flint}_{ffun.flint}_{suffix}(data,in);\n"
                    + f"}}\n")

    if template == "bool(name):notmem":

        for name0 in [name,name_ptr]:

            output.foot.append(f"bool {ffun.new_str()}(const {name0.new} &in);\n")

            output.cpp.append(f"bool {ffun.new_str()}("
                + f"const {name0.new} &in) {{\n"
                + f"return {name.flint}_{ffun.flint}(in.data);\n"
                + f"}}\n")

    if template in ["void(name:out,name,name/si/ui/ZZ):commutes",
                    "void(name:out,name,name/ZZ)",
                    "void(name:out,name,ZZ)",
                    "int(name:out,name,ZZ)" ]:

        suffix = "fmpz"

        for name0,name1 in itertools.product([name, name_ptr],["ZZ","ZZ_ptr"]):

            output(name0, f"{name0.new} &{ffun.new_str_eq()}(const {name1} &in);\n")

            tmp = f"{name0.new} &{name0.new}::{ffun.new_str_eq()}(const {name1} &in) {{\n"

            if template in ["int(name:out,name,ZZ)"]:
                tmp += "int error = "

            tmp += f"{name.flint}_{ffun.flint}_{suffix}(data,data,in.data);\n"

            if template in ["int(name:out,name,name)"]:
                tmp += f"if(error==0) {{\n"
                tmp += f'throw invalid_argument("{ffun.new_str_eq()} failed");\n'
                tmp += f"}}\n"

            tmp += f"return *this;\n"
            tmp += f"}}\n"

            output.cpp.append(tmp)

            output.foot.append(f"{name.new} {ffun.new_str()}("
                               + f"const {name0.new} &in_1, const {name1} &in_2);\n")

            tmp  = f"{name.new} {ffun.new_str()}("
            tmp += f"const {name0.new} &in_1, const {name1} &in_2) {{\n"
            tmp += f"auto result = {name.new}();\n"

            if template in ["int(name:out,name,name)"]:
                tmp += "int error = "

            tmp += f"{name.flint}_{ffun.flint}_{suffix}(result.data,in_1.data,in_2.data);\n"

            if template in ["int(name:out,name,name)"]:
                tmp += f"if(error==0) {{\n"
                tmp += f'throw invalid_argument("{ffun.new_str()} failed");\n'
                tmp += f"}}\n"

            tmp += f"return result;\n"
            tmp += f"}}\n"

            output.cpp.append(tmp)


    if template == "void(name:out,name,name/si/ui/ZZ):commutes":

        suffix = "fmpz"

        for name0,name1 in itertools.product([name, name_ptr],["ZZ","ZZ_ptr"]):

            output.foot.append(f"{name.new} {ffun.new_str()}("
                               + f"const {name1} &in_1, const {name0.new} &in_2);\n")

            output.cpp.append(f"{name.new} {ffun.new_str()}("
                              + f"const {name1} &in_1, const {name0.new} &in_2) {{\n"
                              + f"auto result = {name.new}();\n"
                              + f"{name.flint}_{ffun.flint}_{suffix}(result.data,in_2.data,in_1.data);\n"
                              + f"return result;\n"
                              + f"}}\n")

    if template in ["void(ZZ:out,name,ZZ)"]:

        suffix = "_fmpz"

        for name0,name1 in itertools.product([name,name_ptr],["ZZ","ZZ_ptr"]):

            output.foot.append(f"ZZ {ffun.new_str()}("
                               + f"const {name0.new} &in_1, const {name1} &in_2);\n")

            output.cpp.append(f"ZZ {ffun.new_str()}("
                            + f"const {name0.new} &in_1, const {name1} &in_2) {{\n"
                            + f"auto result = ZZ();\n"
                            + f"{name.flint}_{ffun.flint}{suffix}(result.data,in_1.data,in_2.data);\n"
                            + f"return result;\n"
                            + f"}}\n")

        for name0,name1 in itertools.product([name,name_ptr],get_int_types(si=True,ui=True)):

            output.foot.append(f"ZZ {ffun.new_str()}("
                               + f"const {name0.new} &in_1, const {name1} in_2);\n")

            output.cpp.append(f"ZZ {ffun.new_str()}("
                            + f"const {name0.new} &in_1, const {name1} &in_2) {{\n"
                            + f"auto result = ZZ();\n"
                            + f"{name.flint}_{ffun.flint}{suffix}(result.data,in_1.data,ZZ(in_2).data);\n"
                            + f"return result;\n"
                            + f"}}\n")


    return output

def negation(name,fun='neg'):

    output = SourceCode()

    output(name,f"{name.new} &operator-();\n")

    output.cpp.append(f"{name.new} &{name.new}::operator-() {{\n"
                    + f"{name.flint}_{fun}(data,data);\n"
                    + f"return *this;\n"
                    + f"}}\n")

    return output

def addmul(name,ui=True):

    output = SourceCode()

    fun_names = ["addmul", "submul"]

    name_ptr = name.ptr()

    for fun in fun_names:

        for name0, name1, name2 in itertools.product([name,name_ptr],repeat=3):

            output(name0,f"{name0.new} &{fun}(const {name1.new} &in_1, "
                                      + f"const {name2.new} &in_2);\n")

            output.cpp.append(f"{name0.new} &{name0.new}::{fun}(const {name1.new} &in_1, "
                            + f"const {name2.new} &in_2) {{\n"
                            + f"{name.flint}_{fun}(data,in_1.data,in_2.data);\n"
                            + f"return *this;\n"
                            + f"}}\n")

    ui_types = get_int_types(si=False,ui=True)
    if ui:
        for fun,int_type in itertools.product(fun_names,ui_types):

            for name0, name1 in itertools.product([name,name_ptr],repeat=2):

                output(name0,f"{name0.new} &{fun}(const {name1.new} &in_1, "
                                            + f"const {int_type} in_2);\n")

                output.cpp.append(f"{name0.new} &{name0.new}::{fun}(const {name1.new} &in_1, "
                                + f"const {int_type} in_2) {{\n"
                                + f"{name.flint}_{fun}_ui(data,in_1.data,in_2);\n"
                                + f"return *this;\n"
                                + f"}}\n")
    else:
        for fun,int_type in itertools.product(fun_names,ui_types):

            for name0, name1 in itertools.product([name,name_ptr],repeat=2):
                output(name0,f"{name.new} &{fun}(const {name1.new} &in_1, "
                                          + f"const {int_type} in_2);\n")

                output.cpp.append(f"{name0.new} &{name0.new}::{fun}(const {name1.new} &in_1, "
                                + f"const {int_type} in_2) {{\n"
                                + f"return addmul(in_1,{name.new}(in_2));\n"
                                + f"}}\n")

    si_types = get_int_types(si=True,ui=False)
    for int_type in si_types:

        for name0,name1 in itertools.product([name,name_ptr],repeat=2):

            output(name0,f"{name0.new} &addmul("
                    + f"const {name1.new} &in_1, const {int_type} in_2);\n")

            output.cpp.append(f"{name0.new} &{name0.new}::addmul(const {name1.new} &in_1, "
                            + f"const {int_type} in_2) {{\n"
                            + f"if(in_2 < 0) {{\n"
                            + f"return submul(in_1,(uint64_t) (-in_2));\n"
                            + f"}}"
                            + f"return addmul(in_1,(uint64_t) in_2);\n"
                            + f"}}\n")

            output(name0,f"{name0.new} &submul(const {name1.new} &in_1, const {int_type} in_2);\n")

            output.cpp.append(f"{name0.new} &{name0.new}::submul(const {name1.new} &in_1, "
                            + f"const {int_type} in_2) {{\n"
                            + f"if(in_2 < 0) {{\n"
                            + f"return addmul(in_1,(uint64_t) (-in_2));\n"
                            + f"}}"
                            + f"return submul(in_1,(uint64_t) in_2);\n"
                            + f"}}\n")

    int_types = ui_types + si_types

    for fun,int_type in itertools.product(fun_names,int_types):
        for name0,name1 in itertools.product([name,name_ptr],repeat=2):
            output(name0,f"{name0.new} &{fun}(const {int_type} in_1, "
                                      + f"const {name1.new} &in_2);\n")

            output.cpp.append(f"{name0.new} &{name0.new}::{fun}(const {int_type} in_1, "
                            + f"const {name1.new} &in_2) {{\n"
                            + f"return {fun}(in_2,in_1);\n"
                            + f"}}\n")

    for fun,int_type1,int_type2 in itertools.product(fun_names,
                                                     int_types,int_types):
        for name0 in [name,name_ptr]:
            output(name0,f"{name0.new} &{fun}(const {int_type1} in_1, "
                                      + f"const {int_type2} in_2);\n")

            output.cpp.append(f"{name0.new} &{name0.new}::{fun}(const {int_type1} in_1, "
                            + f"const {int_type2} in_2) {{\n"
                            + f"return {fun}({name.new}(in_1),in_2);\n"
                            + f"}}\n")

    return output

def ostream(name):

    output = SourceCode()

    output.foot.append(f"std::ostream &operator<<(std::ostream &os, const {name.new} &in);\n")
    output.cpp.append(f"ostream &operator<<(ostream &os, const {name.new} &in) {{\n"
                    + f"os << ((const string) in);\n"
                    + f"return os;\n"
                    + f"}}\n")

    return output;

def gen_ZZ():

    output = SourceCode()

    name = FlintName("ZZ", "fmpz")
    name_ptr = name.ptr()

    output += decl_ptr_struct(name)
    output += decl_struct(name)

    output += rule_of_five(name)

    for is_ptr,nm in enumerate([name,name_ptr]):
        output += copy_types(nm,is_ptr=(is_ptr!=0))
        output += cast(nm)
        output += ostream(nm)
        output += negation(nm)

    funs_by_template = {}

    funs_by_template["void(name:out,name,name/si/ui):commutes"] = [
            FlintFunc("+","add",True),
            FlintFunc("-","sub",True),
            FlintFunc("*","mul",True) ]

    funs_by_template["void(name:out,name,name/si/ui)"] =  [
            FlintFunc("cdiv_q", "cdiv_q"),
            FlintFunc("fdiv_q", "fdiv_q"),
            FlintFunc("tdiv_q", "tdiv_q"),
            FlintFunc("divexact","divexact") ]

    funs_by_template["void(name:out,name,name)"] =  [
            FlintFunc("gcd","gcd"),
            ]

    funs_by_template["int(name:out,name,name)"] =  [
            FlintFunc("pow","pow_fmpz"),
            ]

    funs_by_template["void(name:out,name,ui)"] =  [
            FlintFunc("<<","mul_2exp",True),
            FlintFunc("pow","pow_ui"),
            ]

    funs_by_template["void(name:out,name)"] =  [
            FlintFunc("abs","abs"),
            ]

    funs_by_template["void(name:out,name,int:default=0)"] =  [
            FlintFunc("next_prime","nextprime"),
            ]

    funs_by_template["void(name:out,name,name/ui)"] =  [
            FlintFunc("%","mod",True) ]

    funs_by_template["bool(name,name/si):memonly"] =  [
            FlintFunc("is_divisible_by","divisible") ]

    funs_by_template["bool(name):notmem"] =  [
            FlintFunc("is_prime","is_prime") ]

    for template,funs in funs_by_template.items():
        for fun in funs:
            output += translate_fun(name,fun,template)

    output += compare(name)
    output += addmul(name)

    return output

def gen_QQ():

    output = SourceCode()

    name = FlintName("QQ", "fmpq")
    name_ptr = name.ptr()

    output += decl_ptr_struct(name)
    output += decl_struct(name)

    output += rule_of_five(name)

    for is_ptr,nm in enumerate([name,name_ptr]):
        output += copy_types(nm,si=False,ui=False,sifrac=True,uifrac=True,ZZfrac=True,d=False,is_ptr=(is_ptr!=0))
        output += cast(nm,si=False,ui=False)
        output += ostream(nm)
        output += negation(nm)

    funs_by_template = {}

    funs_by_template["void(name:out,name,name/si/ui/ZZ):commutes"] = [
            FlintFunc("+","add",True),
            FlintFunc("-","sub",True),
            FlintFunc("*","mul",True) ]

    funs_by_template["void(name:out,name,name/ZZ)"] =  [
            FlintFunc("/", "div",True)]

    funs_by_template["int(name:out,name,ZZ)"] =  [
            FlintFunc("pow","pow"),
            ]

    funs_by_template["void(ZZ:out,name,ZZ)"] =  [
            FlintFunc("%", "mod",True)
            ]


    funs_by_template["void(name:out,name,ui)"] =  [
            FlintFunc("<<","mul_2exp",True),
            ]

    funs_by_template["void(name:out,name,si)"] =  [
            FlintFunc("pow","pow"),
            ]

    funs_by_template["void(name:out,name)"] =  [
            FlintFunc("abs","abs"),
            ]

    for template,funs in funs_by_template.items():
        for fun in funs:
            output += translate_fun(name,fun,template)

    return output;

def generate_header(hpp_fname="tmp.hpp", cpp_fname="tmp.cpp"):

    includes  = "#include <flint/fmpz.h>\n"
    includes += "#include <flint/fmpq.h>\n"
    includes += "#include <flint/fmpz_mat.h>\n"
    includes += "#include <algorithm>\n"
    includes += "#include <iomanip>\n"
    includes += "#include <iostream>\n"
    includes += "#include <string>\n"
    includes += "#include <type_traits>\n"
    includes += "#include <variant>\n"
    includes += "#include <vector>\n"
    includes += "\n"

    output = SourceCode()

    output.head.append(includes)

    output.cpp.append(f'#include "{hpp_fname}"')
    output.cpp.append("using namespace std;\n")

    output += gen_ZZ()
    output += gen_QQ()

    output.write(hpp_fname=hpp_fname,cpp_fname=cpp_fname)

    hpp_lc = 0
    for line in open(hpp_fname,'r').readlines():
        print(line,end="")
        hpp_lc += 1

    cpp_lc = 0
    for line in open(cpp_fname,'r').readlines():
        print(line,end="")
        cpp_lc += 1

    lc = hpp_lc + cpp_lc

    print("")
    print("------------------------>")
    print("")
    print(f"hpp line count = {hpp_lc}")
    print(f"cpp line count = {cpp_lc}")
    print(f"    line count = {lc}")
    print("")
    print("<------------------------")

if __name__ == "__main__":

    generate_header()

    # TODO:
    # *_mat* ...
    # generate unit tests
