#!/usr/bin/sage

import itertools

def triangular(n):

    return n*(n+1)/2

def is_triangular(a):

    return is_square(1+8*a)

def next_triangular(a):

    n = floor( (-1 + sqrt(1+8*a))/2 )

    return triangular(n+1)

def next_square(a):

    n = floor( sqrt(a) )

    return (n+1)^2

def pentagonal(n):

    return n*(3*n-1)/2

def is_pentagonal(a):

    if not is_square(1+24*a):
        return False

    P = (1 + sqrt(1+24*a))

    return P % 6 == 0

def next_pentagonal(a):

    n = floor( (1 + sqrt(1+24*a))/6 )

    return pentagonal(n+1)

def hexagonal(n):

    return n*(2*n-1)

def is_hexagonal(a):

    if not is_square(1+8*a):
        return False

    P = (1 + sqrt(1+8*a))

    return P % 4 == 0

def next_hexagonal(a):

    n = floor( (1+sqrt(1+8*a))/4 )

    return hexagonal(n+1)

def heptagonal(n):

    return n*(5*n-3)/2

def is_heptagonal(a):

    if not is_square(9+40*a):
        return False

    P = (3 + sqrt(9+40*a))

    return P % 10 == 0

def next_heptagonal(a):

    n = floor( (3 + sqrt(9+40*a))/10 )

    return heptagonal(n+1)

def octagonal(n):

    return n*(3*n-2)

def is_octagonal(a):

    if not is_square(1+3*a):
        return False

    P = (1 + sqrt(1+3*a))

    return P % 3 == 0

def next_octagonal(a):

    n = floor( (1 + sqrt(1+3*a)) / 3 )

    return octagonal(n+1)

def binary_search(min_val, max_val, test):

    if max_val == min_val:

        return min_val

    if max_val == min_val + 1:

        if test(min_val):
            return min_val
        else:
            return max_val

    mid_val = (max_val+min_val) // 2

    if test(mid_val):

        return binary_search(min_val, mid_val, test)

    else:

        return binary_search(mid_val+1, max_val, test)

types = [['triangular', triangular, is_triangular, next_triangular],
        ['square', lambda x: x^2, is_square, next_square],
        ['pentagonal', pentagonal, is_pentagonal, next_pentagonal],
        ['hexagonal', hexagonal, is_hexagonal, next_hexagonal],
        ['heptagonal', heptagonal, is_heptagonal, next_heptagonal],
        ['octagonal', octagonal, is_octagonal, next_octagonal]]

def gen_permutations(elements):

    if len(elements) == 1:

        return [[elements[0]]]

    ret = []

    for i in range(len(elements)):

        a = elements[i]

        subarray = elements[0:i]
        subarray += elements[i+1:]

        tails = gen_permutations(subarray)

        ret += [[a] + tup for tup in tails]

    return ret

def branch_cycles(vals, perm_types):

    num_vals = len(vals)

    verbose = False
    if num_vals >= 3 and vals[0] == 1281 and vals[1] == 8128 and vals[2] == 2882:
        verbose = True
        print('verbose! (%d)' % num_vals)
        if num_vals == 5:
            print(vals)


    if num_vals == 5:

        final_val = (vals[4] % 100) * 100 + (vals[0] // 100)

        if final_val < 1000:
            return []

        test = types[perm_types[4]][2]

        if test(final_val):
            return [vals + [final_val]]
        else:
            return []

    v = vals[num_vals-1]

    l_bd = (v % 100) * 100

    if l_bd < 1000:
        # has to be 4 digits
        return []

    u_bd = l_bd + 100
    l_bd -= 1

    next_of_type = types[perm_types[num_vals-1]][3]

    w = next_of_type(l_bd)

    if verbose and num_vals == 3:

        print(vals)
        print("l_bd = %d -> %d (%s)" % (l_bd, w,
            types[perm_types[num_vals-1]][0]))

    ret = []

    while w < u_bd:

        recur_vals = vals + [w]
        ret += branch_cycles(recur_vals, perm_types)

        w = next_of_type(w)

        if verbose and num_vals == 3 and w < u_bd:

            print("          -> %d (%s)" % (w,
                types[perm_types[num_vals-1]][0]))

    return ret


if __name__ == "__main__":

    # generate octagonal numbers

    oct_numbers = []

    n = 1

    while octagonal(n) < 10**3:

        n *= 2

    n = binary_search(n//2, n, lambda x: octagonal(x) >= 10**3)

    oc = octagonal(n)

    while oc < 10**4:

        oct_numbers.append(oc)

        n += 1
        oc = octagonal(n)

    # permutations for the types
    perm_types = gen_permutations(list(range(5)))

    ret = []
    for tup in itertools.product(oct_numbers, perm_types):

        ret += branch_cycles([tup[0]], tup[1])

    for tup in ret:
        print(sum(tup))
