# How to use C functions in Python

Here is a way that I got to work.

```cpp
#include <algorithm>
#include <iostream>
#include <memory>
#include <numeric>
#include <tuple>
#include <vector>

#include <gmp.h>

#include <pybind11/pybind11.h>
#include <pybind11/stl.h>
#include <pybind11/complex.h>
#include <pybind11/functional.h>
#include <pybind11/chrono.h>


using namespace std;

void mpz_addeq(mpz_t a, mpz_t b)
{
  mpz_add(a,a,b);
}

int64_t long use_mpz_addeq(int64_t a, int64_t b)
{
  mpz_t _a, _b;

  mpz_init(_a);
  mpz_init(_b);

  mpz_set_si(_a, a);
  mpz_set_si(_b, b);

  mpz_addeq(_a, _b);

  int64_t c = mpz_get_si(_a);

  mpz_clear(_a);
  mpz_clear(_b);

  return c;
}

vector<vector<int64_t>> mat_add(vector<vector<int64_t>> a, vector<vector<int64_t>> b)
{
  size_t nrows = a.size();
  size_t ncols = a[0].size();

  vector<vector<int64_t>> result = {};

  for(size_t row=0; row<nrows; row++)
  {
    vector<int64_t> row_vec = {};
    for(size_t col = 0; col<ncols; col++)
    {
      row_vec.push_back(a[row][col] + b[row][col]);
    }

    result.push_back(row_vec);
  }

  return result;
}

tuple<vector<vector<int64_t>>,int64_t> mat_add_tr(vector<vector<int64_t>> a, vector<vector<int64_t>> b)
{
  size_t nrows = a.size();
  size_t ncols = a[0].size();

  vector<vector<int64_t>> result = {};

  for(size_t row=0; row<nrows; row++)
  {
    vector<int64_t> row_vec = {};
    for(size_t col = 0; col<ncols; col++)
    {
      row_vec.push_back(a[row][col] + b[row][col]);
    }

    result.push_back(row_vec);
  }

  int64_t tr = 0;
  for(size_t row=0; row<min(nrows,ncols); row++)
  {
    tr += result[row][row];
  }

  return make_tuple(result,tr);
}

PYBIND11_MODULE(use_pybind11, m) {
  m.doc() = "pybind11 example plugin";

  m.def("use_mpz_addeq", &use_mpz_addeq, "add two numbers");
  m.def("mat_add", &mat_add, "add two matrices");
  m.def("mat_add_tr", &mat_add_tr, "add two matrices and also trace");
}
```

```Makefile
CXX = g++ -std=c++20 -O3 -Wall
CFLAGS = -shared -fPIC
# this is `python3 -m pybind11 --includes`
INCLUDES = -I/usr/include/python3.8 -I/home/dad/.local/lib/python3.8/site-packages/pybind11/include
LIBS = -lgmp

all: use_pybind11.cpython-38-x86_64-linux-gnu.so

# this is `python3-config --extension-suffix`
use_pybind11.cpython-38-x86_64-linux-gnu.so: use_pybind11.cpp
	$(CXX) $(CFLAGS) $(INCLUDES) $+ -o $@ $(LIBS)

clean:
	rm use_pybind11.cpython-38-x86_64-linux-gnu.so

.PHONY: clean
```

```Python
import use_pybind11

a = [[1,2],[1,-2]]
b = [[-1,1],[0,1]]
c, tr_c = use_pybind11.mat_add_tr(a,b)
```

# How to use C functions in Julia

Here is a way that I got to work.

``` C
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>

#include <gmp.h>

#include "test_code.h"

void mpz_addeq(mpz_t a, mpz_t b)
{
  mpz_add(a,a,b);
}

long long use_mpz_addeq(long long a, long long b)
{
  mpz_t _a, _b;

  mpz_init(_a);
  mpz_init(_b);

  mpz_set_si(_a, a);
  mpz_set_si(_b, b);

  mpz_addeq(_a, _b);

  int64_t c = mpz_get_si(_a);

  mpz_clear(_a);
  mpz_clear(_b);

  return c;
}

void do_mpz_add_mat(int64_t *c, int64_t *a, int64_t *b, size_t nrows, size_t ncols)
{
  mpz_t **A = (mpz_t **) malloc(nrows * sizeof(mpz_t *));
  mpz_t **B = (mpz_t **) malloc(nrows * sizeof(mpz_t *));

  for(size_t row = 0; row < nrows; row++)
  {
    A[row] = (mpz_t *) malloc(ncols * sizeof(mpz_t));
    B[row] = (mpz_t *) malloc(ncols * sizeof(mpz_t));

    for(size_t col = 0; col < ncols; col++)
    {
      mpz_init(A[row][col]);
      mpz_init(B[row][col]);

      mpz_set_si(A[row][col], a[row*nrows + col]);
      mpz_set_si(B[row][col], b[row*nrows + col]);

      mpz_addeq(A[row][col], B[row][col]);
    }
  }

  for(size_t row = 0; row < nrows; row++)
  {

    for(size_t col = 0; col < ncols; col++)
    {
      c[row*ncols + col] = mpz_get_si(A[row][col]);
    }
  }


  for(size_t row = 0; row < nrows; row++)
  {

    for(size_t col = 0; col < ncols; col++)
    {
      mpz_clear(A[row][col]);
      mpz_clear(B[row][col]);
    }

    free(A[row]);
    free(B[row]);
  }


  free(A);
  free(B);

}
```

```Makefile
CC = gcc -std=c99 -O3 -Wall -Werror
CFLAGS = -fPIC -c
INCLUDES =
LIBS = -lgmp

all: libtestcode.so

  test_code.o: test_code.c
$(CC) -fpic -c $(INCLUDES) $+ -o $@ $(LIBS)

  libtestcode.so: test_code.o
  gcc -shared -o libtestcode.so test_code.o -lgmp

#ar rcs libtestcode.so test_code.o

  clean:
  rm -rf test_code.o libtestcode.so

  .PHONY: clean
```

```julia
ccall((:do_mpz_add_mat, "libtestcode"), Cvoid, (Ptr{Int64}, Ptr{Int64}, Ptr{Int64}, UInt64, UInt64), C, A, B, 2, 2)
```
