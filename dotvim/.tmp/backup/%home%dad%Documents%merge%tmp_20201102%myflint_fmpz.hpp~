#pragma once

#include <algorithm>
#include <iostream>
#include <memory>
#include <numeric>
#include <tuple>
#include <vector>
#include <iomanip>

using namespace std;

#include <fmt/core.h>
#include <fmt/ostream.h>

using fmt::print;

// flint
#include <flint/flint.h>
#include <flint/fmpz.h>

// TODO: what are the correct C++ keywords to put on each kind of input?
//
// factoring
// factorization class


class Fmpz
{
  public:
    fmpz_t number;

    Fmpz();
    Fmpz(const int64_t& in_number);
    Fmpz(const fmpz_t& in_number);
    Fmpz(const string in_string);
    Fmpz(const Fmpz &other);

    Fmpz(Fmpz&& other) noexcept; // move constructor

    Fmpz& operator=(const Fmpz &other);
    Fmpz& operator=(const int64_t &other);


    ~Fmpz();

    // addition
    Fmpz& operator+=(const Fmpz& rhs);
    Fmpz operator+(const Fmpz &rhs) const;
    Fmpz& operator+=(const int64_t& rhs);
    Fmpz operator+(const int64_t& rhs) const;

    // subtraction
    Fmpz& operator-=(const Fmpz &rhs);
    Fmpz operator-(const Fmpz &rhs) const;
    Fmpz& operator-=(const int64_t &rhs);
    Fmpz operator-(const int64_t &rhs) const;

    Fmpz operator-() const;

    // multiplication
    Fmpz& operator*=(const Fmpz &rhs);
    Fmpz operator*(const Fmpz &rhs) const;
    Fmpz& operator*=(const int64_t &rhs);
    Fmpz operator*(const int64_t &rhs) const;

    void addmul(const Fmpz &in0, const Fmpz &in1);
    void addmul(const Fmpz &in0, const uint64_t &in1);
    void addmul(const uint64_t &in0, const Fmpz &in1);
    void addmul(const uint64_t &in0, const uint64_t &in1);
    void addmul(const Fmpz &in0, const int64_t &in1);
    void addmul(const int64_t &in0, const Fmpz &in1);
    void addmul(const int64_t &in0, const int64_t &in1);

    void submul(const Fmpz &in0, const Fmpz &in1);
    void submul(const Fmpz &in0, const uint64_t &in1);
    void submul(const uint64_t &in0, const Fmpz &in1);
    void submul(const uint64_t &in0, const uint64_t &in1);
    void submul(const Fmpz &in0, const int64_t &in1);
    void submul(const int64_t &in0, const Fmpz &in1);
    void submul(const int64_t &in0, const int64_t &in1);

    Fmpz& operator%=(const Fmpz &rhs);
    Fmpz operator%(const Fmpz &rhs) const;
    Fmpz& operator%=(const uint64_t &rhs);
    Fmpz operator%(const uint64_t &rhs) const;

    bool is_divisible_by(const Fmpz& poss_factor) const;

    Fmpz& operator/=(const Fmpz &rhs);
    Fmpz operator/(const Fmpz &rhs) const;

    bool operator==(const Fmpz &rhs) const;
    bool operator!=(const Fmpz &rhs) const;
    bool operator>(const Fmpz &rhs) const;
    bool operator>=(const Fmpz &rhs) const;
    bool operator<(const Fmpz &rhs) const;
    bool operator<=(const Fmpz &rhs) const;

    bool operator==(const int64_t &rhs) const;
    bool operator!=(const int64_t &rhs) const;
    bool operator>(const int64_t &rhs) const;
    bool operator>=(const int64_t &rhs) const;
    bool operator<(const int64_t &rhs) const;
    bool operator<=(const int64_t &rhs) const;

};

bool operator==(const int64_t &lhs, const Fmpz& rhs);
bool operator!=(const int64_t &lhs, const Fmpz& rhs);
bool operator>(const int64_t &lhs, const Fmpz& rhs);
bool operator>=(const int64_t &lhs, const Fmpz& rhs);
bool operator<(const int64_t &lhs, const Fmpz& rhs);
bool operator<=(const int64_t &lhs, const Fmpz& rhs);

ostream& operator<<(ostream& os, const Fmpz& f);

Fmpz pow(Fmpz base, int64_t exponent);

Fmpz abs(const Fmpz& in);
bool is_prime(const Fmpz& in);
