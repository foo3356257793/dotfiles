#include "myflint_ZZ.hpp"

ZZ_ptr& ZZ_ptr::operator=(const ZZ_ptr &other) { // copy assignment from ZZ
  fmpz_set((fmpz*) *this, (const fmpz*) other);
  return *this;
}
ZZ_ptr& ZZ_ptr::operator=(const ZZ &other) { // copy assignment from ZZ
  fmpz_set((fmpz*) *this, (const fmpz*) other);
  return *this;
}
ZZ_ptr& ZZ_ptr::operator=(const int64_t &other) { // copy assignment from int64_t
  fmpz_set_si((fmpz*) *this, other);
  return *this;
}
ZZ_ptr& ZZ_ptr::operator=(const string &other) { // copy assignment from string
  fmpz_set_str((fmpz*) *this, other.c_str(), 10);
  return *this;
}


ZZ_ptr& ZZ_ptr::apply_fmpz_fun_eq(const ZZ &rhs,
    const function<void(fmpz_t, fmpz_t, const fmpz_t)>& fun) {
  fun((fmpz*) *this,(fmpz*) *this, (const fmpz*) rhs);
  return *this;
}

ZZ_ptr& ZZ_ptr::apply_fmpz_fun_eq(const function<void(fmpz_t, fmpz_t)>& fun) {
  fun((fmpz*) *this, (fmpz*) *this);
  return *this;
}

ZZ_ptr& ZZ_ptr::apply_fmpz_fun_eq(int64_t in, const function<void(fmpz_t, fmpz_t, int64_t)>& fun) {
  fun((fmpz*) *this, (fmpz*) *this, in);
  return *this;
}

ZZ apply_fmpz_fun(
    const ZZ_ptr &lhs,
    const ZZ &rhs,
    const function<void(fmpz_t, const fmpz_t, const fmpz_t)>& fun) {
  auto result = ZZ();
  fun((fmpz*) result, (const fmpz*) lhs, (const fmpz*) rhs);
  return result;
}

ZZ apply_fmpz_fun(const ZZ_ptr &lhs, function<void(fmpz_t, const fmpz_t)> fun) {
  auto result = ZZ();
  fun((fmpz*) result, (const fmpz*) lhs);
  return result;
}

ZZ apply_fmpz_fun(const ZZ_ptr &lhs, int64_t in, function<void(fmpz_t, const fmpz_t, int64_t)> fun) {
  auto result = ZZ();
  fun((fmpz*) result, (const fmpz*) lhs, in);
  return result;
}

ZZ_ptr& ZZ_ptr::operator+=(const ZZ &rhs) { return apply_fmpz_fun_eq(rhs, fmpz_add); }
ZZ_ptr& ZZ_ptr::operator-=(const ZZ &rhs) { return apply_fmpz_fun_eq(rhs, fmpz_sub); }
ZZ_ptr& ZZ_ptr::operator*=(const ZZ &rhs) { return apply_fmpz_fun_eq(rhs, fmpz_mul); }
ZZ_ptr& ZZ_ptr::operator%=(const ZZ &rhs) { return apply_fmpz_fun_eq(rhs, fmpz_mod); }
ZZ_ptr& ZZ_ptr::operator/=(const ZZ &rhs) {
  return apply_fmpz_fun_eq(rhs, fmpz_divexact);
}
ZZ_ptr& ZZ_ptr::operator-() { return apply_fmpz_fun_eq(fmpz_neg); }

ZZ ZZ_ptr::operator+(const ZZ &rhs) const { return apply_fmpz_fun(*this, rhs, fmpz_add); }
ZZ ZZ_ptr::operator-(const ZZ &rhs) const { return apply_fmpz_fun(*this, rhs, fmpz_sub); }
ZZ ZZ_ptr::operator*(const ZZ &rhs) const { return apply_fmpz_fun(*this, rhs, fmpz_mul); }
ZZ ZZ_ptr::operator%(const ZZ &rhs) const { return apply_fmpz_fun(*this, rhs, fmpz_mod); }
ZZ ZZ_ptr::operator/(const ZZ &rhs) const {
  return apply_fmpz_fun(*this, rhs, fmpz_divexact);
}
ZZ ZZ_ptr::operator-() const { return apply_fmpz_fun(*this, fmpz_neg); }

ZZ_ptr& ZZ_ptr::addmul(const ZZ &in0, const ZZ &in1) {
  fmpz_addmul((fmpz*) *this, (const fmpz*) in0, (const fmpz*) in1);
  return *this;
}
ZZ_ptr& ZZ_ptr::submul(const ZZ &in0, const ZZ &in1) {
  fmpz_submul((fmpz*) *this, (const fmpz*) in0, (const fmpz*) in1);
  return *this;
}

bool ZZ_ptr::operator==(const ZZ &rhs) const {
  return fmpz_equal((const fmpz*) *this, (const fmpz*) rhs);
}

bool ZZ_ptr::operator==(const int64_t &rhs) const {
  return fmpz_equal_si((const fmpz*) *this, rhs);
}


#if 0
bool ZZ::operator!=(const ZZ &rhs) const {
  return !(fmpz_equal((fmpz*) *this, (fmpz*) rhs));
}
#endif

strong_ordering ZZ_ptr::operator<=>(const ZZ &rhs) const{
  return (fmpz_cmp((const fmpz*) *this,(const fmpz*) rhs))<=>0;
}

bool ZZ_ptr::is_divisible_by(const ZZ &poss_factor) const {
  return fmpz_divisible((const fmpz*) *this, (const fmpz*) poss_factor);
}

ZZ abs(const ZZ_ptr &in) { return apply_fmpz_fun(in,fmpz_abs); }

bool is_prime(const ZZ_ptr &in) {
  auto result = fmpz_is_prime((const fmpz*) in);
  return (result != 0);
}

ZZ pow(ZZ_ptr base, int64_t exponent) {
  if (exponent < 0) {
    throw invalid_argument("Negative exponentiation not supported for ZZ");
  }

  auto result = ZZ();
  fmpz_pow_ui((fmpz*) result, (const fmpz*) base, (uint64_t)exponent);

  return result;
}

ostream &operator<<(ostream &os, const ZZ_ptr &f) {
  char *out_string = fmpz_get_str(NULL, 10, (const fmpz*) f);
  os << out_string;
  free(out_string);

  return os;
}

ZZ gcd(const ZZ_ptr &a, const ZZ &b){
  return apply_fmpz_fun(a,b,fmpz_gcd);
}

ZZ_ptr& ZZ_ptr::next_prime(){
  return apply_fmpz_fun_eq(0,fmpz_nextprime);
}

ZZ next_prime(const ZZ_ptr &a){
  return apply_fmpz_fun(a,0,fmpz_nextprime);
}
