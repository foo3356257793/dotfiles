#include "myflint_fmpz.hpp"

Fmpz::Fmpz()
{
  fmpz_init(number);
}

Fmpz::Fmpz(const int64_t& in_number)
{
  fmpz_init_set_si(number, in_number);
}

Fmpz::Fmpz(const fmpz_t& in_number)
{
  fmpz_init_set(number, in_number);
}

Fmpz::Fmpz(const string in_string) : Fmpz()
{
  fmpz_set_str(number, in_string.c_str(), 10);
}

Fmpz::Fmpz(const Fmpz &other) : Fmpz(other.number) {}

Fmpz::Fmpz(Fmpz&& other) noexcept : Fmpz() {
  swap(number,other.number);
}

Fmpz& Fmpz::operator=(const Fmpz &other)
{
  fmpz_set(number, other.number);
  return *this;
}

Fmpz& Fmpz::operator=(const int64_t &other)
{
  fmpz_set_si(number, other);
  return *this;
}

Fmpz& Fmpz::operator=(Fmpz &&other) noexcept {
  swap(number,other.number);
  return *this;
}

Fmpz::~Fmpz()
{
  fmpz_clear(number);
}

// addition
Fmpz& Fmpz::operator+=(const Fmpz& rhs)
{
  fmpz_add(number, number, rhs.number);
  return *this;
}

Fmpz& Fmpz::operator+=(const int64_t& rhs)
{
  fmpz_add_si(number, number, rhs);
  return *this;
}

Fmpz Fmpz::operator+(const Fmpz &rhs) const
{
  auto result = Fmpz();
  fmpz_add(result.number, number, rhs.number);
  return result;
}

Fmpz Fmpz::operator+(const int64_t& rhs) const
{
  auto result = Fmpz();
  fmpz_add_si(result.number, number, rhs);
  return result;
}

// subtraction
Fmpz& Fmpz::operator-=(const Fmpz &rhs)
{
  fmpz_sub(number, number, rhs.number);
  return *this;
}

Fmpz& Fmpz::operator-=(const int64_t &rhs)
{
  fmpz_sub_si(number, number, rhs);
  return *this;
}

Fmpz Fmpz::operator-(const Fmpz &rhs) const
{
  auto result = Fmpz();
  fmpz_sub(result.number, number, rhs.number);
  return result;
}

Fmpz Fmpz::operator-(const int64_t &rhs) const
{
  auto result = Fmpz();
  fmpz_sub_si(result.number, number, rhs);
  return result;
}

Fmpz Fmpz::operator-() const
{
  auto result = Fmpz();
  fmpz_neg(result.number, number);
  return result;
}

// multiplication
Fmpz& Fmpz::operator*=(const Fmpz &rhs)
{
  fmpz_mul(number, number, rhs.number);
  return *this;
}

Fmpz& Fmpz::operator*=(const int64_t &rhs)
{
  fmpz_mul_si(number, number, rhs);
  return *this;
}

Fmpz Fmpz::operator*(const Fmpz &rhs) const
{
  auto result = Fmpz();
  fmpz_mul(result.number, number, rhs.number);
  return result;
}

Fmpz Fmpz::operator*(const int64_t &rhs) const
{
  auto result = Fmpz();
  fmpz_mul_si(result.number, number, rhs);
  return result;
}

// addmul
void Fmpz::addmul(const Fmpz &in0, const Fmpz &in1) {fmpz_addmul(number, in0.number, in1.number);}
void Fmpz::addmul(const Fmpz &in0, const uint64_t &in1) {fmpz_addmul_ui(number, in0.number, in1);}
void Fmpz::addmul(const uint64_t &in0, const Fmpz &in1) {addmul(in1,in0);}
void Fmpz::addmul(const uint64_t &in0, const uint64_t &in1) {addmul(Fmpz(in0),in1);}

// submul
void Fmpz::submul(const Fmpz &in0, const Fmpz &in1) {fmpz_submul(number, in0.number, in1.number);}
void Fmpz::submul(const Fmpz &in0, const uint64_t &in1) {fmpz_submul_ui(number, in0.number, in1);}
void Fmpz::submul(const uint64_t &in0, const Fmpz &in1) {submul(in1,in0);}
void Fmpz::submul(const uint64_t &in0, const uint64_t &in1) {submul(Fmpz(in0),in1);}

// handle signed integers by passing unsigned part to one of these
void Fmpz::addmul(const Fmpz &in0, const int64_t &in1)
{
  if(in1 >= 0) addmul(in0, (uint64_t) in1);
  else submul(in0, (uint64_t) (-in1));
}
void Fmpz::addmul(const int64_t &in0, const Fmpz &in1){addmul(in1,in0);}
void Fmpz::addmul(const int64_t &in0, const int64_t &in1){addmul(Fmpz(in0),in1);}

void Fmpz::submul(const Fmpz &in0, const int64_t &in1){addmul(in0,-in1);}
void Fmpz::submul(const int64_t &in0, const Fmpz &in1){submul(in1,in0);}
void Fmpz::submul(const int64_t &in0, const int64_t &in1){submul(Fmpz(in0),in1);}

// division
Fmpz& Fmpz::operator%=(const Fmpz &rhs)
{
  fmpz_mod(number, number, rhs.number);
  return *this;
}

Fmpz& Fmpz::operator%=(const uint64_t &rhs)
{
  fmpz_mod_ui(number, number, rhs);
  return *this;
}

Fmpz Fmpz::operator%(const Fmpz &rhs) const
{
  auto result = Fmpz();
  fmpz_mod(result.number, number, rhs.number);
  return result;
}

Fmpz Fmpz::operator%(const uint64_t &rhs) const
{
  auto result = Fmpz();
  fmpz_mod_ui(result.number, number, rhs);
  return result;
}

Fmpz& Fmpz::operator/=(const Fmpz& rhs)
{
  fmpz_divexact(number, number, rhs.number);
  return *this;
}

Fmpz Fmpz::operator/(const Fmpz& rhs) const
{
  auto result = Fmpz();
  fmpz_divexact(result.number, number, rhs.number);
  return *this;
}

// comparison
bool Fmpz::operator==(const Fmpz &rhs) const
{
  return (bool) fmpz_equal(number, rhs.number);
}

bool Fmpz::operator==(const int64_t &rhs) const
{
  return (bool) fmpz_equal_si(number, rhs);
}

bool Fmpz::operator!=(const Fmpz &rhs) const
{
  return !(fmpz_equal(number, rhs.number));
}
bool Fmpz::operator!=(const int64_t &rhs) const
{
  return !(fmpz_equal_si(number, rhs));
}

bool Fmpz::operator>(const Fmpz &rhs) const
{
  return (fmpz_cmp(number, rhs.number) > 0);
}
bool Fmpz::operator>(const int64_t &rhs) const
{
  return (fmpz_cmp_si(number,rhs) > 0);
}

bool Fmpz::operator>=(const Fmpz &rhs) const
{
  return (fmpz_cmp(number, rhs.number) >= 0);
}
bool Fmpz::operator>=(const int64_t &rhs) const
{
  return (fmpz_cmp_si(number,rhs) >= 0);
}

bool Fmpz::operator<=(const Fmpz &rhs) const
{
  return (fmpz_cmp(number, rhs.number) <= 0);
}
bool Fmpz::operator<=(const int64_t &rhs) const
{
  return (fmpz_cmp_si(number,rhs) <= 0);
}

bool Fmpz::operator<(const Fmpz &rhs) const
{
  return (fmpz_cmp(number, rhs.number) < 0);
}
bool Fmpz::operator<(const int64_t &rhs) const
{
  return (fmpz_cmp_si(number,rhs) < 0);
}

bool operator==(const int64_t& lhs, const Fmpz& rhs)
{
  return (rhs==lhs);
}
bool operator!=(const int64_t& lhs, const Fmpz& rhs)
{
  return (rhs!=lhs);
}
bool operator>(const int64_t& lhs, const Fmpz& rhs)
{
  return (rhs<lhs);
}
bool operator>=(const int64_t& lhs, const Fmpz& rhs)
{
  return (rhs<=lhs);
}
bool operator<=(const int64_t& lhs, const Fmpz& rhs)
{
  return (rhs>=lhs);
}
bool operator<(const int64_t& lhs, const Fmpz& rhs)
{
  return (rhs>lhs);
}


bool Fmpz::is_divisible_by(const Fmpz& poss_factor) const
{
  return fmpz_divisible(number,poss_factor.number);
}

// other stuff
Fmpz abs(const Fmpz& in)
{
  auto result = Fmpz();
  fmpz_abs(result.number, in.number);
  return result;
}

bool is_prime(const Fmpz& in)
{
  auto result = fmpz_is_prime(in.number);
  return (result != 0);
}

ostream& operator<<(ostream& os, const Fmpz& f)
{
  char *out_string = fmpz_get_str(NULL, 10, f.number);
  os << out_string;
  free(out_string);

  return os;
}


Fmpz pow(Fmpz base, int64_t exponent)
{
  if(exponent < 0)
  {
    throw invalid_argument("Negative exponentiation not supported for Fmpz");
  }

  auto result = Fmpz();
  fmpz_pow_ui(result.number, base.number, (uint64_t) exponent);

  return result;
}

template<typename T>
Fmpz operator+(const T &lhs, const Fmpz &rhs) { return rhs * lhs; }
template<typename T>
Fmpz operator-(const T &lhs, const Fmpz &rhs) { return -(rhs - lhs); }
//template<typename T>

//Fmpz operator*(const int64_t& lhs, const Fmpz& rhs) { return rhs * lhs; }

//Fmpq operator/(const int64_t &lhs, const Fmpz &rhs);
