#define _ftype fmpz

#define _TYPE _ZZ


#include "rule_of_five.cpp"

#define _TYPE_OUT _TYPE

#define _setfun _fun_paster(_ftype,set_si)
#include "copys_si.cpp"
#undef _setfun

#define _setfun _fun_paster(_ftype,set_ui)
#include "copys_ui.cpp"
#undef _setfun

#define _setfun _fun_paster(_ftype,set_d)
#include "copys_df.cpp"
#undef _setfun

#define _setfun _fun_paster(_ftype,set_str)
#include "copy_string.cpp"
#undef _setfun

#define _getfun _fun_paster(_ftype,get_str)
#include "cast_string.cpp"
#undef _getfun

#undef _TYPE_OUT


#define _getfun _fun_paster(_ftype,get_si)
#include "cast_si.cpp"
#undef _getfun

#define _getfun _fun_paster(_ftype,get_ui)
#include "cast_ui.cpp"
#undef _getfun

#define _getfun _fun_paster(_ftype,get_d)
#include "cast_df.cpp"
#undef _getfun

#include "ZZ_auto.cpp"

#define _funname_eq pow_eq
#define _funnative _fun_paster(_ftype,pow_fmpz)
#define _checkinput int error =
#define _checkoutput if(error=0) {throw invalid_argument("pow_eq failed");}
#include "fun_NN_eq_star.cpp"
#undef _checkoutput
#undef _checkinput
#undef _funnative
#undef _funname_eq

_TYPE &_TYPE::next_prime_eq(int proved){
  _fun_paster(_ftype,nextprime)(data,data,proved);
  return *this;
}

_TYPE &_TYPE::next_prime_eq(){
  return next_prime_eq(1);
}

bool _TYPE::is_prime() const{
  return _fun_paster(_ftype,is_prime)(data);
}

#undef _TYPE
