#!/usr/bin/sage

import itertools

import time

def find_completions(base, e_c):

    if e_c == 1:

        return [base]

    fac_e_c = factor(e_c)

    prime_factors = [tup[0] for tup in fac_e_c if tup[0] > 1]

    p = prime_factors[-1]

    e_c /= p

    if e_c % p != 0:

        # need to include p in base
        base *= p^2

        new_e_c = (p-1) * e_c

        G = gcd(base, new_e_c)

        while G > 1:

            new_e_c /= G

            G = gcd(G, new_e_c)

        return find_completions(base, new_e_c)

    # need to branch on whether to include p
    while e_c % p == 0:
        e_c /= p

    base_w_p = base * p^2

    new_e_c = (p-1) * e_c

    G = gcd(base, new_e_c)

    while G > 1:

        new_e_c /= G

        G = gcd(G, new_e_c)

    ret_w_p = find_completions(base_w_p, new_e_c)

    ret_w_no_p = find_completions(base, e_c)

    return ret_w_p + ret_w_no_p

def check_achilles(C):

    fac_C = factor(C)

    gcd_coeffs = gcd([tup[1] for tup in fac_C if tup[0] > 1])

    return (gcd_coeffs == 1)

def check_strong_achilles(C, base_primes):


    fac_C = []

    _C = C
    for p in base_primes:

        tup = [p,0]

        while _C % p == 0:
            _C /= p
            tup[1] += 1

        if tup[1] > 0:
            fac_C.append(tup)

    fac__C = factor(_C)

    for tup in fac__C:

        fac_C.append(tup)

    C_exponents = [tup[1] for tup in fac_C]
    gcd_coeffs = gcd(C_exponents)
    min_coeffs = min(C_exponents)

    if gcd_coeffs > 1 or min_coeffs <= 1:
        return False

    phi_primes = [tup[0] for tup in fac_C]
    phi_exponents = [tup[1]-1 for tup in fac_C]
    for tup in fac_C:

        p = tup[0]

        new_factors = factor(p-1)

        for new_tup in new_factors:

            q = new_tup[0]

            if q in phi_primes:

                index = phi_primes.index(q)

                phi_exponents[index] += new_tup[1]

            else:

                phi_primes.append(q)
                phi_exponents.append(new_tup[1])

    gcd_coeffs = gcd(phi_exponents)
    min_coeffs = min(phi_exponents)

    if gcd_coeffs > 1 or min_coeffs <= 1:
        return False

    return True

def branch_strong_achilles(C_primes, C_exponents, phi_primes, phi_exponents,
        C, n, base_primes, index):

    if C >= n:
        return []

    if index >= len(base_primes):

        if gcd(C_exponents) == 1 and gcd(phi_exponents) == 1 and min(C_exponents) > 1 and min(phi_exponents) > 1:
            return [C]
        else:
            return []

    ret = []
    _C_exponents = copy(C_exponents)
    _phi_exponents = copy(phi_exponents)
    for extra_pow in range(3):

        ret += branch_strong_achilles(C_primes, _C_exponents, phi_primes,
                _phi_exponents, C, n, base_primes, index+1)

        C *= base_primes[index]
        if C >= n:
            break

        arr_index = C_primes.index(base_primes[index])
        _C_exponents[arr_index] += 1

        arr_index = phi_primes.index(base_primes[index])
        _phi_exponents[arr_index] += 1

    return ret

def find_strong_achilles_forms(C, base, n):

    if C == 1:
        return []

    fac_base = factor(base)
    base_primes = [tup[0] for tup in fac_base if tup[0] > 1]

    # do the processing to get everything out
    fac_C = []

    _C = C
    for p in base_primes:

        tup = [p,0]

        while _C % p == 0:
            _C /= p
            tup[1] += 1

        if tup[1] > 0:
            fac_C.append(tup)

    fac__C = factor(_C)

    for tup in fac__C:

        fac_C.append(tup)

    C_primes = [tup[0] for tup in fac_C]
    C_exponents = [tup[1] for tup in fac_C]

    phi_primes = [tup[0] for tup in fac_C]
    phi_exponents = [tup[1]-1 for tup in fac_C]
    for tup in fac_C:

        p = tup[0]

        new_factors = factor(p-1)

        for new_tup in new_factors:

            q = new_tup[0]

            if q in phi_primes:

                index = phi_primes.index(q)

                phi_exponents[index] += new_tup[1]

            else:

                phi_primes.append(q)
                phi_exponents.append(new_tup[1])

    return branch_strong_achilles(C_primes, C_exponents, phi_primes,
            phi_exponents, C, n, base_primes, 0)


if __name__ == "__main__":

    n = 10**18

    max_cube_part = floor(n**(1/3))

    strong_achilles_numbers = []
    num_strong_achilles_numbers = 0

    start_time = time.perf_counter()

    for c in range(1,max_cube_part+1):

        if c % (100) == 0:
            print('c=%d (%d)...' % (c, num_strong_achilles_numbers))

        if c % (1000) == 0 and c > 0:
            end_time = time.perf_counter()

            tot_time = end_time-start_time

            print("TIME = %.3lf min" % (tot_time/60.0))

            est_time = tot_time * (max_cube_part / c)

            print("est TIME = %.3lf hours" % (est_time/(60.0*60.0)))

        e_c = euler_phi(c)

        # get piece which is coprime to c

        G = gcd(e_c, c)

        while G > 1:

            e_c /= G

            G = gcd(e_c, G)

        compl = find_completions(c, e_c)

        for C in compl:

            C *= c^2

            if C <= n:

                ret = find_strong_achilles_forms(C, c, n)

                num_strong_achilles_numbers += len(ret)

    print("found %d strong achilles below %d" % (num_strong_achilles_numbers,
        n))

    end_time = time.perf_counter()

    tot_time = end_time-start_time

    print("TIME = %.3lf min" % (tot_time/60.0))
