using Nemo
using Random
using Formatting
using Test
using Statistics

import Base: log2, ==
import LinearAlgebra: lq, norm

using LoadFlint
const libflint = LoadFlint.libflint

ZZ = FlintZZ
QQ = FlintQQ

Nemo.getindex(m::fmpz_mat, index::Int64) = begin
    #=
    # return a row matrix, unless there is only one row,
    # in which case return the entry at column 'index'
    =#
    if nrows(m) == 1
        m[1,index]
    else
        view(m,index,1,index,ncols(m))
    end
end

function lq(m::fmpz_mat,signs=true)

    num_rows = nrows(m)
    num_cols = ncols(m)

    L,Q = lq(d_mat(m))
    Q = Array{Float64,2}(Q)

    if signs
        for col in 1:num_rows
            if L[col,col] < 0
                for row in col:num_rows
                    L[row,col] *= -1
                end
                for subcol in 1:num_cols
                    Q[col,subcol] *= -1
                end
            end
        end
    end

    return L,Q
end

function example_mat()
    Random.seed!(1234)

    dims = (3,4)

    out = MatrixSpace(ZZ,dims[1],dims[2])()

    bound = ZZ(1)<<128

    for (row,col) in Iterators.product(1:dims[1],1:dims[2])
        out[row,col] = rand(-bound:bound)
    end

    return out
end

function comp_mats(m_ZZ::fmpz_mat,m_Float64::Array{Float64,2})
    out = 0
    for (row,col) in Iterators.product(1:dims[1],1:dims[2])
        if m_ZZ[row,col] == 0
            if abs(m_Float64[row,col]) > 1e-6
                out += 1
            end
        else
            targ = Float64(m_ZZ[row,col])
            if abs((targ - m_Float64[row,col])/targ) > 1e-6
                out += 1
            end
        end
    end

    return out
end

function comp_mats(m_1::Array{Float64,2},m_2::Array{Float64,2})

    dim_1 = size(m_1)
    dim_2 = size(m_2)

    if dim_1 != dim_2
        return 1
    end

    out = 0

    for (row,col) in Iterators.product(1:dim_1[1],1:dim_1[2])

        den = max(1.0,abs(m_1[row,col]))

        if abs(m_1[row,col]-m_2[row,col])/den > 1e-4
            out += 1
        end
    end

    return out
end

function TEST_lq()
    @testset "TEST lq" begin

        mat = example_mat()

        L,Q = lq(mat)

        # test that LQ is approx mat
        should_mat = L*Q

        @test comp_mats(mat,should_mat) == 0

        # test that L is lower triang

        num_bad = 0
        for row in 1:nrows(mat)
            for col in row+1:nrows(mat)
                if abs(L[row,col]) > 1e-6
                    num_bad += 1
                end
            end
        end

        @test num_bad == 0

        # test that Q is orthogonal
        should_id = Q * transpose(Q)

        (I_rows,I_cols) = size(should_id)

        @test I_rows == I_cols

        num_bad = 0
        for (row,col) in Iterators.product(1:I_rows,1:I_cols)

            value = should_id[row,col]

            if row==col
                value -= 1
            end

            if abs(value) > 1e-6
                num_bad += 1
            end
        end

        @test num_bad==0

    end
end

function apply_2_by_2(c11,c12,c21,c22,a1,a2)

    new1 = c11*a1 + c12*a2
    new2 = c21*a1 + c22*a2

    return new1,new2
end

function TEST_apply_2_by_2()
    @testset "TEST apply_2_by_2" begin
        a1 = ZZ(5)
        a2 = ZZ(7)

        c11 = 3
        c12 = -2
        c21 = -7
        c22 = 5

        a1,a2 = apply_2_by_2(c11,c12,c21,c22,a1,a2)

        @test a1 == 1
        @test a2 == 0
    end
end

function norm_sq(vec)
    return sum([v^2 for v in vec])
end

function TEST_norm_sq()
    @testset "TEST norm_sq" begin
        v = [1,2]
        @test norm_sq(v) == 5
    end
end

function norm(vec::Array{fmpz,1})
    return sqrt(Float64(norm_sq(vec)))
end

function TEST_norm()
    @testset "TEST norm" begin
        v = [1,2]
        @test abs(norm(v) - sqrt(5)) < 1e-6
    end
end

function dual_basis(mat::fmpz_mat)

    mat_inv,den = pseudo_inv(mat)
    out = transpose(mat_inv)

    dim = nrows(out)

    for row in 1:(dim รท 2)
        swap_rows!(out,row,dim+1-row)
    end

    if den < 0
        out = -out
        den = -den
    end

    return out,den
end

function rand_mod_diag_mat(M::fmpz,dim::Int64,num_mod::Int64)

    out = identity_matrix(ZZ, dim)

    for row in 1:num_mod
        out[row,row] = M
    end

    for row in (num_mod+1):dim
        out[row,1] = rand(ZZ(1):M)
    end

    return out

end

function TEST_dual_basis()
    @testset "TEST dual_basis" begin
        Random.seed!(0)

        dim = 4

        mat = rand_mod_diag_mat(ZZ(1)<<32,dim,1)
        mat = lll(mat)

        dmat,den = dual_basis(mat)

        dot_mat = mat * transpose(dmat)

        num_bad = 0
        for (row,col) in Iterators.product(1:nrows(dot_mat),1:ncols(dot_mat))
            if dot_mat[row,col] % den != 0
                num_bad += 1
            end
        end

        @test num_bad == 0

        L,Q = lq(mat)
        L_d, Q_d = lq(dmat)

        num_bad = 0
        for row in 1:dim
            prod_value = L[row,row] * L_d[dim+1-row,dim+1-row]
            if abs(log2(prod_value) - log2(den)) > 1e-6
                num_bad += 1
            end
        end

        @test num_bad == 0
    end
end


function nextprime(a::fmpz)

    out = a

    # Notes: calling this function
    #
    # void fmpz_nextprime(fmpz_t res, const fmpz_t n, int proved)
    #
    # 'Nothing' is the 'void' return type
    # next is the tuple of input types
    # next is the actual input values
    ccall((:fmpz_nextprime, libflint), Nothing, (Ref{fmpz}, Ref{fmpz}, Int64), out, a, 1)

    return out
end

function nextprime(a::Integer)
    return nextprime(ZZ(a))
end

function TEST_nextprime()

    @testset "TEST nextprime" begin
        @test nextprime(4) == 5
        @test nextprime(ZZ(1)<<64) == 18446744073709551629
    end

end

function log2(a::fmpz)
    return log2(max(0.5,abs(Float64(a))))
end

function TEST_log2()

    @testset "TEST log2" begin
        @test log2(ZZ(0)) == -1
        @test log2(ZZ(-2)) == 1
        @test log2(1234) == log2(ZZ(1234))
    end

end

function round_rand(a::Float64)

    out = ZZ(round(a))

    expon = 0
    try
        expon = exponent(a)
    catch e
        # happens when a rounds to 0 or a is NaN or Inf
        return out
    end

    if expon > 52
        expon -= 52

        bound = ZZ(round(abs(significand(a)) * 2.0^expon))

        out += rand(-bound:bound)
    end

    return out
end

function TEST_round_rand()
    @testset "TEST round_rand" begin
        a = 2.0^128
        a_round = round_rand(a)

        @test ((round(a) - Float64(round_rand(a))) / a) < 2.0^(-51)

        a = -a
        @test ((round(a) - Float64(round_rand(a))) / a) < 2.0^(-51)
    end
end


function rand_vec_of_len(mat::fmpz_mat,L::Array{Float64,2},target_len,primitive=true)

    dim = nrows(mat)

    # check if we expect to be able to do this
    for col in 1:dim
        if abs(L[col,col]) > 2*target_len
            throw(DomainError("matrix not sufficiently conditioned to hit target"))
        end
    end

    target_vec = [randn(Float64) for _ in 1:dim]

    norm = sum([v^2 for v in target_vec])
    norm = sqrt(norm)

    scale = target_len / norm

    curr_vec = zeros(Float64, dim)
    coeffs = zeros(ZZ, dim)

    for col in Iterators.reverse(1:dim)
        c_float = round((scale * target_vec[col] - curr_vec[col]) / L[col,col])
        coeffs[col] = round_rand(c_float)

        for subcol in 1:col
            curr_vec[subcol] += c_float * L[col,subcol]
        end
    end

    if primitive
        G = gcd(coeffs)

        while G > 1
            coeffs += [rand(-G:G) for _ in 1:dim]
            G = gcd(coeffs)
        end
    end

    out = zeros(ZZ, dim)
    for (row,col) in Iterators.product(1:dim,1:dim)
        out[col] += coeffs[row] * mat[row,col]
    end

    return out
end

function inspan(mat::fmpz_mat,vec::Array{fmpz,1})
    dim = nrows(mat)

    try
        solve(transpose(mat),MatrixSpace(ZZ,dim,1)(vec))
    catch e
        return false
    end

    return true
end

function is_unimodular_equiv(orig_mat::fmpz_mat,new_mat::fmpz_mat)
    try
        U = solve(transpose(orig_mat),transpose(new_mat))
        D = abs(det(U))
        return D == 1
    catch e
        return false
    end
end


function TEST_rand_vec_basis()
    @testset "TEST rand_vec_of_len" begin

        dim = 4

        log2_target_len = 64
        target_len = 2.0^log2_target_len

        mat = rand_mod_diag_mat(ZZ(1)<<128,dim,1)
        mat = lll(mat)
        L,_ = lq(mat)

        vec = rand_vec_of_len(mat,L,target_len)

        # is this in the basis?
        @test inspan(mat,vec)

        # is it the correct length
        @test abs(log2(norm(vec)) - log2_target_len) < 1e-6

        # if the matrix is not well-conditioned, throw an error
        mat = rand_mod_diag_mat(ZZ(1)<<128,4,1)
        L,_ = lq(mat)

        @test_throws DomainError rand_vec_of_len(mat,L,target_len)

    end
end

function d_mat(m::fmpz_mat)
    out = zeros(Float64,nrows(m),ncols(m))

    for (row,col) in Iterators.product(1:nrows(m),1:ncols(m))
        out[row,col] = m[row,col]
    end

    return out
end

function TEST_d_mat()
    @testset "TEST d_mat" begin

        Random.seed!(1234)

        m_ZZ = example_mat()

        m_Float64 = d_mat(m_ZZ)

        @test comp_mats(m_ZZ,m_Float64) == 0
    end
end

function reduce_col(m::fmpz_mat,L::Array{Float64,2},col::Int64)
    for row in col+1:nrows(m)

        c = round(L[row,col]/L[col,col])

        for subcol in 1:col
            L[row,subcol] -= c * L[col,subcol]
        end

        c_ZZ = ZZ(c)

        for subcol in 1:ncols(m)
            m[row,subcol] -= c_ZZ * m[col,subcol]
        end
    end

    return m,L
end


function TEST_reduce_col()
    @testset "TEST reduce_col" begin
        Random.seed!(31415)

        dim = 4

        mat = rand_mod_diag_mat(ZZ(1)<<128,dim,1)
        mat = lll(mat)

        col = 2
        bound = ZZ(64)

        # perturb the rows randomly
        for row in col+1:dim
            c = rand(-bound:bound)

            for subcol in 1:dim
                mat[row,col] += c*mat[col,col]
            end
        end

        L,_ = lq(mat)

        orig_mat = deepcopy(mat)

        mat,L = reduce_col(mat,L,col)

        L_corr, _ = lq(mat)

        @test comp_mats(L,L_corr) == 0

        @test is_unimodular_equiv(orig_mat,mat)

        num_bad = 0
        for row in col+1:dim
            ratio = L[row,col] / L[col,col]

            if abs(ratio) > 0.5 + 1e-6
                num_bad += 1
            end
        end

        @test num_bad == 0
    end
end


function reduce_columns(m::fmpz_mat,L::Array{Float64,2},colstart::Int64=0,maybe_bad_prec=false)

    dim = nrows(m)

    if colstart==0
        colstart = dim
    end

    for col in Iterators.reverse(1:colstart)
        m,L = reduce_col(m,L,col)
    end

    if maybe_bad_prec
        L,_ = lq(m)

        for col in 1:colstart
            for row in col+1:dim
                if abs(L[row,col]/L[col,col]) > (0.5+1e-6)
                    return reduce_columns(m,L,colstart,true)
                end
            end
        end
    end

    return m, L
end


function TEST_reduce_columns()
    @testset "TEST reduce_columns" begin

        Random.seed!(31415)

        dim = 4

        mat = rand_mod_diag_mat(ZZ(1)<<128,dim,1)
        mat = lll(mat)

        bound = ZZ(64)

        for col in 1:dim-1
            for row in col+1:dim
                c = rand(-bound:bound)
                for subcol in 1:dim
                    mat[row,col] += c*mat[col,col]
                end
            end
        end

        L,_ = lq(mat)

        orig_mat = deepcopy(mat)

        mat,L = reduce_columns(mat,L)

        L_corr, _ = lq(mat)

        @test comp_mats(L,L_corr) == 0

        @test is_unimodular_equiv(orig_mat,mat)

        num_bad = 0
        for col in 1:dim-1
            for row in col+1:dim
                ratio = L[row,col] / L[col,col]

                if abs(ratio) > 0.5 + 1e-6
                    num_bad += 1
                end
            end
        end

        @test num_bad == 0

    end
end

function weak_reduce_has_enough_precision(L,rowbegin,rowend)
    if rowbegin == 1
        return true
    end

    max_pre_diag = max([L[row,row] for row in 1:(rowbegin-1)])

    post_diag = mean([L[row,row] for row in rowbegin:rowend])

    score = max_pre_diag / post_diag

    # TODO: what is the right MIN_SCORE?
    MIN_SCORE = 2.0^(52-16)

    return score > MIN_SCORE
end

function weak_reduce(m::fmpz_mat,rowbegin::Int64=1,rowend::Int64=0)

    dim = nrows(m)

    if rowend == 0
        rowend = dim
    end

    if (rowbegin < rowend) || (rowbegin < 1) || (rowend > dim)
        throw(DomainError("bad bounds for weak_reduce"))
    end

    if rowbegin == rowend
        return m,L
    end

    if !weak_reduce_has_enough_precision(L,rowbegin,rowend)
        throw(DomainError("gap between top and bottom too large"))
    end

    L,_ = lq(m)
    reduce_columns(m,L,rowend)

    row = rowbegin+1

    while row >= rowend

        norm_prev = L[row-1,row-1]^2
        norm_next = L[row,row-1]^2 + L[row,row]^2

        if norm_prev > norm_next
            swap_rows!(m,row-1,row)

            L,_ = lq(m)
            reduce_columns(m,L,row)

            row = max(rowbegin+1,row-1)
        else
            row += 1
        end
    end

    return m,L
end


function TEST_weak_reduce()
    @testset "TEST weak_reduce" begin

        Random.seed!(31415)

        dim = 4

        mat = rand_mod_diag_mat(ZZ(1)<<128,dim,1)

        @test_throws DomainError weak_reduce(mat)

        mat = lll(mat)

        @test weak_reduce(mat)

        # TODO: place a thing and weak reduce below
    end
end

function ==(row_mat::fmpz_mat,vec::Array{fmpz,1})
    if nrows(row_mat) > 1
        println("not a row mat")
        return false
    end

    dim = ncols(row_mat)
    if length(vec) != dim
        println("dims don't match")
        return false
    end

    for col in 1:dim
        if row_mat[col] != vec[col]
            return false
        end
    end

    return true
end

function place_vector(mat::fmpz_mat,vec::Array{fmpz,1},row::Int64=1)

    if ncols(mat) != length(vec)
        throw(DomainError("vec invalid length for mat"))
    end

    dim = nrows(mat)

    if dim != ncols(mat)
        throw(DomainError("non-square mat not supported"))
    end

    dl_mat, _ = dual_basis(mat)

    col_vec = MatrixSpace(ZZ, ncols(mat), 1)(vec)
    dot_vec = dl_mat * col_vec

    pivot = 1
    max_row = dim+1-row

    while pivot < max_row && dot_vec[pivot,1] == 0
        pivot += 1
    end

    while pivot < max_row
        g,u,v = gcdx(dot_vec[pivot,1],dot_vec[pivot+1,1])

        s = dot_vec[pivot+1,1] รท g
        t = -dot_vec[pivot,1] รท g

        dot_vec[pivot,1],dot_vec[pivot+1,1] = apply_2_by_2(s,t,u,v,
                                                       dot_vec[pivot,1],dot_vec[pivot+1,1])

        for col in 1:dim
            mat[dim-pivot,col],mat[dim+1-pivot,col] = apply_2_by_2(s,-t,-u,v,
                                                       mat[dim-pivot,col],mat[dim+1-pivot,col])
        end

        pivot += 1
    end

    return mat
end


function TEST_place_vector()
    @testset "TEST place_vector" begin

        Random.seed!(31415)

        dim = 4
        mat = rand_mod_diag_mat(ZZ(1)<<128,dim,1)
        mat = lll(mat)

        log2_target_len = 64
        target_len = 2.0^log2_target_len

        L,_ = lq(mat)

        vec = rand_vec_of_len(mat,L,target_len)

        mat = place_vector(mat,vec)

        printfmtln("vec = {}", vec)
        printfmtln("mat = {}", mat)

        @test mat[1]==vec
    end
end


function TEST_rand_mat()
    @testset "TEST rand_mat" begin
        Random.seed!(31415)

        log2_target_len = 64
        target_len = 2.0^log2_target_len
    end
end


function aux_prime_list(log2_det::Float64,log2_aux_prime_start::Float64)

    num_aux_primes = Int64(ceil(log2_det / log2_aux_prime_start))

    printfmtln("num_aux_primes = {}", num_aux_primes)

    p = ZZ(floor(2.0^log2_aux_prime_start))

    out = []
    log2_last_prime = log2_det

    for i in 1:(num_aux_primes-1)
        p = nextprime(p)

        # NOTE: have to deepcopy these fmpz objects
        push!(out,deepcopy(p))
        log2_last_prime -= log2(p)
    end

    p = nextprime(ZZ(floor(2.0^log2_last_prime)))

    if num_aux_primes > 1 && p >= out[1]
        p = nextprime(out[num_aux_primes-1])
    end

    # don't have to copy the last one
    push!(out,p)

    return out
end

function TEST_aux_prime_list()
    @testset "TEST aux_prime_list" begin
    end
end

#=
@testset "ALL TESTS" begin
    #=
    TEST_lq()
    TEST_apply_2_by_2()
    TEST_norm_sq()
    TEST_norm()
    TEST_dual_basis()
    TEST_nextprime()
    TEST_log2()
    TEST_round_rand()
    TEST_rand_vec_basis()
    TEST_d_mat()
    =#
    TEST_reduce_col()
    TEST_reduce_columns()
    TEST_place_vector()
    TEST_rand_mat()
end
=#

Random.seed!(31415)

dim = 4
log2_target_len = 64.0
target_len = 2.0^log2_target_len

mat = identity_matrix(ZZ,dim)

# rand vec and place
L,_ = lq(mat)
vec = rand_vec_of_len(mat,L,target_len)

mat = place_vector(mat,vec,1)

L,_ = lq(mat)

weights = ones(Float64,dim)

pivot = 1
while pivot < dim && L[pivot,pivot] / L[pivot+1,pivot+1] < 4
    global pivot
    pivot += 1
end

for row in pivot+1:dim
    weights[row] = max(1.0,L[pivot,pivot]/L[row,row])
end

tmp_mat = deepcopy(mat)

for row in pivot+1:dim

    global pivot

    if weights[row] == 1
        continue
    end

    w = ZZ(round(weights[row]))

    for col in 1:ncols(tmp_mat)
        tmp_mat[row,col] *= w
    end
end

tmp_L,_ = lq(tmp_mat)
tmp_mat,tmp_L = reduce_columns(tmp_mat,tmp_L,0,true)

printfmtln("L =\n{}",L)

for col in pivot+1:dim
    global L
    inv_w = 1.0/weights[col]
    for row in col:dim
        L[row,col] = tmp_L[row,col] * inv_w
    end
end

# do we need to reweight again
pivot = 1
while pivot < dim && tmp_L[pivot,pivot] / tmp_L[pivot+1,pivot+1] < 4
    global pivot
    pivot += 1
end

new_weights = ones(Float64,dim)
for row in pivot+1:dim
    new_weights[row] = max(1.0,L[pivot,pivot]/L[row,row])
end

for row in pivot+1:dim

    global pivot

    if new_weights[row] == 1.0
        continue
    end

    w = ZZ(round(new_weights[row]))

    for col in 1:ncols(tmp_mat)
        tmp_mat[row,col] *= w
    end
end

tmp_L,_ = lq(tmp_mat)
tmp_mat,tmp_L = reduce_columns(tmp_mat,tmp_L,0,true)

for col in pivot+1:dim
    global L
    inv_w = 1.0/(weights[col] * new_weights[col])
    for row in col:dim
        L[row,col] = tmp_L[row,col] * inv_w
    end
end
