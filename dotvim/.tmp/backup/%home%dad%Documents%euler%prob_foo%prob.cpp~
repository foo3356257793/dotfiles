#include <assert.h> // for debugging
#include <bits/stdc++.h> // need for status bar
#include <omp.h> // for parallel for loops

// C++ std library stuff to import
#include <algorithm> // various algorithms
#include <iostream> // easy printing
#include <vector> // I use vectors here

#include <memory>

#include <execution>

// testing
#include <gtest/gtest.h>

// fmt
#include <fmt/core.h>
#include <fmt/format.h>

using fmt::print;

// C++ std functions I'm using
using std::cout;
using std::endl;
using std::max_element;
using std::min;
using std::ostream;
using std::setw;
using std::sort;
using std::string;
using std::vector;

using std::unique_ptr;
using std::make_unique;

using std::shared_ptr;
using std::make_shared;

using std::make_heap;
using std::sort_heap;

// parameters to test
const int NUM_WHEAT = 1 << 4;
const int TARGET_NUM_WHEAT = NUM_WHEAT / 2;
const int NUM_TARES = NUM_WHEAT;
const int NUM_ROUNDS = 4;

// print vectors by <<
template <typename T>
std::ostream &operator<<(std::ostream &out, const std::vector<T> &v) {
  if (!v.empty()) {
    out << '[';
    std::copy(v.begin(), v.end(), std::ostream_iterator<T>(out, ", "));
    out << "\b\b]";
  }
  return out;
}

// convenient for printing the status of running steps
void display_progress_bar(int num_complete, int num_total, double time,
                          string name) {
  int num_dashes = (20 * num_complete) / num_total;
  int percent = (100 * num_complete) / num_total;
  const int total_width = 100 / 5;

  int count_width = ceil(log10(num_total + 1));

  cout << "\r"
       << "[" << string(num_dashes, (char)'-')
       << string(total_width - num_dashes, ' ') << "]";
  cout << setw(3) << percent << "%"
       << "  [" << name << " " << setw(count_width) << num_complete << " of "
       << num_total << "]"
       << "  (" << setw(9) << time << " secs)";
  std::cout.flush();
}

// vector with labels and cut info
class Observation {
 public:
  vector<double> values;
  string label;
  int index_bound;
  friend ostream &operator<<(ostream &os, const Observation &observation);

  Observation(vector<double> input_values, string input_label,
              int input_index_bound) {
    values = input_values;
    label = input_label;
    index_bound = input_index_bound;
  }

  Observation(vector<double> input_values, string input_label) {
    values = input_values;
    label = input_label;
    index_bound = input_values.size();
  }
};

// print an Observation
std::ostream &operator<<(std::ostream &out, const Observation &obs) {
  out << "Observation with label " << obs.label << endl;
  out << "  index_bound = " << obs.index_bound << endl;
  out << obs.values;

  return out;
}

// boundary for a round: value and location in sorted list for round
class RoundBoundary {
 public:
  double value;
  int index;
  int num_rounds;
  //vector<Observation *>::iterator location;
  vector<shared_ptr<Observation>>::iterator location;

  RoundBoundary() {}

  // also updates the cut information
  // RoundBoundary(vector<Observation *>::iterator it,
  //               vector<Observation *>::iterator end, int round_index,
  RoundBoundary(vector<shared_ptr<Observation>>::iterator it,
      vector<shared_ptr<Observation>>::iterator end, int round_index,
                int input_num_rounds) {
    index = round_index;
    num_rounds = input_num_rounds;

    // cut tares OR wheat which already have a cut
    while ((it != end) &&
           (((*it)->label != "wheat") || ((*it)->index_bound < num_rounds))) {
      (*it)->index_bound = min((*it)->index_bound, index);
      it++;
    }
    assert(it != end);

    value = (*it)->values[index];
    location = it;
  }

  // doesn't update cut information, but computes score_delta
  //RoundBoundary(vector<Observation *>::iterator it,
  //              vector<Observation *>::iterator end,
  RoundBoundary(vector<shared_ptr<Observation>>::iterator it,
      vector<shared_ptr<Observation>>::iterator end,
                int round_index,
                int input_num_rounds, int &score_delta) {
    index = round_index;
    num_rounds = input_num_rounds;

    while (it != end && (*it)->label != "wheat") {
      score_delta += (*it)->index_bound - index;
      it++;
    }
    assert(it != end);

    value = (*it)->values[index];
    location = it;
  }
};

// sorted data, boundaries, and score info for a round
class Round {
 public:
  //vector<Observation *> sorted_data;
  vector<shared_ptr<Observation>> sorted_data;
  int index;
  int num_rounds;
  int score_delta = 0;
  RoundBoundary boundary;
  RoundBoundary next_boundary;

  //Round(vector<Observation *> input_data,
  Round(vector<shared_ptr<Observation>> input_data,
      int round_index,
        int input_num_rounds) {

    // note to self: this copies the input_data vector to make a new vector
    sorted_data = input_data;
    num_rounds = input_num_rounds;

    index = round_index;

    auto comp = [round_index](const shared_ptr<Observation> &a,
        const shared_ptr<Observation> &b) -> bool {
      return a->values[round_index] > b->values[round_index];
    };

    // sort the data on index `round_index`
    sort(sorted_data.begin(), sorted_data.end(), comp);
    //sort(std::execution::par, sorted_data.begin(), sorted_data.end(), comp);
    //make_heap(sorted_data.begin(), sorted_data.end(), comp);
    //sort_heap(sorted_data.begin(), sorted_data.end(), comp);

    // compute the boundaries
    boundary = RoundBoundary(sorted_data.begin(), sorted_data.end(), index,
                             num_rounds);
  }

  // the next boundary after the current one
  // compute the new score delta as well
  void compute_next_boundary() {
    score_delta = (*boundary.location)->index_bound - index;
    next_boundary = RoundBoundary(boundary.location + 1, sorted_data.end(),
                                  index, num_rounds, score_delta);
  }

  // get the next boundary after this one and update index_bounds for
  // observations in betweeen
  void step_boundary() {
    //vector<Observation *>::iterator it = boundary.location;
    vector<shared_ptr<Observation>>::iterator it = boundary.location;

    (*it)->index_bound = min((*it)->index_bound, index);
    it++;

    boundary = RoundBoundary(it, sorted_data.end(), index, num_rounds);
  }
};

// everything we are going to use to analyze what boundaries to pick
class MyDataInRounds {
 public:
  //vector<Observation *> data;
  vector<shared_ptr<Observation>> data;
  int num_rounds;
  // TODO: use smart pointer for this
  //vector<Round *> rounds;
  vector<unique_ptr<Round>> rounds;
  int num_wheat;

  //MyDataInRounds(vector<Observation *> input_data, int input_num_rounds) {
  MyDataInRounds(vector<shared_ptr<Observation>> input_data, int input_num_rounds) {
    data = input_data;
    num_rounds = input_num_rounds;

    //rounds = vector<Round *>(num_rounds);
    rounds = vector<unique_ptr<Round>>(num_rounds);

    double start_time = omp_get_wtime();

    cout << endl;
    cout << "Sorting..." << endl;

    int rounds_complete = 0;
    display_progress_bar(rounds_complete, num_rounds, 0, "Round");

    #pragma omp parallel for
    for (int round = 0; round < num_rounds; round++) {
      //rounds[round] = new Round(data, round, num_rounds);
      rounds[round] = make_unique<Round>(data, round, num_rounds);

      #pragma omp critical
      {
        rounds_complete++;
        display_progress_bar(rounds_complete, num_rounds,
                             omp_get_wtime() - start_time, "Round");
      }
    }

    double end_time = omp_get_wtime();
    cout << endl;
    cout << "Took " << end_time - start_time << " sec." << endl;
    cout << endl;

    // reprocess rounds to set next_boundary
    #pragma omp parallel for
    for (auto& round_ptr : rounds) {
      round_ptr->compute_next_boundary();
    }

    num_wheat = count_if(data.begin(), data.end(), [](shared_ptr<Observation> &a) -> bool {
      return a->label == "wheat";
    });
  }

  // figure out where to make the next cut
  void cut_wheat() {

    // find max score delta
    vector<unique_ptr<Round>>::iterator arg_max =
        max_element(rounds.begin(), rounds.end(),
                    [](const unique_ptr<Round> &a, const unique_ptr<Round> &b) -> bool {
                      return a->score_delta < b->score_delta;
                    });

    // set the boundary
    //Observation *obs_ptr = *((*arg_max)->boundary.location);
    shared_ptr<Observation> obs_ptr = *((*arg_max)->boundary.location);
    obs_ptr->index_bound = (*arg_max)->index;

    #pragma omp parallel for
    for (auto &round_ptr : rounds) {
      //Observation *obs_ptr = *(round_ptr->boundary.location);
      shared_ptr<Observation> obs_ptr = *(round_ptr->boundary.location);
      if (obs_ptr->index_bound < num_rounds) {
        round_ptr->step_boundary();
      }
    }

    // recompute all score_deltas
    #pragma omp parallel for
    for (auto &round_ptr : rounds) {
      round_ptr->compute_next_boundary();
    }

    num_wheat--;
  }
};


MyDataInRounds(vector<double> wheat, vector<double> tares)
{
  auto data = load_data(wheat, tares);

}

// generate random data
vector<double> gen_random_vector(const int vector_length) {
  vector<double> values(vector_length);

  for (int index = 0; index < vector_length; index++) {
    values[index] =
        (double)((((uint64_t)rand()) << 48) + (((uint64_t)rand()) << 32) +
                 (rand() << 16) + (rand()));
  }

  // make these correlated
  for (int i = vector_length - 2; i >= 0; i--) {
    values[i] += values[i + 1];
  }

  return values;
}

// generate random data
vector<vector<double>> gen_random_vector_of_vectors(const int num_vectors,
                                                    const int vector_length) {
  vector<vector<double>> vec(num_vectors);

  for (int index = 0; index < num_vectors; index++) {
    vec[index] = gen_random_vector(vector_length);
  }

  return vec;
}

// is this vector below the boundaries?
bool test_vector(vector<double> vec, vector<double> boundaries) {
  for (int i = 0; i < vec.size(); i++) {
    if (vec[i] > boundaries[i]) {
      return false;
    }
  }

  return true;
}

vector<shared_ptr<Observation>> load_data(
    vector<vector<double>> wheat,
    vector<vector<double>> tares)
{

  vector<shared_ptr<Observation>> data = {};

  for (auto vec : wheat) {
    //data.push_back(new Observation(vec, "wheat", num_rounds));
    data.push_back(make_shared<Observation>(vec, "wheat"));
  }
  for (auto vec : tares) {
    //data.push_back(new Observation(vec, "tares", num_rounds));
    data.push_back(make_shared<Observation>(vec, "tares"));
  }

  return data;
}


// find the boundaries given wheat and tares
vector<double> find_boundaries(vector<vector<double>> wheat,
                               vector<vector<double>> tares, int num_rounds,
                               int target_num_wheat) {
  cout << endl;
  cout << "Placing data into solver..." << endl;

  // label and put into data object
  auto data = load_data(wheat, tares);

  // put into the MyDataInRounds class
  MyDataInRounds my_data(data, num_rounds);

  cout << "Cutting..." << endl;

  int num_to_cut = my_data.num_wheat - target_num_wheat;
  int cut_so_far = 0;

  display_progress_bar(0, num_to_cut, 0, "Cut");

  double start_time = omp_get_wtime();

  // cut out wheat until done
  while (my_data.num_wheat > target_num_wheat) {
    my_data.cut_wheat();

    cut_so_far++;
    if ((cut_so_far == num_to_cut) || ((cut_so_far & ((1 << 16) - 1)) == 0)) {
      display_progress_bar(cut_so_far, num_to_cut, omp_get_wtime() - start_time,
                           "Cut");
    }
  }

  double end_time = omp_get_wtime();
  cout << endl;
  cout << "Took " << end_time - start_time << " sec." << endl;
  cout << endl;

  // look at boundary
  vector<double> result = {};
  for (auto &round_ptr : my_data.rounds) {
    result.push_back(round_ptr->boundary.value);
  }

  #if 0
  // clean up
  for (auto obs : data) {
    delete obs;
  }
  #endif

  return result;
}

TEST(Tests, TestLoadData) {

  vector<vector<double>> wheat = {{1,2},{3,4}};
  vector<vector<double>> tares = {{1,1},{7,11}};

  auto num_rounds = 2;

  auto data = load_data(wheat, tares);

  EXPECT_EQ(data.size(), wheat.size() + tares.size());

  vector<vector<double>> loaded_wheat = {};
  vector<vector<double>> loaded_tares = {};

  // manually check that if we unwind the data we get our input
  for (auto &obs : data)
  {

    EXPECT_TRUE(obs->label == "wheat" || obs->label == "tares");

    if(obs->label == "wheat")
    {
      loaded_wheat.push_back(obs->values);
    }
    else if(obs->label == "tares")
    {
      loaded_tares.push_back(obs->values);
    }

    EXPECT_EQ(obs->index_bound, num_rounds);
  }

  ASSERT_EQ(wheat.size(), loaded_wheat.size());

  sort(wheat.begin(), wheat.end());
  sort(loaded_wheat.begin(), loaded_wheat.end());

  auto wheat_it = wheat.begin();
  auto loaded_wheat_it = loaded_wheat.begin();

  while(wheat_it < wheat.end())
  {
    ASSERT_EQ(*wheat_it,*loaded_wheat_it);

    ++wheat_it;
    ++loaded_wheat_it;
  }

  ASSERT_EQ(tares.size(), loaded_tares.size());

  sort(tares.begin(), tares.end());
  sort(loaded_tares.begin(), loaded_tares.end());

  auto tares_it = tares.begin();
  auto loaded_tares_it = loaded_tares.begin();

  while(tares_it < tares.end())
  {
    ASSERT_EQ(*tares_it,*loaded_tares_it);

    ++tares_it;
    ++loaded_tares_it;
  }

}

TEST(Tests, TestMyDataInRoundsLoad) {

  vector<vector<double>> wheat = {{1,2},{3,4}};
  vector<vector<double>> tares = {{1,1},{7,11}};

  auto num_rounds = 2;

  auto data = load_data(wheat,tares);

  MyDataInRounds my_data(data, num_rounds);

  // verify manually that this is good
  EXPECT_EQ(my_data.num_rounds, num_rounds);
  EXPECT_EQ(my_data.num_wheat, 2);

}

TEST(Tests, TestMyDataInRoundsQuickLoad) {

  vector<vector<double>> wheat = {{1,2},{3,4}};
  vector<vector<double>> tares = {{1,1},{7,11}};

  auto num_rounds = 2;

  MyDataInRounds my_data(wheat, tares);

  // verify manually that this is good
  EXPECT_EQ(my_data.num_rounds, num_rounds);
  EXPECT_EQ(my_data.num_wheat, 2);

}



TEST (Tests, TestGenRandomVectors) {

  vector<vector<double>> wheat =
    gen_random_vector_of_vectors(NUM_WHEAT, NUM_ROUNDS);

  EXPECT_EQ(wheat.size(), NUM_WHEAT);
  EXPECT_EQ(wheat[0].size(), NUM_ROUNDS);
}

TEST (Tests, FmtWorks) {
  print("Works? {}", true);
}

TEST (Tests, CanPrintVecs) {

  vector<vector<double>> wheat =
    gen_random_vector_of_vectors(2, 2);

  for(auto vec : wheat) {
    print("{}", fmt::join(vec, ", "));
  }

}

int main(int argc, char *argv[]) {

  #if 0
  srand(0);

  cout << "Generating data..." << endl;
  // generate random data
  vector<vector<double>> wheat =
      gen_random_vector_of_vectors(NUM_WHEAT, NUM_ROUNDS);
  vector<vector<double>> tares =
      gen_random_vector_of_vectors(NUM_TARES, NUM_ROUNDS);
  #endif

  #if 0
  print("INPUT DATA\n");
  print("printing wheat...\n");
  for(auto vec : wheat) {
    print("{}\n", fmt::join(vec, ", "));
  }
  print("printing tares...");
  for(auto vec : tares) {
    print("{}\n", fmt::join(vec, ", "));
  }
  #endif

  #if 0
  // find the boundaries
  vector<double> boundaries =
      find_boundaries(wheat, tares, NUM_ROUNDS, TARGET_NUM_WHEAT);

  cout << endl;
  cout << "boundaries:" << endl;
  cout << boundaries << endl;
  #endif

  ::testing::InitGoogleTest(&argc, argv);
  return RUN_ALL_TESTS();

}
