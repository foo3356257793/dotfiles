#!/usr/bin/python3

import os
from datetime import datetime, timedelta

import yaml

def datetime_weekend(dt):

    weekday = dt.weekday()

    return dt + timedelta(days=((5-weekday)%7))

def datetime_from_string(dt_string):

    try:
        dt = datetime.strptime(dt_string, '%Y-%m-%d %H:%M:%S.%f')
    except:
        raise ValueError(f'Failed to parse this string: {dt_str}')

    return dt


def pretty_timedelta(td):

    seconds = td.total_seconds()
    seconds = round(seconds)

    minutes, seconds = divmod(seconds, 60)
    hours, minutes = divmod(minutes, 60)

    if hours > 0:
        return '%2d hr %2d min %2d sec' % (hours, minutes, seconds)
    elif minutes > 0:
        return '%2d min %2d sec' % (minutes, seconds)

    return '%2d sec' % (seconds)


if __name__ == "__main__":

    # get the time now
    dt_now = datetime.now()

    #######################
    # what is the filename?
    #######################

    fname_head = 'time_log'

    # what is the first day in the week?
    dt_weekend = datetime_weekend(dt_now)
    week_str = dt_weekend.strftime('%Y%m%d')

    fname = f'{fname_head}_{week_str}.yaml'

    if not os.path.exists(fname):

        print('No time data found for this week')
        exit(1)

    ###############
    # load the data
    ###############

    with open(fname, 'r') as f:

        data = yaml.load(f, Loader=yaml.FullLoader)

    ####################
    # put data into dict
    ####################

    times_for_tag = {}

    for line in data:

        tag = line[0]
        dt_string = line[1]

        dt = datetime_from_string(dt_string)

        if not tag in times_for_tag:

            times_for_tag[tag] = [timedelta(0), dt]

        elif times_for_tag[tag][1] == None:

            times_for_tag[tag][1] = dt

        else:

            times_for_tag[tag][0] += dt - times_for_tag[tag][1]
            times_for_tag[tag][1] = None

    # close tags and add up and stop open tags
    totals = []

    for item in times_for_tag.items():

        tag = item[0]
        total_tm, start_tm = item[1]

        if start_tm != None:
            total_tm += dt_now - start_tm
            tag = '*' + tag

        totals.append([total_tm, tag])

    totals.sort(reverse=True)

    max_len_tag = max([len(entry[1]) for entry in totals])

    time_strings = [pretty_timedelta(entry[0]) for entry in totals]

    max_len_time = max([len(time_string) for time_string in time_strings])

    for entry, time_string in zip(totals, time_strings):

        tag = entry[1]

        print(f'{tag:{max_len_tag}} {time_string:>{max_len_time}}')
