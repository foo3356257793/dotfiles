#include "myflint_factor.hpp"

//#include <map>
#include <functional>

auto print_factor_array(ostream &os, vector<tuple<Fmpz,int64_t>> in, bool include_times) {

  for(auto &tup : in) {
    auto[base, exponent] = tup;

    if(exponent == 0) continue;

    if(include_times) {
      os << " * ";
    }
    include_times = true;

    os << base;

    if(exponent != 1) {
      os << "^" << exponent;
    }
  }

  return include_times;
}

ostream& operator<<(ostream& os, const Factorization<Fmpz>& factors)
{
  if((factors.prime_factors.size() + factors.other_factors.size()) == 0) {
    os << "1";
    return os;
  }

  bool include_times = false;

  include_times = print_factor_array(os, factors.prime_factors, include_times);
  include_times = print_factor_array(os, factors.other_factors, include_times);

  return os;
}

Factor::Factor(int64_t in)
{
  fmpz_factor_init(data);
  bits = in;
}

Factor::Factor() : Factor(15L) {}; // default param

Factor::~Factor()
{
  fmpz_factor_clear(data);
}

tuple<int64_t,Fmpz> root_perfect_power(const Fmpz& in)
{
  auto root = Fmpz();
  auto exponent = fmpz_is_perfect_power(root.number,in.number);

  if(exponent == 0 || exponent == 1)
  {
    return tuple(1,in);
  }

  // not guaranteed that 'root' is minimal: recurse
  auto[recurse_exponent,recurse_root] = root_perfect_power(root);
  return tuple(exponent * recurse_exponent, recurse_root);
}

auto recover_large_factor(Fmpz& remainder,
                          const Fmpz& fac,
                          const int64_t& exponent,
                          vector<tuple<Fmpz,int64_t>>& target)
{

  if(remainder.is_divisible_by(fac))
  {
    target.push_back(tuple(fac,exponent));
    remainder /= pow(fac,exponent);
  }
  else if(exponent == 1)
  {
    target.push_back(tuple(remainder,1));
  }
  else
  {
    auto[exponent,root] = root_perfect_power(remainder);
    target.push_back(tuple(root,exponent));
  }

}

template <typename T>
void sort_factorization_vec(vector<tuple<T,int64_t>>& vec) {

  sort(vec.begin(), vec.end(), [](tuple<T,int64_t>& a, tuple<T,int64_t>& b){
      auto[a_fac,a_exponent] = a;
      auto[b_fac,b_exponent] = b;
      return a_fac < b_fac;
      });
}

  template <typename T>
void Factorization<T>::sort()
{
  sort_factorization_vec(prime_factors);
  sort_factorization_vec(other_factors);
}

#if 0
Factorization<Fmpz> Factor::operator()(const Fmpz& in)
{
  int success = fmpz_factor_smooth(data,in.number,bits,0);

  auto remainder = abs(in);

  auto num_factors = data->num;

  auto result = Factorization<Fmpz>();

  for(int index=0; index<num_factors-1; index++)
  {
    auto fac = Fmpz(data->p[index]);
    auto exponent = data->exp[index];

    result.prime_factors.push_back(tuple(fac,exponent));

    remainder /= pow(fac,exponent);
  }

  auto fac = Fmpz(data->p[num_factors-1]);
  auto exponent = data->exp[num_factors-1];

  if(success==1) {
    recover_large_factor(remainder, fac, exponent, result.prime_factors);
  }
  else {
    recover_large_factor(remainder, fac, exponent, result.other_factors);
  }

  result.sort();

  return result;
}
#endif

Factorization<Fmpz> Factor::operator()(const Fmpz& in)
{
  int success = fmpz_factor_smooth(data,in.number,bits,0);

  //print("success: {}\n", success);

  auto num_factors = data->num;
  auto result = Factorization<Fmpz>();

  auto remainder = abs(in);

  for(int index=0; index<num_factors; index++)
  {
    auto fac = Fmpz();
    fmpz_factor_get_fmpz(fac.number, data, index);

    print("{},{}\n", fac, data->exp[index]);

    int64_t exponent = 0;
    while(remainder.is_divisible_by(fac))
    {
      remainder /= fac;
      exponent++;
    }

    print("actually found {},{}\n", fac,exponent);

    if(exponent == 0) continue;

    const auto tup = tuple(fac,exponent);

    if((success==1) || index<num_factors-1) {
      result.prime_factors.push_back(tup);
    }
    else {
      result.other_factors.push_back(tup);
    }
  }

  if(remainder != 1)
  {
    result.other_factors.push_back(tuple(remainder,1));
  }

  result.sort();

  return result;
}

tuple<fmpz_t*,slong> Factor::operator[](const slong index)
{
  if((index < 0) || (index >= num)){
    throw invalid_argument("Out of bounds access on Factor");
  }

  return tuple(&(data->p + index),data->exp[index]);
}

ostream& operator<<(ostream& os, const Factor& f)
{
  os << "Factor class element (bits = " << f.bits << ")";
  return os;
}


template <>
Fmpz Factorization<Fmpz>::product() const
{
  auto result = Fmpz(1);

  for(const auto[base,exponent] : prime_factors) {
    result *= pow(base,exponent);
  }
  for(const auto[base,exponent] : other_factors) {
    result *= pow(base,exponent);
  }

  return result;
}

  template <typename T>
auto merge_factorization_vectors(
    const vector<tuple<T,int64_t>>& in_0,
    const vector<tuple<T,int64_t>>& in_1,
    function<auto(vector<tuple<T,int64_t>>&)> push_0,
    function<auto(vector<tuple<T,int64_t>>&)> push_1,
    function<int64_t(int64_t,int64_t)> combine)
{

  auto it_0 = in_0.begin();
  const auto end_0 = in_0.end();

  auto it_1 = in_1.begin();
  const auto end_1 = in_1.end();

  vector<tuple<T,int64_t>> result = {};

  while(it_0 < end_0 && it_1 < end_1) {
    const auto[number_0,exponent_0] = *it_0;
    const auto[number_1,exponent_1] = *it_1;

    if(number_0 < number_1) {
      result.push_back(push_0(*it_0));
      ++it_0;
    }
    else if(number_0 > number_1) {
      result.push_back(push_1(*it_1));
      ++it_1;
    }
    else {
      auto exponent = combine(exponent_0,exponent_1);
      if(exponent != 0) {
        result.push_back(push_0(tuple(number_0,exponent)));
      }
      ++it_0;
      ++it_1;
    }
  }

  // insert leftovers
  // at least one of these does nothing
  while(it_0 < end_0) {
    result.push_back(push_0(*it_0));
    ++it_0;
  }
  while(it_1 < end_1) {
    result.push_back(push_1(*it_1));
    ++it_1;
  }

  return result;
}

template <typename T>
vector<tuple<T,int64_t>> merge_factorization_vectors(
    const vector<tuple<T,int64_t>>& in_0,
    const vector<tuple<T,int64_t>>& in_1,
    function<auto(vector<tuple<T,int64_t>>&)> push_1,
    function<int64_t(int64_t,int64_t)> combine)
{ return merge_factorization_vectors(in_0,in_1,push_1,push_1,combine); }

  template <typename T>
vector<tuple<T,int64_t>> merge_factorization_vectors(
    const vector<tuple<T,int64_t>>& in_0,
    const vector<tuple<T,int64_t>>& in_1,
    function<auto(vector<tuple<T,int64_t>>&)> push_0,
    function<auto(vector<tuple<T,int64_t>>&)> push_1)
{ return merge_factorization_vectors(in_0,in_1,push_0,push_1,[](int64_t& a,int64_t& b){return a+b;}); }

  template <typename T>
vector<tuple<T,int64_t>> merge_factorization_vectors(
    const vector<tuple<T,int64_t>>& in_0,
    const vector<tuple<T,int64_t>>& in_1,
    function<auto(vector<tuple<T,int64_t>>&)> push_1)
{ return merge_factorization_vectors(in_0,in_1,push_1,push_1); }

  template <typename T>
vector<tuple<T,int64_t>> merge_factorization_vectors(
    const vector<tuple<T,int64_t>>& in_0,
    const vector<tuple<T,int64_t>>& in_1,
    function<int64_t(int64_t,int64_t)> combine)
{ return merge_factorization_vectors(in_0,in_1,[](vector<tuple<T,int64_t>>& in){return in;}, combine); }

  template <typename T>
vector<tuple<T,int64_t>> merge_factorization_vectors(
    const vector<tuple<T,int64_t>>& in_0,
    const vector<tuple<T,int64_t>>& in_1)
{ return merge_factorization_vectors(in_0,in_1,[](vector<tuple<T,int64_t>>& in){return in;}); }
