#!/usr/bin/sage

if __name__ == "__main__":

    """
    TODO: ultimately want to split up in two ways

    1. number of triples in a suit (and whether contains a double)
    2. number of triples in a connected block
    """

    n = 9
    t = 4

    # what could the effect of the first card be?

    final_states = []

    # n pairs, n triples, next index minimums

    # no cards at pos 0
    final_states.append([[0,0,0,0]])

    # 1 card at pos 0 => part of chow
    final_states.append([[0,1,1,1]])

    # 2 cards at pos 0 =>
    # (1) part of two chows
    # (2) part of a pair
    final_states.append([[0,2,2,2],[1,0,0,0]])

    # 3 cards at pos 0 =>
    # (1) part of a pung
    # (2) part of three chows (reduces to (1))
    # (3) part of a pair and a chow
    final_states.append([[0,1,0,0],[1,1,1,1]])

    # 4 cards at pos 0 ->
    # (1) part of a pung and a chow
    # (2) part of four chows (reduces to (1))
    # (3) part of a pair and two chows
    final_states.append([[0,2,1,1],[1,2,2,2]])

    states_0 = {}
    for state in final_states:
        states_0[str(state)] = 1


    curr_index = 1
    states_1 = {}

    for state_str in states_0:

        s = eval(state_str)

        num_states = len(s)

        # none in next tile group
        output_states_0 = []
        output_states_1 = []
        output_states_2 = []
        output_states_3 = []
        output_states_4 = []

        for state in s:

            if state[2] == 0:

                output_states_0.append([state[0],state[1],0,0])
                output_states_1.append([state[0],state[1]+1,1,1])
                output_states_2.append([state[0],state[1]+2,2,2])
                output_states_3.append([state[0],state[1]+1,0,0])
                output_states_4.append([state[0],state[1]+2,1,1])

                if state[0] == 0:
                    output_states_2.append([1,state[1],0,0])
                    output_states_3.append([1,state[1]+1,1,1])
                    output_states_4.append([1,state[1]+2,2,2])

            elif state[2] == 1:

                output_states_1.append([state[0],state[1],state[3],0])
                output_states_2.append([state[0],state[1]+1,state[3]+1,1])
                output_states_3.append([state[0],state[1]+2,state[3]+2,2])
                output_states_4.append([state[0],state[1]+1,state[3],0])

                if state[0] == 0:
                    output_states_3.append([1,state[1],state[3],0])
                    output_states_4.append([1,state[1]+1,state[3]+1,1])

            elif state[2] == 2:

                output_states_2.append([state[0],state[1],state[3],0])
                output_states_3.append([state[0],state[1]+1,state[3]+1,1])
                output_states_4.append([state[0],state[1]+2,state[3]+2,2])

                if state[0] == 0:
                    output_states_4.append([1,state[1],state[3],0])

            elif state[3] == 3:

                output_states_3.append([state[0],state[1],state[3],0])
                output_states_4.append([state[0],state[1]+1,state[3]+1,1])

            else: # state[3] == 4

                output_states_4.append([state[0],state[1],state[3],0])

        output_states_0.sort()
        output_str_0 = str(output_states_0)
        if output_str_0 not in states_1:

            states_1[output_str_0] = 1

        else:

            states_1[output_str_0] += 1

