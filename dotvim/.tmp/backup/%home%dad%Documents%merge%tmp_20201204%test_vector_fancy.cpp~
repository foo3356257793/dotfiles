#include "formal_sum.hpp"
#include "myflint_factor.hpp"
#include "myflint_poly.hpp"
#include "myflint_ZZ_mat.hpp"
#include "div_operator.hpp"
#include "myflint_RR_mat.hpp"

#include "yaml-cpp/yaml.h"

#include "myflint_lll.hpp"

#include <iomanip>
#include <iostream>
#include <string>
#include <type_traits>
#include <variant>
#include <vector>

#include <fstream>

#include <valarray>

// the variant to visit
using var_t = std::variant<ZZ, ZZ_poly>;
 
// helper constant for the visitor #3
template<class> inline constexpr bool always_false_v = false;

template<class... Ts> struct overloaded : Ts... { using Ts::operator()...; };
template<class... Ts> overloaded(Ts...) -> overloaded<Ts...>;

// testing
#include <gtest/gtest.h>

using Term = FormalSumTerm<int64_t,int64_t>;
using TermZZ = FormalSumTerm<ZZ,int64_t>;
using TermZZ_ZZ = FormalSumTerm<ZZ,ZZ>;

TEST(Tests, factorization) {

  auto foo = Factorization<int64_t>();

  foo.primes += Term(31,1);
  foo.composites += Term(94,-1);

  print("{}\n", foo);

  auto bar = Factorization<int64_t>();
  bar.composites += Term(94,1);
  bar.primes += Term(2,3);

  foo += bar;

  print("{}\n", foo);

  auto items = foo.sorted_items();

  ASSERT_EQ(items.size(), 2);
  ASSERT_EQ(items[0].value, 2);
  ASSERT_EQ(items[0].coeff, 3);
  ASSERT_EQ(items[1].value, 31);
  ASSERT_EQ(items[1].coeff, 1);

  foo *= 2;

  print("{}\n", foo);

  items = foo.sorted_items();

  ASSERT_EQ(items.size(), 2);
  ASSERT_EQ(items[0].value, 2);
  ASSERT_EQ(items[0].coeff, 6);
  ASSERT_EQ(items[1].value, 31);
  ASSERT_EQ(items[1].coeff, 2);

  foo *= 0;

  print("{} is zero? {}\n", foo, foo==0);

  ASSERT_EQ(foo,0);

  auto fooZZ = Factorization<ZZ>();

  fooZZ.primes += TermZZ(ZZ(31),1);
  fooZZ.composites += TermZZ(ZZ(94),-1);

  print("{}\n", fooZZ);

  auto items_ZZ = fooZZ.sorted_items();

  ASSERT_EQ(items_ZZ.size(), 2);
  ASSERT_EQ(items_ZZ[0].value, 31);
  ASSERT_EQ(items_ZZ[0].coeff, 1);
  ASSERT_EQ(items_ZZ[1].value, 94);
  ASSERT_EQ(items_ZZ[1].coeff, -1);

}

TEST(Tests, formal_sum) {

  auto foo = FormalSum<ZZ,ZZ>();

  foo += TermZZ_ZZ(10,3);
  foo += TermZZ_ZZ(70,-5);
  foo += TermZZ_ZZ(ZZ("123456789123456789"),-1);

  print("{}\n", foo);

  auto items = foo.sorted_items();

  ASSERT_EQ(items.size(), 3);
  ASSERT_EQ(items[0].value, 10);
  ASSERT_EQ(items[0].coeff, 3);
  ASSERT_EQ(items[1].value, 70);
  ASSERT_EQ(items[1].coeff, -5);
  ASSERT_EQ(items[2].value, ZZ("123456789123456789"));
  ASSERT_EQ(items[2].coeff, -1);

  print("minus foo: {}\n", -foo);

  items = (-foo).sorted_items();

  ASSERT_EQ(items.size(), 3);
  ASSERT_EQ(items[0].value, 10);
  ASSERT_EQ(items[0].coeff, -3);
  ASSERT_EQ(items[1].value, 70);
  ASSERT_EQ(items[1].coeff, 5);
  ASSERT_EQ(items[2].value, ZZ("123456789123456789"));
  ASSERT_EQ(items[2].coeff, 1);

  auto bar = FormalSum<ZZ,ZZ>();
  bar += TermZZ_ZZ(71,89);
  bar += TermZZ_ZZ(93,ZZ("90909090909090909090909090"));
  bar += TermZZ_ZZ(ZZ("37"),45);

  print("{}\n", bar);

  items = bar.sorted_items();

  ASSERT_EQ(items.size(), 3);
  ASSERT_EQ(items[0].value, 37);
  ASSERT_EQ(items[0].coeff, 45);
  ASSERT_EQ(items[1].value, 71);
  ASSERT_EQ(items[1].coeff, 89);
  ASSERT_EQ(items[2].value, 93);
  ASSERT_EQ(items[2].coeff, ZZ("90909090909090909090909090"));

  foo += move(bar);

  print("{}\n", foo);

  items = foo.sorted_items();

  ASSERT_EQ(items.size(), 6);
  ASSERT_EQ(items[0].value, 10);
  ASSERT_EQ(items[0].coeff, 3);
  ASSERT_EQ(items[1].value, 37);
  ASSERT_EQ(items[1].coeff, 45);
  ASSERT_EQ(items[2].value, 70);
  ASSERT_EQ(items[2].coeff, -5);
  ASSERT_EQ(items[3].value, 71);
  ASSERT_EQ(items[3].coeff, 89);
  ASSERT_EQ(items[4].value, 93);
  ASSERT_EQ(items[4].coeff, ZZ("90909090909090909090909090"));
  ASSERT_EQ(items[5].value, ZZ("123456789123456789"));
  ASSERT_EQ(items[5].coeff, -1);

  auto gobble = FormalSum<ZZ,ZZ>();
  gobble += TermZZ_ZZ(2,79);
  foo -= move(gobble);

  print("{}\n", foo);

  items = foo.sorted_items();

  ASSERT_EQ(items.size(), 7);
  ASSERT_EQ(items[0].value, 2);
  ASSERT_EQ(items[0].coeff, -79);
  ASSERT_EQ(items[1].value, 10);
  ASSERT_EQ(items[1].coeff, 3);
  ASSERT_EQ(items[2].value, 37);
  ASSERT_EQ(items[2].coeff, 45);
  ASSERT_EQ(items[3].value, 70);
  ASSERT_EQ(items[3].coeff, -5);
  ASSERT_EQ(items[4].value, 71);
  ASSERT_EQ(items[4].coeff, 89);
  ASSERT_EQ(items[5].value, 93);
  ASSERT_EQ(items[5].coeff, ZZ("90909090909090909090909090"));
  ASSERT_EQ(items[6].value, ZZ("123456789123456789"));
  ASSERT_EQ(items[6].coeff, -1);

}

TEST(Tests, factor) {

  auto foo = ZZ(2)*ZZ(3)*ZZ(5)*ZZ(7)*ZZ(11)*ZZ(11)*ZZ(13);

  print("foo = {}\n", foo);

  auto foo_factors = factor(foo);

  print("{}\n", foo_factors);

  auto items = foo_factors.sorted_items();

  ASSERT_EQ(items.size(), 6);
  ASSERT_EQ(items[0].value, 2);
  ASSERT_EQ(items[0].coeff, 1);
  ASSERT_EQ(items[1].value, 3);
  ASSERT_EQ(items[1].coeff, 1);
  ASSERT_EQ(items[2].value, 5);
  ASSERT_EQ(items[2].coeff, 1);
  ASSERT_EQ(items[3].value, 7);
  ASSERT_EQ(items[3].coeff, 1);
  ASSERT_EQ(items[4].value, 11);
  ASSERT_EQ(items[4].coeff, 2);
  ASSERT_EQ(items[5].value, 13);
  ASSERT_EQ(items[5].coeff, 1);

  auto bar = ZZ("48222648924224528332090922912037930609472797631248617");

  auto bar_factors = factor(bar, (FactorParams) {.bits=30});

  print("{}\n", bar_factors);

  print("primes:\n{}\n", bar_factors.primes);
  print("composites:\n{}\n", bar_factors.composites);

  auto check = ZZ(1);
  for(auto &term : bar_factors.primes.items()){
    ASSERT_TRUE(is_prime(term.value));
    check *= term.value^term.coeff;
  }
  for(auto &term : bar_factors.composites.items()){
    ASSERT_TRUE(!is_prime(term.value));
    check *= term.value^term.coeff;
  }

  ASSERT_EQ(check, bar);

}

TEST(Tests, coprime) {

  auto bar = Factorization<ZZ>();

  bar.composites += TermZZ((2*2*2*3*3*5*7),1);
  bar.composites += TermZZ((2*3*3*5*5*5*7*7),1);

  print("start  = {}\n", bar);

  auto starting_prod = ZZ(1);
  for(auto &term : bar.primes.items()){
    starting_prod *= pow(term.value,term.coeff);
  }
  for(auto &term : bar.composites.items()){
    starting_prod *= pow(term.value,term.coeff);
  }

  bar.make_factors_coprime();

  auto ending_prod = ZZ(1);
  for(auto &term : bar.primes.items()){
    ASSERT_TRUE(is_prime(term.value));
    ending_prod *= pow(term.value,term.coeff);
  }
  for(auto &term : bar.composites.items()){
    ASSERT_TRUE(!is_prime(term.value));
    ending_prod *= pow(term.value,term.coeff);
  }

  print("result = {}\n", bar);

  print("primes:\n{}\n", bar.primes);
  print("composites:\n{}\n", bar.composites);

  ASSERT_EQ(starting_prod, ending_prod);

}

TEST(Tests, poly) {

  vector<ZZ> coeffs = {ZZ(1),ZZ(2),ZZ(3)};

  auto poly = ZZ_poly(coeffs);

  print("poly:\n{}\n", poly);

  ASSERT_EQ(poly.degree(), 2);

  ASSERT_EQ(poly[0],1);
  ASSERT_EQ(poly[1],2);
  ASSERT_EQ(poly[2],3);

  poly[0] += 5;

  print("now poly is: {}\n", poly);

  ASSERT_EQ(poly[0],6);

  ZZ coeff_sum = poly[0];
  for(auto index=1; index<=poly.degree(); index++){
    coeff_sum += poly[index];
  }

  print("sum of coefficients = {}\n", coeff_sum);

  ASSERT_EQ(coeff_sum, 1+2+3+5);

}

variant<ZZ, ZZ_poly> foo(int64_t a){
  if (a & 1){
    return ZZ(a);
  }
  else{
    return ZZ_poly({ZZ(a),ZZ(1)});
  }
}

TEST(Tests, variant) {

  auto val_0 = foo(10);
  auto val_1 = foo(11);

  auto vec = vector<variant<ZZ,ZZ_poly>>();
  vec.push_back(val_0);
  vec.push_back(val_1);

  print("here!\n");

  for(auto &val : vec){
    if(holds_alternative<ZZ>(val)){
      print("This is a ZZ: {}\n", get<ZZ>(val));
    }
    else{
      print("This is a ZZ_poly: {}\n", get<ZZ_poly>(val));
    }
  }

  for(auto &val : vec){
    try{
      print("This is a ZZ: {}\n", get<ZZ>(val));
    }
    catch(bad_variant_access const& ex){
      print("This is a ZZ_poly: {}\n", get<ZZ_poly>(val));
    }
  }

}

template <typename T>
string repr(const T& a){
  stringstream ss;
  ss << a;
  return ss.str();
}

YAML::Emitter& operator << (YAML::Emitter& out, const ZZ_mat& m){

  out << YAML::BeginSeq;
  for(auto row=0; row<m.nrows(); row++){
    out << YAML::BeginSeq;
    for(auto col=0; col<m.ncols(); col++){
      char *out_string = fmpz_get_str(NULL, 10, m(row,col));
      out << out_string;
      free(out_string);
    }
    out << YAML::EndSeq;
  }
  out << YAML::EndSeq;

  return out;
}

optional<vector<ZZ_mat>> read_yaml_file(string fname){

  YAML::Node node;
  try {
    node = YAML::LoadFile(fname);
  } catch (exception &e) {
    cout << "Error parsing file!" << endl;
    cout << e.what() << endl;

    cout << endl;
    return nullopt;
  }

  assert(node.IsSequence());

  auto result = vector<ZZ_mat>();

  for(size_t index=0; index<node.size(); index++){
    auto mat_as_vecs = node[index].as<vector<vector<string>>>();
    result.push_back(ZZ_mat(mat_as_vecs));
  }

  return result;

}


TEST(Tests, yaml) {

  auto a = ZZ("123456789123456789");

  auto num_trials = 8;

  auto vec = vector<ZZ_mat>();

  YAML::Emitter out;

  out << YAML::BeginSeq;

  for(auto trial=0; trial<num_trials; trial++){
    auto mat = ZZ_mat(3,3);
    for(auto row=0; row<3; row++){
      for(auto col=0; col<3; col++){
        mat[row][col] = a;
        a.next_prime();
      }
    }
    out << mat;
    vec.push_back(mat);
  }

  out << YAML::EndSeq;

  ofstream myfile;
  string fname = "example.yaml";
  myfile.open(fname);

  myfile << out.c_str();

  myfile.close();

  auto maybe_matching_vec = read_yaml_file(fname);

  ASSERT_TRUE(maybe_matching_vec.has_value());

  auto matching_vec = maybe_matching_vec.value();

  ASSERT_EQ(vec.size(),matching_vec.size());
  for(auto index=0; index<vec.size(); index++){
    ASSERT_EQ(vec[index],matching_vec[index]);
  }

}

ZZ_mat check_cob(const ZZ_mat &orig_mat, const ZZ_mat &new_mat){

  auto orig_transpose = transpose(orig_mat);
  auto new_transpose = transpose(new_mat);
  auto result = ZZ_mat(orig_mat.nrows(), orig_mat.ncols());
  auto den = ZZ();

  int success = fmpz_mat_solve(result.data, (fmpz *) den, orig_transpose.data, new_transpose.data);

  EXPECT_EQ(success,1);

  // could have a non-trivial denominator
  for(auto row=0; row<result.nrows(); row++){
    for(auto col=0; col<result.ncols(); col++){
      EXPECT_TRUE(fmpz_divisible((const fmpz *)result[row][col],(const fmpz*) den));
      fmpz_divexact((fmpz*) result[row][col],(fmpz*) result[row][col],(const fmpz*) den);
    }
  }

  auto det = determinant(result);
  det = abs(det);

  EXPECT_EQ(det,1);

  return result;

}

TEST(Tests, LLL) {

  auto a = ZZ("123456789123456789");

  auto mat = ZZ_mat(3,3);
  for(auto row=0; row<3; row++){
    for(auto col=0; col<3; col++){
      mat[row][col] = a;
      a.next_prime();
    }
  }

  auto copy = mat;

  LLL_inplace(mat);

  // check that these are related by unimodular cob
  auto cob = check_cob(copy,mat);

  print("{}\n", cob);

}

TEST(Tests, mat) {

  auto mat = ZZ_mat(3,3);

  mat[0][0] = 16;
  for(int row=1; row<3; row++){
    mat[row][0] = 3*row;
    mat[row][row] = 1;
  }

  print("Here is the mat:\n{}\n", mat);

  ASSERT_EQ(mat.nrows(),3);
  ASSERT_EQ(mat[0][0], 16);
  ASSERT_EQ(mat[0][1], 0);
  ASSERT_EQ(mat[0][2], 0);
  ASSERT_EQ(mat[1][0], 3);
  ASSERT_EQ(mat[1][1], 1);
  ASSERT_EQ(mat[1][2], 0);
  ASSERT_EQ(mat[2][0], 6);
  ASSERT_EQ(mat[2][1], 0);
  ASSERT_EQ(mat[2][2], 1);

  auto red_mat = LLL(mat);

  print("reduced:\n{}\n", mat);

  // check that these are related by unimodular cob
  auto cob = check_cob(mat,red_mat);

  print("{}\n", cob);
}

TEST(Tests, div) {

  auto a = ZZ(12);
  auto b = ZZ(4);

  auto c = a รท b;

  print("c = {}\n", c);
  ASSERT_EQ(c,3);

  c รท= 3;

  print("c = {}\n", c);
  ASSERT_EQ(c,1);

}

TEST(Tests, mat_as_vecs) {
  vector<vector<int64_t>> a = {{7,0},{-3,1}};
  vector<vector<string>> b = {{"123456789123456789","0"},{"-3333333333333333","1"}};
  vector<vector<ZZ>> c = {{ZZ("987654321987654321"),0},{7,1}};

  auto A = ZZ_mat(a);
  auto B = ZZ_mat(b);
  auto C = ZZ_mat(c);

  print("A = {}\n", A);
  print("B = {}\n", B);
  print("C = {}\n", C);

  LLL_inplace(B);

  fmpz_mat_gram((fmpz_mat_struct*) C, (const fmpz_mat_struct*) B);

  //print("A ->\n{}\n", A);
  print("B ->\n{}\n", B);
  print("C ->\n{}\n", C);

}

TEST(Tests, RR_mat) {
  //vector<vector<string>> a = {{"123456789123456789","0"},{"-3333333333333333","1"}};

  auto p = ZZ("123456789123456823");
  auto dim = 8;

  auto A = ZZ_mat(dim,dim);
  A[0][0] = p;

  auto B = ZZ("234567891234567891");
  auto C = ZZ("111111111111111111");

  for(auto row=1; row<dim; row++){
    A[row][0] = B * A[row-1][0] + C;
    A[row][0] %= p;
    A[row][row] = 1;
  }

  LLL_inplace(A);

  auto[L,Q] = LQ(A);

  print("A = {}\n", A);
  print("L = {}\n", L);
  print("Q = {}\n", Q);

}

TEST(Tests, vector_arithmetic) {

  valarray<double> a = {1,2,3};
  valarray<double> b = {1,-1,0};

  valarray<double> c = a+b;

  //print("[{}]\n", fmt::join(a,", "));
  //print("[{}]\n", fmt::join(b,", "));
  //print("[{}]\n", fmt::join(c,", "));

  print("[");
  for(auto &v : a){
    print("{}, ", v);
  }
  print("]\n");
  print("[");
  for(auto &v : b){
    print("{}, ", v);
  }
  print("]\n");
  print("[");
  for(auto &v : c){
    print("{}, ", v);
  }
  print("]\n");

}

int main(int argc, char *argv[]){

  ::testing::InitGoogleTest(&argc, argv);
  return RUN_ALL_TESTS();

}
