#include <iostream>
using std::cout;
using std::endl;

// flint for primes
#include <ulong_extras.h>

#include <vector>
using std::vector;

#if 0
#include <algorithm>
using std::find;
using std::distance;

const int d_max = 999;

int find_recurring_cycle(int n)
{

  vector<int> remainders = {1};

  int r = 1;
  while(1)
  {
    r = (10*r) % n;
    auto it = find(remainders.begin(), remainders.end(), r);
    if(it == remainders.end())
    {
      remainders.push_back(r);
    }
    else
    {
      return distance(it, remainders.end());
    }
  }


}
#endif

// is there a way to do this with the library as is?
vector<int> prime_range(int start, int end)
{

  // use flint library to setup prime stuff
  n_primes_t iter;
  n_primes_init(iter);

  vector<int> primes;

  int p = start-1;
  p = n_primes_next(iter);

  while(p < end)
  {
    primes.push_back(p);
    p = n_primes_next(iter);
  }

  n_primes_clear(iter);

  return primes;

}

void prob_27()
{

  const int BOUND = 1000;

  const vector<int> b_values = prime_range(0,BOUND);

  vector<int> good_pairs;

  int a_start = -BOUND+1;
  if(a_start % 2 == 0)
  {
    a_start += 1;
  }

  int a_end = BOUND-1;

  int max_length = 0;
  int arg_max;

  for(int b : b_values)
  {
    for(int a=a_start; a<=a_end; a+=2)
    {
      for(int s=-1; s<=1; s+=2)
      {

        // this is a lambda function
        // in Sage I used a polynomial object
        auto polynomial = [a,s,b](int i){return i*i + a*i + s*b;};

        int i=1;
        while(1)
        {
          int eval = polynomial(i);

          if(eval < 0)
          {
            eval = -eval;
          }

          if(!n_is_prime(eval))
          {
            break;
          }
          i += 1;
        }

        if(i > max_length)
        {
          max_length = i;
          arg_max = a*s*b;
        }
      }
    }
  }

  cout << arg_max << endl;


}

int main(int argc, char *argv[])
{

  prob_27();

}

