#include <algorithm>
#include <iostream>
#include <memory>
#include <numeric>
#include <tuple>
#include <vector>

//using namespace std;
using std::vector;
using std::ostream;
using std::string;
using std::tuple;
using std::make_tuple;
using std::invalid_argument;
//using std::insert;

// testing
#include <gtest/gtest.h>

// fmt
#include <fmt/core.h>
#include <fmt/ostream.h>

using fmt::print;

// flint
#include <flint/flint.h>
#include <flint/fmpzxx.h>
#include <flint/fmpqxx.h>

using flint::fmpzxx;
using flint::fmpqxx;
//using flint::fmpz_factorxx;

// easy printing of vectors
template <typename T>
std::ostream& operator<< (std::ostream& out, const std::vector<T>& v) {
  if ( !v.empty() ) {
    out << '[';
    std::copy (v.begin(), v.end(), std::ostream_iterator<T>(out, ", "));
    out << "\b\b]";
  }
  return out;
}

vector<tuple<fmpzxx,int64_t>> factor_and_parse(const fmpzxx &number)
{

  if(number == 0)
  {
    throw invalid_argument("factoring 0 not defined.");
  }

  if(number == 1 || number == -1) return {};

  auto factorization = factor(number);

  auto num_factors = factorization.size();

  vector<tuple<fmpzxx,int64_t>> result = {};

  // TODO: double check that everything is a factor
  // of the input
  // see if there is stuff left over

  for(slong index=0; index<num_factors; index++)
  {
    auto base = factorization.p(index);
    auto exponent = factorization.exp(index);

    result.push_back(make_tuple(fmpzxx(base),exponent));
  }

  return result;
}

vector<tuple<fmpzxx,int64_t>> merge_factorization_vectors(
    vector<tuple<fmpzxx,int64_t>> in_0,
    vector<tuple<fmpzxx,int64_t>> in_1)
{
  auto it_0 = in_0.begin();
  const auto end_0 = in_0.end();

  auto it_1 = in_1.begin();
  const auto end_1 = in_1.end();

  vector<tuple<fmpzxx,int64_t>> result = {};

  while(it_0 < end_0 && it_1 < end_1)
  {
    const auto[number_0,exponent_0] = *it_0;
    const auto[number_1,exponent_1] = *it_1;

    if(number_0 < number_1)
    {
      result.insert(result.end(), it_0, it_0+1);
      ++it_0;
    }
    else if(number_0 > number_1)
    {
      result.insert(result.end(), it_1, it_1+1);
      ++it_1;
    }
    else
    {
      auto exponent = exponent_0 + exponent_1;
      if(exponent != 0)
      {
        result.push_back(make_tuple(number_0,exponent));
      }
      ++it_0;
      ++it_1;
    }
  }

  // insert leftovers
  // at least one of these does nothing
  result.insert(result.end(), it_0, end_0);
  result.insert(result.end(), it_1, end_1);

  return result;

}
vector<tuple<fmpzxx,int64_t>> merge_divide_factorization_vectors(
    vector<tuple<fmpzxx,int64_t>> in_0,
    vector<tuple<fmpzxx,int64_t>> in_1)
{
  auto it_0 = in_0.begin();
  const auto end_0 = in_0.end();

  auto it_1 = in_1.begin();
  const auto end_1 = in_1.end();

  vector<tuple<fmpzxx,int64_t>> result = {};

  while(it_0 < end_0 && it_1 < end_1)
  {
    const auto[number_0,exponent_0] = *it_0;
    const auto[number_1,exponent_1] = *it_1;

    if(number_0 < number_1)
    {
      result.insert(result.end(), it_0, it_0+1);
      ++it_0;
    }
    else if(number_0 > number_1)
    {
      result.push_back(make_tuple(number_1,-exponent_1));
      ++it_1;
    }
    else
    {
      auto exponent = exponent_0 - exponent_1;
      if(exponent != 0)
      {
        result.push_back(make_tuple(number_0,exponent));
      }
      ++it_0;
      ++it_1;
    }
  }

  // insert leftovers
  // at least one of these does nothing
  result.insert(result.end(), it_0, end_0);

  while(it_1 < end_1)
  {
    const auto[number_1,exponent_1] = *it_1;
    result.push_back(make_tuple(number_1,-exponent_1));
    ++it_1;
  }

  return result;

}

vector<tuple<fmpzxx,int64_t>> pow_factorization_vector(
    vector<tuple<fmpzxx,int64_t>> in,
    int64_t exponent)
{
  if(exponent==1) return in;

  vector<tuple<fmpzxx,int64_t>> result = {};

  for(auto &tup : in)
  {
    auto[base, orig_exponent] = tup;
    result.push_back(make_tuple(base, orig_exponent * exponent));
  }

  return result;

}


fmpqxx product_factors(vector<tuple<fmpzxx,int64_t>> in_factors)
{
  fmpqxx result;
  result.set_one();

  for(auto &tup : in_factors)
  {
    auto[base, exponent] = tup;

    // TODO: can I define this conversion from fmpzxx to fmpqxx?
    fmpqxx base_q;
    base_q.set_integer(base);

    result *= pow(base_q, exponent);
  }

  return result;
}

// call flint's factor and put everything into a vector
vector<tuple<fmpzxx,int64_t>> factor_and_parse(const fmpqxx &number)
{

  auto numer_factors = factor_and_parse(fmpzxx(number.num()));
  auto denom_factors = factor_and_parse(fmpzxx(number.den()));

  auto result = merge_divide_factorization_vectors(numer_factors, denom_factors);

  return result;
}

vector<tuple<fmpzxx,int64_t>> parse_but_dont_process(const fmpqxx &number)
{
  auto num = fmpzxx(number.num());
  if(num < 0) num = -num;

  auto den = fmpzxx(number.den());
  if(den < 0) den = -den;

  vector<tuple<fmpzxx,int64_t>> result = {};

  if(num != 1)
  {
    result.push_back(make_tuple(num, 1));
  }
  if(den != 1)
  {
    result.push_back(make_tuple(den, -1));
  }

  return result;
}

class Factorization {
  public:
    fmpqxx number;
    vector<tuple<fmpzxx,int64_t>> factors;
    vector<tuple<fmpzxx,int64_t>> unprocessed_factors;

    Factorization() {}

    Factorization(int64_t in_number)
    {
      if(in_number == 0)
      {
        throw invalid_argument("Factorization of 0 not defined.");
      }

      number.set_integer(in_number);

      //factors = factor_and_parse(number);
      factors = {};
      unprocessed_factors = parse_but_dont_process(number);

    }

    Factorization(int64_t in_num, int64_t in_den)
    {

      if(in_den == 0)
      {
        throw invalid_argument("Can't use 0 as denominator.");
      }

      number = fmpqxx::frac(in_num, in_den);

      //factors = factor_and_parse(number);
      factors = {};
      unprocessed_factors = parse_but_dont_process(number);
    }

    Factorization(fmpzxx in_number)
    {
      number.set_integer(in_number);

      //factors = factor_and_parse(number);
      factors = {};
      unprocessed_factors = parse_but_dont_process(number);
    }

    Factorization(fmpqxx in_number)
    {
      number = in_number;

      //factors = factor_and_parse(number);
      factors = {};
      unprocessed_factors = parse_but_dont_process(number);
    }

    Factorization(vector<tuple<fmpzxx,int64_t>> in_factors)
    {
      number = product_factors(in_factors);
      factors = in_factors;
      unprocessed_factors = {};
    }

    Factorization(vector<tuple<fmpzxx,int64_t>> in_factors,
                  vector<tuple<fmpzxx,int64_t>> in_unprocessed_factors)
    {
      number = product_factors(in_factors);
      factors = in_factors;
      unprocessed_factors = in_unprocessed_factors;
    }

    Factorization& operator*=(const Factorization &rhs)
    {

      number *= rhs.number;
      factors = merge_factorization_vectors(factors,rhs.factors);
      unprocessed_factors = merge_factorization_vectors(unprocessed_factors,rhs.unprocessed_factors);

      return *this;
    }

    Factorization& operator/=(const Factorization &rhs)
    {

      number /= rhs.number;
      factors = merge_divide_factorization_vectors(factors,rhs.factors);
      unprocessed_factors = merge_divide_factorization_vectors(unprocessed_factors,rhs.unprocessed_factors);

      return *this;
    }

    // TODO list
    // 2. Lazy factorization
    // 4. More types of objects other than integers/rationals

    void factor()
    {
      for(auto &tup : unprocessed_factors)
      {
        auto[base, exponent] = tup;

        auto processed_factors = factor_and_parse(base);

        processed_factors = pow_factorization_vector(processed_factors, exponent);

        factors = merge_factorization_vectors(factors, processed_factors);
      }

      unprocessed_factors = {};
    }
};

fmpqxx product_factors(Factorization in)
{
  auto result = product_factors(in.factors);
  result *= product_factors(in.unprocessed_factors);

  return result;
}


Factorization operator*(Factorization lhs, const Factorization &rhs)
{
  return lhs *= rhs;
}

Factorization operator/(Factorization lhs, const Factorization &rhs)
{
  return lhs /= rhs;
}

// easy printing of Factorization objects
ostream& operator<<(ostream& os, const Factorization& factors)
{
  os << "(Factorization of " << factors.number << " = ";

  if((factors.factors.size() + factors.unprocessed_factors.size()) == 0)
  {
    os << "1)";
    return os;
  }

  bool include_times = false;
  for(auto &tup : factors.factors)
  {
    auto[base, exponent] = tup;

    if(exponent == 0) continue;

    if(include_times)
    {
      os << " * ";
    }
    include_times = true;

    os << base;

    if(exponent != 1)
    {
      os << "^" << exponent;
    }
  }
  for(auto &tup : factors.unprocessed_factors)
  {
    auto[base, exponent] = tup;

    if(exponent == 0) continue;

    if(include_times)
    {
      os << " * ";
    }
    include_times = true;

    os << base;

    if(exponent != 1)
    {
      os << "^" << exponent;
    }
  }

  os << ")";

  return os;
}

// *****************************
// TESTS
// *****************************

TEST(Tests, TestFactorization) {

  int64_t a = 2*3*5*7;

  auto A = Factorization(a);

  EXPECT_EQ(A.number, a);

  auto a_from_factors = product_factors(A);

  EXPECT_EQ(a,a_from_factors);
}

TEST(Tests, TestPrintFactorization) {

  int64_t a = 2*3*5*7;

  auto factors_a = Factorization(a);
  factors_a.factor();

  print("{}\n", factors_a);

  int64_t b = 12;

  auto factors_a_over_b = Factorization(a,b);
  factors_a_over_b.factor();

  print("{}\n", factors_a_over_b);

}

TEST(Tests, TestMergeFactorization) {

  auto a = fmpzxx(4*27*5*7);
  auto b = fmpzxx(12);

  auto factors_a = factor_and_parse(a);
  auto factors_b = factor_and_parse(b);
  auto merged = merge_factorization_vectors(factors_a, factors_b);

  auto A = Factorization(a);
  A.factor();

  auto B = Factorization(b);
  B.factor();

  auto c = fmpzxx(a*b);
  auto C = Factorization(c);
  C.factor();

  EXPECT_EQ(merged, C.factors);
}

TEST(Tests, TestFactorAndParse) {

  auto a = fmpzxx(4*27*5*7);

  auto A = Factorization(a);

  print("{}\n", A);

  int64_t b = 1;
  auto B = Factorization(b);

  print("{}\n", B);

}

TEST(Tests, TestZeroFails) {

  Factorization A;
  try {
    A = Factorization(0);
    FAIL() << "Expected an error";
  }
  catch (invalid_argument & err)
  {
    print("{}\n", err.what());
    EXPECT_EQ(err.what(), string("Factorization of 0 not defined."));
  }
}

TEST(Tests, TestMultiplication) {

  auto a = fmpzxx(4*27*5*7);
  auto b = fmpzxx(22);

  auto A = Factorization(a);
  A.factor();
  auto B = Factorization(b);
  B.factor();

  auto C = A*B;

  print("{} * {} = {}\n", A, B, C);

  EXPECT_EQ(A.number * B.number, C.number);

  auto merged = merge_factorization_vectors(A.factors, B.factors);

  EXPECT_EQ(merged, C.factors);
}

TEST(Tests, TestDivision) {

  auto a = fmpzxx(4*27*5*7);
  auto b = fmpzxx(22);

  auto A = Factorization(a);
  A.factor();

  auto B = Factorization(b);
  B.factor();

  auto C = A/B;

  print("{} / {} = {}\n", A, B, C);

  EXPECT_EQ(A.number / B.number, C.number);

  auto merged = merge_divide_factorization_vectors(A.factors, B.factors);

  EXPECT_EQ(merged, C.factors);
}


// *****************************
// Main: run tests
// *****************************

int main(int argc, char *argv[]) {

  ::testing::InitGoogleTest(&argc, argv);
  return RUN_ALL_TESTS();
}

