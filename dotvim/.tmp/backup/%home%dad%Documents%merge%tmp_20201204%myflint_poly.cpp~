#include "myflint_poly.hpp"

ZZ_poly::ZZ_poly() { fmpz_poly_init(data); }

ZZ_poly::ZZ_poly(const int64_t &degree) {

  if(degree <0) throw invalid_argument("Negative degree undefined");
  fmpz_poly_init2(data, degree+1);
}

ZZ_poly::ZZ_poly(const fmpz_poly_t &in_poly) : ZZ_poly(){
  fmpz_poly_set(data, in_poly);
}

ZZ_poly::ZZ_poly(const vector<ZZ> &coeffs) : ZZ_poly() {
  slong index=0;
  for(auto &coeff : coeffs){
    fmpz_poly_set_coeff_fmpz(data,index++,(const fmpz*) coeff);
  }
}

ZZ_poly::ZZ_poly(const ZZ_poly &other) {
  fmpz_poly_set(data,other.data);
} // copy constructor

ZZ_poly::ZZ_poly(ZZ_poly &&other) noexcept : ZZ_poly() { // move constructor
  fmpz_poly_swap(data, other.data);
}

ZZ_poly &ZZ_poly::operator=(const ZZ_poly &other) { // copy assignment
  fmpz_poly_set(data, other.data);
  return *this;
}

ZZ_poly &ZZ_poly::operator=(ZZ_poly &&other) noexcept { // move assignment
  fmpz_poly_swap(data, other.data);
  return *this;
}

ZZ_poly::~ZZ_poly() { // destructor
  fmpz_poly_clear(data);
}

slong ZZ_poly::degree() const { return fmpz_poly_degree(data); }

ZZ_ptr ZZ_poly::operator[](slong index) const {
  if(index<0 || index>degree()){
    throw invalid_argument("Out of bounds coefficient access");
  }
  return fmpz_poly_get_coeff_ptr(data,index);
}

#if 0
ZZ_poly &ZZ_poly::apply_fmpz_poly_fun_eq(const ZZ_poly &rhs,
    const function<void(fmpz_poly_t, fmpz_poly_t, const fmpz_poly_t)>& fun) {
  fun(data, data, rhs.data);
  return *this;
}

ZZ_poly &ZZ_poly::apply_fmpz_poly_fun_eq(const ZZ &rhs,
    const function<void(fmpz_poly_t, fmpz_poly_t, const fmpz_t)>& fun) {
  fun(data, data, (const fmpz*) rhs);
  return *this;
}

ZZ_poly &ZZ_poly::apply_fmpz_poly_fun_eq(const function<void(fmpz_poly_t, fmpz_poly_t)>& fun) {
  fun(data, data);
  return *this;
}

ZZ_poly ZZ_poly::apply_fmpz_poly_fun(
    const ZZ_poly &rhs,
    const function<void(fmpz_poly_t, const fmpz_poly_t, const fmpz_poly_t)>& fun) const {
  auto result = ZZ_poly();
  fun(result.data, data, rhs.data);
  return result;
}

ZZ_poly ZZ_poly::apply_fmpz_poly_fun(
    const ZZ&rhs,
    const function<void(fmpz_poly_t, const fmpz_poly_t, const fmpz_t)>& fun) const {
  auto result = ZZ_poly();
  fun(result.data, data, (const fmpz*) rhs);
  return result;
}

ZZ_poly ZZ_poly::apply_fmpz_poly_fun(function<void(fmpz_poly_t, const fmpz_poly_t)> fun) const {
  auto result = ZZ_poly();
  fun(result.data, data);
  return result;
}


ZZ_poly &ZZ_poly::operator+=(const ZZ_poly &rhs) { return apply_fmpz_poly_fun_eq(rhs, fmpz_poly_add); }
ZZ_poly ZZ_poly::operator+(const ZZ_poly &rhs) const { return apply_fmpz_poly_fun(rhs, fmpz_poly_add); }
ZZ_poly &ZZ_poly::operator-=(const ZZ_poly &rhs) { return apply_fmpz_poly_fun_eq(rhs, fmpz_poly_sub); }
ZZ_poly ZZ_poly::operator-(const ZZ_poly &rhs) const { return apply_fmpz_poly_fun(rhs, fmpz_poly_sub); }
ZZ_poly &ZZ_poly::operator*=(const ZZ_poly &rhs) { return apply_fmpz_poly_fun_eq(rhs, fmpz_poly_mul); }
ZZ_poly ZZ_poly::operator*(const ZZ_poly &rhs) const { return apply_fmpz_poly_fun(rhs, fmpz_poly_mul); }
ZZ_poly &ZZ_poly::operator%=(const ZZ &rhs) { return apply_fmpz_poly_fun_eq(rhs, fmpz_poly_scalar_mod_fmpz); }
ZZ_poly ZZ_poly::operator%(const ZZ &rhs) const { return apply_fmpz_poly_fun(rhs, fmpz_poly_scalar_mod_fmpz); }
ZZ_poly &ZZ_poly::operator/=(const ZZ &rhs) {
  return apply_fmpz_poly_fun_eq(rhs, fmpz_poly_scalar_divexact_fmpz);
}
ZZ_poly ZZ_poly::operator/(const ZZ &rhs) const {
  return apply_fmpz_poly_fun(rhs, fmpz_poly_scalar_divexact_fmpz);
}
ZZ_poly& ZZ_poly::operator-() { return apply_fmpz_poly_fun_eq(fmpz_poly_neg); }
ZZ_poly ZZ_poly::operator-() const { return apply_fmpz_poly_fun(fmpz_poly_neg); }


bool ZZ_poly::operator==(const ZZ_poly &rhs) const {
  return (fmpz_poly_equal(data,rhs.data) != 0);
}
bool ZZ_poly::operator!=(const ZZ_poly &rhs) const {
  return (fmpz_poly_equal(data,rhs.data) == 0);
}
bool ZZ_poly::operator>(const ZZ_poly &rhs) const {
  if(degree() != rhs.degree()) return degree() > rhs.degree();
  return (fmpz_cmp(fmpz_poly_lead(data), fmpz_poly_lead(rhs.data)) > 0);
}

bool ZZ_poly::operator>=(const ZZ_poly &rhs) const {
  if(degree() != rhs.degree()) return degree() >= rhs.degree();
  return (fmpz_cmp(fmpz_poly_lead(data), fmpz_poly_lead(rhs.data)) >= 0);
}
bool ZZ_poly::operator<=(const ZZ_poly &rhs) const {
  if(degree() != rhs.degree()) return degree() <= rhs.degree();
  return (fmpz_cmp(fmpz_poly_lead(data), fmpz_poly_lead(rhs.data)) <= 0);
}
bool ZZ_poly::operator<(const ZZ_poly &rhs) const {
  if(degree() != rhs.degree()) return degree() < rhs.degree();
  return (fmpz_cmp(fmpz_poly_lead(data), fmpz_poly_lead(rhs.data)) < 0);
}
#endif

ostream &operator<<(ostream &os, const ZZ_poly &f) {

  char *out_string = fmpz_poly_get_str_pretty(f.data, "x");
  os << out_string;
  free(out_string);

  return os;
}
