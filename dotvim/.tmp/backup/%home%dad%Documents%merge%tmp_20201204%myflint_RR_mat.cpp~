#include "myflint_RR_mat.hpp"

using namespace std;

#include <fmt/core.h>
#include <fmt/ostream.h>

using fmt::print;
using fmt::format;

slong RR_mat::nrows() const { return ((const d_mat_struct*) (*this))->r; }
slong RR_mat::ncols() const { return ((const d_mat_struct*) (*this))->c; }

RR_vec_ptr RR_mat::operator[](const int row) const {
  return ((const d_mat_struct*) (*this))->rows[row];
}

RR_mat::RR_mat(int nrows, int ncols) {
  d_mat_init((d_mat_struct*) (*this),nrows,ncols);
}

RR_mat::RR_mat() : RR_mat(0,0) {};

RR_mat::RR_mat(const ZZ_mat& other) : RR_mat(other.nrows(),other.ncols()) {
  fmpz_mat_get_d_mat((d_mat_struct*) (*this),(const fmpz_mat_struct*) other);
}

RR_mat::RR_mat(const RR_mat& other) : RR_mat(other.nrows(),other.ncols()) {
 // copy constructor
  d_mat_set((d_mat_struct*) (*this),(const d_mat_struct*) other);
}

RR_mat::RR_mat(RR_mat &&other) noexcept : RR_mat() { // move constructor
  swap(data, other.data);
}

bool RR_mat::dim_match(const RR_mat &other) {
  return ((nrows() == other.nrows()) && (ncols() == other.ncols()));
}

RR_mat& RR_mat::operator=(const RR_mat &other) { // copy assignment
  if(!dim_match(other))
  {
    // clear and reallocate
    d_mat_clear((d_mat_struct*) (*this));
    d_mat_init((d_mat_struct*) (*this),other.nrows(),other.ncols());
    d_mat_set((d_mat_struct*) (*this),(const d_mat_struct*) other);
    return *this;
  }

  d_mat_set((d_mat_struct*) (*this),(const d_mat_struct*) other);
  return *this;
}

RR_mat &RR_mat::operator=(RR_mat &&other) noexcept { // move assignment
  swap(data, other.data);
  return *this;
}

RR_mat::~RR_mat() { // destructor
  d_mat_clear((d_mat_struct*) (*this));
}

vector<vector<string>> RR_mat::to_string_vectors() const
{
  auto result = vector<vector<string>>();

  for(int row=0; row<nrows(); row++) {
    auto row_vec = vector<string>();
    for(int col=0; col<ncols(); col++) {
      stringstream ss;
      ss << *((double *) (*this)[row][col]);
      row_vec.push_back(ss.str());
    }
    result.push_back(row_vec);
  }

  return result;
}

ostream& operator<<(ostream& os, const RR_mat& f) {
  if(f.nrows() == 0) {
    os << "[]";
    return os;
  }

  const auto string_vectors = f.to_string_vectors();
  const auto widths = column_widths(string_vectors);
  const auto nrows = f.nrows();
  const auto ncols = f.ncols();

  os << "[" << endl;
  for(int row=0; row<nrows; row++) {
    os << "  [";
    for(int col=0; col<ncols; col++) {
      os << setw(widths[col]);
      os << string_vectors[row][col];
      if(col != ncols-1) os << ", ";
    }
    os << "]";
    if (row != nrows-1) os << ",";
    os << endl;
  }
  os << "]";

  return os;
}

RR_mat& RR_mat::transpose_inplace() {
  if(!d_mat_is_square((const d_mat_struct*) (*this))){
    // make a copy and do the transpose
    auto copy = RR_mat(ncols(), nrows());
    d_mat_transpose((d_mat_struct*) copy, (d_mat_struct*) (*this));
    swap(copy.data, data);
    return *this;
  }
  d_mat_transpose((d_mat_struct*) (*this),(d_mat_struct*) (*this));
  return *this;
}

static
void d_mat_lq(d_mat_t L, d_mat_t Q, const d_mat_t A)
{
    slong i, j, k;
    int flag, orig;
    double t, s;

    if (Q->c != A->c || Q->r != A->r || L->c != A->r || L->r != A->r)
    {
        flint_printf("Exception (d_mat_qr). Incompatible dimensions.\n");
        flint_abort();
    }

    if (Q == A)
    {
        d_mat_t t;
        d_mat_init(t, A->r, A->c);
        d_mat_lq(L, t, A);
        d_mat_swap(Q, t);
        d_mat_clear(t);
        return;
    }

    if (A->c == 0)
    {
        return;
    }

    for (k = 0; k < A->r; k++)
    {
        for (j = 0; j < A->c; j++)
        {
            d_mat_entry(Q, k, j) = d_mat_entry(A, k, j);
        }
        orig = flag = 1;
        while (flag)
        {
            t = 0;
            for (i = 0; i < k; i++)
            {
                s = 0;
                for (j = 0; j < A->c; j++)
                {
                    s += d_mat_entry(Q, i, j) * d_mat_entry(Q, k, j);
                }
                if (orig)
                {
                    d_mat_entry(L, k, i) = s;
                }
                else
                {
                    d_mat_entry(L, k, i) += s;
                }
                t += s * s;
                for (j = 0; j < A->c; j++)
                {
                    d_mat_entry(Q, k, j) -= s * d_mat_entry(Q, i, j);
                }
            }
            s = 0;
            for (j = 0; j < A->c; j++)
            {
                s += d_mat_entry(Q, k, j) * d_mat_entry(Q, k, j);
            }
            t += s;
            flag = 0;
            if (s < t)
            {
                orig = 0;
                if (fabs(s * D_EPS) < 1.0e-308)
                    s = 0;
                else
                    flag = 1;
            }
        }
        d_mat_entry(L, k, k) = s = sqrt(s);
        if (s != 0)
            s = 1 / s;
        for (j = 0; j < A->c; j++)
        {
            d_mat_entry(Q, k, j) *= s;
        }
    }
}

tuple<RR_mat,RR_mat> LQ(const ZZ_mat &mat)
{
  auto copy = RR_mat(mat);

  auto L = RR_mat(copy.nrows(), copy.ncols());
  auto Q = RR_mat(copy.ncols(), copy.ncols());

  d_mat_lq((d_mat_struct*) L, (d_mat_struct *) Q, (const d_mat_struct *) copy);

  return tuple(L,Q);

}

slong RR_mat_ptr::nrows() const { return ((const d_mat_struct*) (*this))->r; }
slong RR_mat_ptr::ncols() const { return ((const d_mat_struct*) (*this))->c; }



// return whether bounds were successfully set
bool RR_mat_iterator::iterator::set_bounds(){

  if(pos < 0 || pos >= dim) return false;

  int64_t min_coeff = ceil(-1e-6 - (len_bounds[pos]+vec[pos]) * inv_diags[pos]);
  int64_t max_coeff = floor(1e-6 - (-len_bounds[pos]+vec[pos]) * inv_diags[pos]);

  if(max_coeff < min_coeff){
    return false;
  }

  coeff_bounds[pos] = coeffs[pos] + max_coeff;
  coeffs[pos] += min_coeff;

  if(!two_sided[pos]){
    min_coeff -= coeffs[pos];
    coeffs[pos]=0;
  }

  // fill in
  for(size_t col=0; col<=pos; col++){
    vec[col] += min_coeff*mat[pos][col];
  }

  if(pos > 0){
    len_bounds[pos-1] = sqrt(len_bounds[pos]*len_bounds[pos] - vec[pos]*vec[pos]);
  }

  return true;
}

bool RR_mat_iterator::iterator::backtrack(){
  pos++;
  // WARNING: need to check pos >= dim when you recursively call backtrack
  if(pos >= dim) return false;

  if(coeffs[pos] == coeff_bounds[pos]) return false;

  coeffs[pos]++;
  for(size_t col=0; col<=pos; col++){
    vec[col] += mat[pos][col];
  }

  len_bounds[pos-1] = sqrt(len_bounds[pos]*len_bounds[pos] - vec[pos]*vec[pos]);

  return true;
}

void RR_mat_iterator::iterator::next_phase(){

  if(!params.in_phases) return;
  if(params.len_bound.has_value()){
    if(len_bounds[dim-1] == params.len_bound.value()) return;
  }

  min_len = len_bounds[dim-1];
  len_bounds[dim-1] = params.grow_factor * min_len;
  if(params.len_bound.has_value()){
    len_bounds[dim-1] = min(params.len_bound.value(), len_bounds[dim-1]);
  }
  pos = dim;

  step_to_front(true);
}


void RR_mat_iterator::iterator::set_interior(){

  if(!two_sided[0] && min_len==0)
  {
    l_coeff = 0;
    r_coeff = 0;
    if(0 == coeffs[0]) jump_interior();
    return;
  }

  // don't do this if no shell
  if((!params.in_phases) || (min_len==0))
  {
    l_coeff = coeff_bounds[0]+1;
    return;
  }

  double tail_len_sq = len_bounds[dim-1]*len_bounds[dim-1] - len_bounds[0]*len_bounds[0];

  double min_coeff_sq = min_len*min_len - tail_len_sq;

  if(min_coeff_sq > 0){
    double min_coeff = sqrt(min_coeff_sq);

    l_coeff = ceil(-1e-6 - (min_coeff+vec[0]) * inv_diags[0]);
    r_coeff = floor(1e-6 - (-min_coeff+vec[0]) * inv_diags[0]);

    if(r_coeff < l_coeff){
      // no inner shell
      l_coeff = coeff_bounds[0]+1;
    }
    else{
      l_coeff += coeffs[0];
      r_coeff += coeffs[0];
    }
  }
  else{
    // no inner shell
    l_coeff = coeff_bounds[0]+1;
    return;
  }

  // check if coeffs are already above l_coeff (two_sided causes this)
  if(l_coeff <= coeffs[0]){
    jump_interior();
  }
}


void RR_mat_iterator::iterator::step_to_front(bool go_forward){

  // TODO: if we hit the end, see if we can update the shell
  if(go_forward){
    pos--;

    if(pos<dim-1){
      two_sided[pos] = two_sided[pos+1] || (coeffs[pos+1] != 0);
    }

    go_forward = set_bounds();
  }
  else{
    go_forward = backtrack();
  }

  if(pos >= dim) return next_phase();
  if(pos == 0 && go_forward){
    return set_interior();
  }

  return step_to_front(go_forward);
}


void RR_mat_iterator::iterator::jump_interior(){

  if(r_coeff >= coeff_bounds[0]){
    return step_to_front(false);
  }

  int64_t jump = 1+r_coeff-coeffs[0];

  coeffs[0] += jump;
  vec[0] += jump*mat[0][0];
}

bool RR_mat_iterator::iterator::is_primitive() {

  int64_t G = 0;

  for(auto index=0; index<dim; index++){
    G = gcd(coeffs[index],G);
    if(G==1) return true;
  }

  return (G==1);
}

RR_mat_iterator::iterator& RR_mat_iterator::iterator::operator++() {

  ++num_vecs;
  if(num_vecs >= params.max_vecs){
    pos = dim;
    return *this;
  }

  if(coeffs[0]>=coeff_bounds[0]){
    step_to_front(false);
  }
  else{
    coeffs[0]++;

    vec[0] += mat[0][0];

    if(params.in_phases && (coeffs[0] == l_coeff)) jump_interior();
  }

  if(params.only_primitive){
    if(!is_primitive()){
      --num_vecs;
      return ++(*this);
    }
  }

  return *this;
}

RR_vec_ptr RR_mat_ptr::operator[](const int row) const {
  return ((const d_mat_struct*) (*this))->rows[row];
}


RR_mat_iterator::iterator::iterator(const RR_mat &in_mat,
    RR_mat_params in_params) : mat(in_mat), params(in_params) {

  if(params.in_phases){
    min_len = 0;
  }

  pos = in_mat.nrows();
  dim = mat.nrows();
  pos = dim;
  coeffs = vector<int64_t>(dim);
  coeff_bounds = vector<int64_t>(dim);
  len_bounds = vector<double>(dim);

  if(params.in_phases || (!params.len_bound.has_value())){
    len_bounds[dim-1] = params.grow_factor * mat[0][0];
    if(params.len_bound.has_value()){
      len_bounds[dim-1] = min(len_bounds[dim-1], params.len_bound.value());
    }
  }
  else{
    len_bounds[dim-1] = params.len_bound.value();
  }

  vec = vector<double>(dim);
  inv_diags = vector<double>(dim);
  two_sided = vector<bool>(dim);
  for(size_t index=0; index<dim; index++){
    coeffs[index] = 0;
    vec[index] = 0;
    inv_diags[index] = 1/mat[index][index];
    two_sided[index] = params.two_sided;
  }

  step_to_front(true);
}

bool RR_mat_iterator::iterator::operator!=(const iterator &other) const {
  // basically only checks for the end
  return (pos!=dim || other.pos!=dim);
}


tuple<vector<int64_t>,vector<double>> RR_mat_iterator::iterator::operator*() const {
  return tuple(coeffs, vec);
}
