#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <gmp.h>

inline void mpz_mat_swap_rows(mpz_t *a, mpz_t *b, int n, mpz_t tmp)
{
    for(int j=0; j<n; j++)
    {
        mpz_set(tmp,a[j]);
        mpz_set(a[j],b[j]);
        mpz_set(b[j],tmp);
    }
}

int log2_int(int a)
{
    int b = 1;
    int l = 0;
    while(b < a)
    {
        b <<= 1;
        l++;
    }

    return l;
}

int main(int argc, char *argv[])
{

    printf("Hello, world!\n");

    int n = 7;
    int M = 9;

    int size_M = log2_int(M);
    printf("%X is %d bits\n", M, size_M);

    mpz_t **a = malloc(n * sizeof(mpz_t *));

    for(int i=0; i<n; i++)
    {
        a[i] = malloc(n * sizeof(mpz_t));
        for(int j=0; j<n; j++)
        {
            mpz_init2(a[i][j], 2*size_M);
        }
    }

    mpz_t MM;
    mpz_init2(MM, 2*size_M);
    mpz_set_ui(MM, M);

    // generate random matrix for testing
    gmp_randstate_t state;
    gmp_randinit_default(state);
    gmp_randseed_ui(state, time(NULL));
    for(int i=0; i<n; i++)
    {
        for(int j=0; j<n; j++)
        {
            mpz_urandomm(a[i][j], state, MM);
        }
    }

    printf("here is random matrix\n");
    for(int i=0; i<n; i++)
    {
        for(int j=0; j<n; j++)
        {
            gmp_printf("%2Zd ", a[i][j]);
        }
        printf("\n");
    }

    // set up kernel
    mpz_t **ker = malloc(n * sizeof(mpz_t *));
    for(int i=0; i<n; i++)
    {
        ker[i] = malloc(n * sizeof(mpz_t));
        for(int j=0; j<n; j++)
        {
            mpz_init2(ker[i][j], 2*size_M);
        }
    }

    for(int i=0; i<n; i++)
    {
        mpz_set_ui(ker[i][i], 1);
    }

    mpz_t tmp, gcd_val;
    mpz_init2(tmp, 2*size_M);
    mpz_init2(gcd_val, 2*size_M);
    for(int i=0; i<n-1; i++)
    {
        // find nonzero pivot, if exists
        int pivot = i;
        while(pivot<n && mpz_cmp_ui(a[i][pivot],0)==0)
            pivot++;
        // if pivot == n, we are done with this column
        if(pivot<n)
        {
            if(pivot != i)
            {
                mpz_mat_swap_rows(a[i],a[pivot],n,tmp);
                mpz_mat_swap_rows(ker[i],ker[pivot],n,tmp);
            }

            while(mpz_tstbit(a[i][i],0) == 0)
            {
                for(int j=0; j<n; j++)
                {
                    if(mpz_tstbit(a[i][j],0) == 1)
                    {
                        mpz_add(a[i][j],a[i][j],MM);
                    }

                    if(mpz_tstbit(ker[i][j],0) == 1)
                    {
                        mpz_add(ker[i][j],ker[i][j],MM);
                    }

                    mpz_fdiv_q_2exp(a[i][j], a[i][j], 1);
                    mpz_fdiv_q_2exp(ker[i][j], ker[i][j], 1);
                }
            }

            for(int row=i+1; row<n; row++)
            {

                if(mpz_cmp_ui(a[row][i],0) != 0)
                {

                    while(mpz_tstbit(a[row][i],0) == 0)
                    {
                        for(int j=0; j<n; j++)
                        {
                            if(mpz_tstbit(a[row][j],0) == 1)
                            {
                                mpz_add(a[row][j],a[row][j],MM);
                            }

                            if(mpz_tstbit(ker[row][j],0) == 1)
                            {
                                mpz_add(ker[row][j],ker[row][j],MM);
                            }

                            mpz_fdiv_q_2exp(a[row][j], a[row][j], 1);
                            mpz_fdiv_q_2exp(ker[row][j], ker[row][j], 1);
                        }
                    }

                    if(mpz_cmp(a[i][i], a[row][i]) > 0)
                    {
                        mpz_mat_swap_rows(a[i],a[row],n,tmp);
                        mpz_mat_swap_rows(ker[i],ker[row],n,tmp);
                    }

                    while(mpz_cmp_ui(a[row][i],0) != 0)
                    {
                        for(int j=0; j<n; j++)
                        {
                            mpz_sub(a[row][j], a[row][j], a[i][j]);
                            if(mpz_cmp_ui(a[row][j],0) < 0)
                            {
                                mpz_add(a[row][j], a[row][j], MM);
                            }
                            mpz_sub(ker[row][j], ker[row][j], ker[i][j]);
                            if(mpz_cmp_ui(ker[row][j],0) < 0)
                            {
                                mpz_add(ker[row][j], ker[row][j], MM);
                            }
                        }

                        while(mpz_cmp_ui(a[row][i],0) != 0 && mpz_tstbit(a[row][i],0) == 0)
                        {
                            for(int j=0; j<n; j++)
                            {
                                if(mpz_tstbit(a[row][j],0) == 1)
                                {
                                    mpz_add(a[row][j],a[row][j],MM);
                                }
                                if(mpz_tstbit(ker[row][j],0) == 1)
                                {
                                    mpz_add(ker[row][j],ker[row][j],MM);
                                }

                                mpz_fdiv_q_2exp(a[row][j], a[row][j], 1);
                                mpz_fdiv_q_2exp(ker[row][j], ker[row][j], 1);
                            }
                        }

                        if(mpz_cmp_ui(a[row][i],0) != 0 && mpz_cmp(a[i][i], a[row][i]) > 0)
                        {
                            mpz_mat_swap_rows(a[i],a[row],n,tmp);
                            mpz_mat_swap_rows(ker[i],ker[row],n,tmp);
                        }

                    }
                }
            }

            // finally zero out column
            mpz_set(gcd_val,MM);
            while(mpz_cmp_ui(gcd_val,0) != 0)
            {
                mpz_sub(gcd_val,gcd_val,a[i][i]);
                while(mpz_cmp_ui(gcd_val,0) != 0 && mpz_tstbit(gcd_val,0) == 0)
                {
                    mpz_fdiv_q_2exp(gcd_val, gcd_val, 1);
                }
                if(mpz_cmp_ui(gcd_val,0) != 0 && mpz_cmp(a[i][i],gcd_val) > 0)
                {
                    mpz_set(tmp,gcd_val);
                    mpz_set(gcd_val,a[i][i]);
                    mpz_set(a[i][i],tmp);
                }
            }

            // now gcd is in a[i][i]; find divisor
            mpz_fdiv_q(gcd_val,MM,a[i][i]);

            for(int j=0; j<n; j++)
            {
                mpz_mul(ker[i][j],ker[i][j],gcd_val);
                mpz_mod(ker[i][j],ker[i][j],MM);
            }


        }
    }

    printf("after reduction\n");
    for(int i=0; i<n; i++)
    {
        for(int j=0; j<n; j++)
        {
            gmp_printf("%2Zd ", a[i][j]);
        }
        printf("\n");
    }

    // print result
    printf("here is kernel matrix\n");
    for(int i=0; i<n; i++)
    {
        for(int j=0; j<n; j++)
        {
            gmp_printf("%2Zd ", ker[i][j]);
        }
        printf("\n");
    }

    // clean up
    for(int i=0; i<n; i++)
    {
        for(int j=0; j<n; j++)
        {
            mpz_clear(ker[i][j]);
        }
        free(ker[i]);
    }
    free(ker);
    gmp_randclear(state);
    mpz_clear(MM);
    for(int i=0; i<n; i++)
    {
        for(int j=0; j<n; j++)
        {
            mpz_clear(a[i][j]);
        }
        free(a[i]);
    }
    free(a);

    exit(0);

}

