#include <algorithm>
#include <cmath>
#include <iostream>
#include <memory>
#include <tuple>
#include <vector>
#include <iterator>

#include <execution>

#include <ranges>

using namespace std;


tuple<bool,int64_t> gen_pandigital(int64_t a)
{
  int64_t k=2;

  auto str_a = to_string(a);

  string str_pan = "";
  for(int i=0; i<str_a.size(); i++)
  {
    char c = str_a[i];
    if((c=='0') || (str_pan.find(c) != string::npos))
    {
      return make_tuple(false,0);
    }
    str_pan += c;
  }

  while(str_pan.size() < 9)
  {
    int64_t b = k*a;

    auto str_b = to_string(b);

    for(int i=0; i<str_b.size(); i++)
    {
      char c = str_b[i];

      if((c=='0') || (str_pan.find(c) != string::npos))
      {
        return make_tuple(false,0);
      }

      str_pan += c;
    }
  }

  int64_t result = stoi(str_pan);

  return make_tuple(true,result);

}

int64_t prob_38()
{
  int64_t answer = 0;
  for(int len_head = 1; len_head < 5; len_head++)
  {
    int start = pow(10,len_head)-1;
    int stop = pow(10,len_head-1);

    // hack: I want to go in reverse order
    auto my_range = ranges::iota_view(-start,-stop);

    auto answer_it = find_if(execution::par, my_range.begin(), my_range.end(),
        [](const int &a) -> bool {
        bool works;
        int64_t result;
        tie(works, result) = gen_pandigital(-a);
        return works;
        });

    if(answer_it != my_range.end())
    {
      bool works;
      int64_t result;
      tie(works, result) = gen_pandigital(-(*answer_it));
      answer = max(answer, result);
    }
  }

  return answer;
}

int main()
{

  int64_t answer = prob_38();

  cout << answer << endl;

}

