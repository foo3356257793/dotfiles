#include <pybind11/pybind11.h>
#include <pybind11/stl.h>
#include <pybind11/complex.h>

namespace py = pybind11;

#include <assert.h> // for debugging
#include <bits/stdc++.h> // need for status bar
#include <omp.h> // for parallel for loops

// C++ std library stuff to import
#include <algorithm> // various algorithms
#include <iostream> // easy printing
#include <vector> // I use vectors here

#include <memory>

#include <tuple>

using std::tuple;

// C++ std functions I'm using
using std::cout;
using std::endl;
using std::max_element;
using std::min;
using std::ostream;
using std::setw;
using std::sort;
using std::string;
using std::vector;

using std::unique_ptr;
using std::make_unique;

using std::shared_ptr;
using std::make_shared;

// parameters to test
const int NUM_WHEAT = 1 << 6;
const int TARGET_NUM_WHEAT = NUM_WHEAT / 2;
const int NUM_TARES = NUM_WHEAT;
const int NUM_ROUNDS = 4;

// print vectors by <<
template <typename T>
std::ostream &operator<<(std::ostream &out, const std::vector<T> &v) {
  if (!v.empty()) {
    out << '[';
    std::copy(v.begin(), v.end(), std::ostream_iterator<T>(out, ", "));
    out << "\b\b]";
  }
  return out;
}

// convenient for printing the status of running steps
void display_progress_bar(int num_complete, int num_total, double time,
                          string name) {
  int num_dashes = (20 * num_complete) / num_total;
  int percent = (100 * num_complete) / num_total;
  const int total_width = 100 / 5;

  int count_width = ceil(log10(num_total + 1));

  cout << "\r"
       << "[" << string(num_dashes, (char)'-')
       << string(total_width - num_dashes, ' ') << "]";
  cout << setw(3) << percent << "%"
       << "  [" << name << " " << setw(count_width) << num_complete << " of "
       << num_total << "]"
       << "  (" << setw(9) << time << " secs)";
  std::cout.flush();
}

// vector with labels and cut info
class Observation {
 public:
  vector<double> values;
  string label;
  int index_bound;
  friend ostream &operator<<(ostream &os, const Observation &observation);

  Observation(vector<double> input_values, string input_label,
              int input_index_bound) {
    values = input_values;
    label = input_label;
    index_bound = input_index_bound;
  }
};

// print an Observation
std::ostream &operator<<(std::ostream &out, const Observation &obs) {
  out << "Observation with label " << obs.label << endl;
  out << "  index_bound = " << obs.index_bound << endl;
  out << obs.values;

  return out;
}

// boundary for a round: value and location in sorted list for round
class RoundBoundary {
 public:
  double value;
  int index;
  int num_rounds;
  //vector<Observation *>::iterator location;
  vector<shared_ptr<Observation>>::iterator location;

  RoundBoundary() {}

  // also updates the cut information
  // RoundBoundary(vector<Observation *>::iterator it,
  //               vector<Observation *>::iterator end, int round_index,
  RoundBoundary(vector<shared_ptr<Observation>>::iterator it,
      vector<shared_ptr<Observation>>::iterator end, int round_index,
                int input_num_rounds) {
    index = round_index;
    num_rounds = input_num_rounds;

    // cut tares OR wheat which already have a cut
    while ((it != end) &&
           (((*it)->label != "wheat") || ((*it)->index_bound < num_rounds))) {
      (*it)->index_bound = min((*it)->index_bound, index);
      it++;
    }
    assert(it != end);

    value = (*it)->values[index];
    location = it;
  }

  // doesn't update cut information, but computes score_delta
  //RoundBoundary(vector<Observation *>::iterator it,
  //              vector<Observation *>::iterator end,
  RoundBoundary(vector<shared_ptr<Observation>>::iterator it,
      vector<shared_ptr<Observation>>::iterator end,
                int round_index,
                int input_num_rounds, int &score_delta) {
    index = round_index;
    num_rounds = input_num_rounds;

    while (it != end && (*it)->label != "wheat") {
      score_delta += (*it)->index_bound - index;
      it++;
    }
    assert(it != end);

    value = (*it)->values[index];
    location = it;
  }
};

// sorted data, boundaries, and score info for a round
class Round {
 public:
  //vector<Observation *> sorted_data;
  vector<shared_ptr<Observation>> sorted_data;
  int index;
  int num_rounds;
  int score_delta = 0;
  RoundBoundary boundary;
  RoundBoundary next_boundary;

  //Round(vector<Observation *> input_data,
  Round(vector<shared_ptr<Observation>> input_data,
      int round_index,
        int input_num_rounds) {
    // note to self: this copies the input_data vector to make a new vector
    sorted_data = input_data;

    num_rounds = input_num_rounds;

    index = round_index;

    // sort the data on index `round_index`
    sort(sorted_data.begin(), sorted_data.end(),
         [round_index](const shared_ptr<Observation> &a,
                       const shared_ptr<Observation> &b) -> bool {
           return a->values[round_index] > b->values[round_index];
         });

    // compute the boundaries
    boundary = RoundBoundary(sorted_data.begin(), sorted_data.end(), index,
                             num_rounds);
  }

  // the next boundary after the current one
  // compute the new score delta as well
  void compute_next_boundary() {
    score_delta = (*boundary.location)->index_bound - index;
    next_boundary = RoundBoundary(boundary.location + 1, sorted_data.end(),
                                  index, num_rounds, score_delta);
  }

  // get the next boundary after this one and update index_bounds for
  // observations in betweeen
  void step_boundary() {
    //vector<Observation *>::iterator it = boundary.location;
    vector<shared_ptr<Observation>>::iterator it = boundary.location;

    (*it)->index_bound = min((*it)->index_bound, index);
    it++;

    boundary = RoundBoundary(it, sorted_data.end(), index, num_rounds);
  }
};

// everything we are going to use to analyze what boundaries to pick
class MyDataInRounds {
 public:
  //vector<Observation *> data;
  vector<shared_ptr<Observation>> data;
  int num_rounds;
  // TODO: use smart pointer for this
  //vector<Round *> rounds;
  vector<unique_ptr<Round>> rounds;
  int num_wheat;

  //MyDataInRounds(vector<Observation *> input_data, int input_num_rounds) {
  MyDataInRounds(vector<shared_ptr<Observation>> input_data, int input_num_rounds) {
    data = input_data;
    num_rounds = input_num_rounds;

    //rounds = vector<Round *>(num_rounds);
    rounds = vector<unique_ptr<Round>>(num_rounds);

    double start_time = omp_get_wtime();

    cout << endl;
    cout << "Sorting..." << endl;

    int rounds_complete = 0;
    display_progress_bar(rounds_complete, num_rounds, 0, "Round");

    #pragma omp parallel for
    for (int round = 0; round < num_rounds; round++) {
      //rounds[round] = new Round(data, round, num_rounds);
      rounds[round] = make_unique<Round>(data, round, num_rounds);

      #pragma omp critical
      {
        rounds_complete++;
        display_progress_bar(rounds_complete, num_rounds,
                             omp_get_wtime() - start_time, "Round");
      }
    }

    double end_time = omp_get_wtime();
    cout << endl;
    cout << "Took " << end_time - start_time << " sec." << endl;
    cout << endl;

    // reprocess rounds to set next_boundary
    #pragma omp parallel for
    for (auto& round_ptr : rounds) {
      round_ptr->compute_next_boundary();
    }

    num_wheat = count_if(data.begin(), data.end(), [](shared_ptr<Observation> &a) -> bool {
      return a->label == "wheat";
    });
  }

  // figure out where to make the next cut
  void cut_wheat() {

    // find max score delta
    vector<unique_ptr<Round>>::iterator arg_max =
        max_element(rounds.begin(), rounds.end(),
                    [](const unique_ptr<Round> &a, const unique_ptr<Round> &b) -> bool {
                      return a->score_delta < b->score_delta;
                    });

    // set the boundary
    //Observation *obs_ptr = *((*arg_max)->boundary.location);
    shared_ptr<Observation> obs_ptr = *((*arg_max)->boundary.location);
    obs_ptr->index_bound = (*arg_max)->index;

    #pragma omp parallel for
    for (auto &round_ptr : rounds) {
      //Observation *obs_ptr = *(round_ptr->boundary.location);
      shared_ptr<Observation> obs_ptr = *(round_ptr->boundary.location);
      if (obs_ptr->index_bound < num_rounds) {
        round_ptr->step_boundary();
      }
    }

    // recompute all score_deltas
    #pragma omp parallel for
    for (auto &round_ptr : rounds) {
      round_ptr->compute_next_boundary();
    }

    num_wheat--;
  }
};

// generate random data
vector<double> gen_random_vector(const int vector_length) {
  vector<double> values(vector_length);

  for (int index = 0; index < vector_length; index++) {
    values[index] =
        (double)((((uint64_t)rand()) << 48) + (((uint64_t)rand()) << 32) +
                 (rand() << 16) + (rand()));
  }

  // make these correlated
  for (int i = vector_length - 2; i >= 0; i--) {
    values[i] += values[i + 1];
  }

  return values;
}

// generate random data
vector<vector<double>> gen_random_vector_of_vectors(const int num_vectors,
                                                    const int vector_length) {
  vector<vector<double>> vec(num_vectors);

  for (int index = 0; index < num_vectors; index++) {
    vec[index] = gen_random_vector(vector_length);
  }

  return vec;
}

// is this vector below the boundaries?
bool test_vector(vector<double> vec, vector<double> boundaries) {
  for (size_t i = 0; i < vec.size(); i++) {
    if (vec[i] > boundaries[i]) {
      return false;
    }
  }

  return true;
}

// find the boundaries given wheat and tares
vector<double> find_boundaries(vector<vector<double>> wheat,
                               vector<vector<double>> tares, int num_rounds,
                               int target_num_wheat) {
  cout << endl;
  cout << "Placing data into solver..." << endl;

  // label and put into data object
  //vector<Observation *> data = {};
  vector<shared_ptr<Observation>> data = {};
  for (auto vec : wheat) {
    //data.push_back(new Observation(vec, "wheat", num_rounds));
    data.push_back(make_shared<Observation>(vec, "wheat", num_rounds));
  }
  for (auto vec : tares) {
    //data.push_back(new Observation(vec, "tares", num_rounds));
    data.push_back(make_shared<Observation>(vec, "tares", num_rounds));
  }

  // put into the MyDataInRounds class
  MyDataInRounds my_data(data, num_rounds);

  cout << "Cutting..." << endl;

  int num_to_cut = my_data.num_wheat - target_num_wheat;
  int cut_so_far = 0;

  display_progress_bar(0, num_to_cut, 0, "Cut");

  double start_time = omp_get_wtime();

  // cut out wheat until done
  while (my_data.num_wheat > target_num_wheat) {
    my_data.cut_wheat();

    cut_so_far++;
    if ((cut_so_far == num_to_cut) || ((cut_so_far & ((1 << 16) - 1)) == 0)) {
      display_progress_bar(cut_so_far, num_to_cut, omp_get_wtime() - start_time,
                           "Cut");
    }
  }

  double end_time = omp_get_wtime();
  cout << endl;
  cout << "Took " << end_time - start_time << " sec." << endl;
  cout << endl;

  // look at boundary
  vector<double> result = {};
  for (auto &round_ptr : my_data.rounds) {
    result.push_back(round_ptr->boundary.value);
  }

  #if 0
  // clean up
  for (auto obs : data) {
    delete obs;
  }
  #endif

  return result;
}

class foo {
  public:
    double cost;
    vector<double> sol;
};

foo compute_foo(int a, int b)
{
  foo my_foo;
  my_foo.cost = (double) a;
  my_foo.sol = {(double) a,(double) b};

  return my_foo;
}

tuple<int,vector<int>> compute_bar(int a, int b)
{
  vector<int> bar = {b,-a};
  return make_tuple(a+b, bar);
}

double sum_vec(vector<double> vec)
{
  double s = 0;
  for(auto v : vec)
  {
    s += v;
  }

  return s;
}

PYBIND11_MODULE(prob_functions, m) {
  m.doc() = "pybind11 example plugin"; // docstring

  m.def("find_boundaries", &find_boundaries, "A function to find boundaries over wheat and tares.");
  m.def("compute_foo", &compute_foo, "A function which returns a class.");
  m.def("sum_vec", &sum_vec, "A function which should take a list.");

  py::class_<foo>(m, "foo")
    .def_readwrite("cost", &foo::cost)
    .def_readwrite("sol", &foo::sol);

  m.def("compute_bar", &compute_bar, "A function which returns a tuple.");
}
