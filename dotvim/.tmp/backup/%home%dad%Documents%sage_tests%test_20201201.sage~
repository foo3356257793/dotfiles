#!/usr/bin/sage

import unittest

poly_ZZ.<x> = ZZ[]

def transform_for_integral_basis(M,K):

    d = K.degree()
    f = K.defining_polynomial()
    lead = f.leading_coefficient()

    for col in range(1,d):
        M[0,d-1-col] /= lead
    for row in range(1,d):
        M[row,d-1] *= lead

    return M

def basis_for_el(a,K):

    u = K.gen()
    d = K.degree()

    M = matrix(QQ, d, d)
    print(f"in: {a}")

    aa = a
    for row in range(d):
        print(f"{row}: {aa}")
        for col in range(d):
            M[row,d-1-col] = aa[col]
        aa *= u

    print("raw")
    print(M)
    print("")

    transform_for_integral_basis(M,K)

    #print("transformed")
    #print(M)
    #print("")

    return M

def hnf_basis_for_ell(a,K):

    M = basis_for_el(a,K)

    d = M.nrows()

    den = denominator(M)

    M_num = matrix(ZZ,den*M)

    hnf_M_num = M_num.hermite_form()

    return hnf_M_num / den

"""
def ns_full(M,p):

    N = matrix(GF(p),M).left_kernel().basis_matrix()
    d = M.nrows()

    full_N = matrix(ZZ,d,d)

    row=0

    for col in range(d):

        if row >= N.nrows() or N[row,col] == 0:
            full_N[col,col] = p
        else:
            for j in range(d):
                full_N[col,j] = ZZ(N[row,j])
            row += 1

    return full_N
"""

def clear_denom(M,K):

    d = K.degree()
    f = K.defining_polynomial()
    lead = ZZ(f.leading_coefficient())

    # for this test
    assert is_prime(lead)

    force_mat = lead * M

    try:
        force_mat = matrix(ZZ,force_mat)
    except:
        raise ValueError("expected this to work...")

    cob = ns_full(force_mat,lead)

    M = cob * M
    M = M.hermite_form()

    return M

def factor_ideals_over_prime(M,K,p):

    assert is_prime(p)

    # I ordered them so we go from bottom right to top left

    den = denominator(M_a)
    M_num = matrix(ZZ, den*M)

def transform_from_power_basis(K,O_K=None):

    if O_K is None:
        O_K = K.integral_basis()

    d = K.degree()

    mat = matrix(QQ,d,d)

    for row in range(d):
        for col in range(d):
            mat[row,col] = O_K[row][col]

    return mat

def M_x(K,O_K=None,T_O_K=None):

    u = K.gen()

    if T_O_K is None:
        T_O_K = transform_from_power_basis(K,O_K)

    d = K.degree()
    mat = matrix(QQ,d,d)

    for row in range(d-1):
        mat[row,row+1] = 1

    el = u^d
    for col in range(d):
        mat[d-1,col] = el[col]

    mat = T_O_K * mat * T_O_K^(-1)

    return mat

def numerator_mat(M):

    den = denominator(M)
    result = matrix(ZZ, den * M)

    return result, den

def null_cob(mat,p):

    mat = matrix(GF(p),mat)

    d = mat.nrows()
    result_p = mat.left_kernel().basis_matrix()

    result = matrix(ZZ, d,d)

    row = 0
    for col in range(d):

        if row >= result_p.nrows() or result_p[row,col] == 0:
            result[col,col] = p
        else:
            for j in range(col,d):
                result[col,j] = ZZ(result_p[row,j])
            row += 1

    return result

def primes_to_process(num):

    result = {}

    for diag in num.diagonal():

        for fac, m in factor(diag):

            try:
                result[fac] += m
            except:
                result[fac] = m

    return result


def factor_ideal_from_basis(M):

    num, den = numerator_mat(M)

    num = num.hermite_form()

    result = []

    primes = primes_to_process(num)

    for p in primes:

        GFp = GF(p)
        nu_p = primes[p]

        while nu_p > 0:

            log_p_norm = 0
            for diag in num.diagonal():
                if diag % p == 0:
                    log_p_norm += 1

            id_basis = matrix(GFp, num)
            result.append((p,id_basis,log_p_norm))

            nu_p -= log_p_norm

            assert nu_p >= 0
            assert log_p_norm > 0

            cob = null_cob(id_basis,p)
            num = cob * num
            num = matrix(ZZ,num / p)

            num = num.hermite_form()

    return result, num, den

def elements_from_basis(B,O_K):

    return [sum([ZZ(v) * b for v,b in zip(vec,O_K)]) for vec in B]


class Test(unittest.TestCase):

    def M_x(self):

        f = 2*x^3 - 3

        K.<u> = NumberField(f)
        d = K.degree()
        O_K = K.integral_basis()

        T_O_K = transform_from_power_basis(K,O_K)

        a_poly = 3*x+5

        M_u = M_x(K,O_K,T_O_K)

        M_a = a_poly(M_u)

        a_recov = sum([M_a[0,col] * O_K[col] for col in range(d)])

        print(M_a)
        print(a_recov)

        self.assertEqual(a_poly(x=u),a_recov)

    def ideal_factorization(self):

        f = 2*x^3 - 3

        K.<u> = NumberField(f)
        d = K.degree()
        O_K = K.integral_basis()

        T_O_K = transform_from_power_basis(K,O_K)

        a_poly = 3*x+5

        M_u = M_x(K,O_K,T_O_K)
        M_a = a_poly(M_u)

        ideals, num, denom = factor_ideal_from_basis(M_a)

        answer = ideal(a_poly(x=u))

        result = ideal(K(1))
        for p,B,log_p_norm in ideals:

            basis_els = elements_from_basis(B,O_K)
            iota = ideal([K(p)] + basis_els)

            result *= iota

        result /= ideal(K(denom))

        self.assertEqual(answer, result)


    # TODO: factor ideals over a prime


if __name__ == "__main__":

    suite = unittest.TestSuite()
    suite.addTest(Test("M_x"))
    suite.addTest(Test("ideal_factorization"))
    unittest.TextTestRunner().run(suite)

    f = 2*x^3 - 3

    K.<u> = NumberField(f)
    O_K = K.integral_basis()

    T_O_K = transform_from_power_basis(K,O_K)
    M_u = M_x(K,O_K,T_O_K)

    a_poly = 3*x+5
    M_a = a_poly(x=M_u)

    ideals, num, denom = factor_ideal_from_basis(M_a)

    # a = (3*u-5)

    # norm_K_a = norm(a)
    # norm_M_a = det(M_a)

    # M_a_orig = basis_for_el(a,K)

    # den = denominator(M_a_orig)
    # M_a_num = matrix(ZZ, den * M_a_orig)
    # M_a_num = M_a_num.hermite_form()
    # M_a_hnf = M_a_num / den
    # den = denominator(M_a_hnf)
    # M_a_hnf = matrix(ZZ, den * M_a_hnf)

    # print(f"HNF:\n{M_a_hnf}")
    # print(f"den = {den}")

    # primes_to_process = set()

    # for diag in M_a_hnf.diagonal():

    #     for fac,m in factor(diag):

    #         if not fac in primes_to_process:
    #             primes_to_process.add(fac)


    # lead = f.leading_coefficient()
    # col_basis = [x^(d-1-j) * lead for j in range(d-1)] + [1]

    # poly_list = [sum([M_a_hnf[i,j] * col_basis[j] for j in range(d)]) for i in range(d)]

    # """
    # for p in primes_to_process:

    #     print(f"processing {p}...")

    #     GFp = GF(p)
    #     poly_GFp.<v> = GFp[]

    #     M_mod = matrix(GFp, M_a_hnf).echelon_form()

    #     # poly_list = [sum([M_a_hnf[i,j] * v^(d-1-j) for j in range(d)]) for i in range(d)]

    #     # gen_poly = gcd(poly_list)

    #     # print(gen_poly)

    #     # print("def_poly:")
    #     # print(factor(poly_GFp(f)))
    # """

    # """
    # for fac,m in factor(ideal(a)):

    #     print(f"{norm(fac)}: {fac} : {m}")
    # """
