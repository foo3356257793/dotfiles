#+TITLE: dotemacs

* Startup
  
I put the basic startup things in =init.el=.

* Bootstrap use-package
  
Make sure =use-package= is installed.

#+begin_src emacs-lisp
  (unless (package-installed-p 'use-package)
   (package-refresh-contents)
   (package-install 'use-package))

  (eval-when-compile
    (require 'use-package)
    )
#+end_src

#+RESULTS:
: use-package

* Environment variables
  
When I don't run from shell I want to set the environment variables.
  
#+BEGIN_SRC emacs-lisp
  (use-package exec-path-from-shell
    :if (memq window-system '(mac ns x))
    :init (exec-path-from-shell-initialize))
#+END_SRC

#+RESULTS:
: t

* Look

** Basics
   
I just want a clean look.

#+begin_src emacs-lisp
  (setq inhibit-startup-screen t)
    (when window-system
     (blink-cursor-mode 0) ; Disable cursor blinking
     (menu-bar-mode -1)     ; No menu bar
     (toggle-scroll-bar -1) ; No scroll bar
     (fringe-mode 8)        ; Comfortable fringe
     (tool-bar-mode -1)     ; No tool bar
    )

  (setq default-frame-alist
        '(
          (vertical-scroll-bars . nil)
          (width . 90)
          (height . 40)
          (font . "Inconsolata 16")
          ))
#+end_src

#+RESULTS:
: ((vertical-scroll-bars) (width . 90) (height . 40) (font . Inconsolata 16))


Maybe this gives transparency.

#+BEGIN_SRC emacs-lisp
  (set-frame-parameter (selected-frame) 'alpha '(85 . 50))
  (add-to-list 'default-frame-alist '(alpha . (85 . 50)))
#+END_SRC

#+RESULTS:
: ((alpha 85 . 50) (vertical-scroll-bars) (width . 90) (height . 40) (font . Inconsolata 16))


Use visual line mode: don't worry about manually wrapping paragraphs anymore.

#+begin_src emacs-lisp
(add-hook 'text-mode-hook #'visual-line-mode)
#+end_src

#+RESULTS:
| (lambda nil (interactive) (message Olivetti text-mode-hook) (setq olivetti-body-width 81) (olivetti-mode 1)) | visual-line-mode | text-mode-hook-identify |

Vim scrolloff setting

#+begin_src emacs-lisp

(setq scroll-margin 4)

#+end_src

#+RESULTS:
: 4

** Olivetti: center in buffer
  
Here is a thing which centers the buffer, which I think looks nice.  Configure =text-mode= and =prog-mode= to use this.
  
#+begin_src emacs-lisp
  ;; (use-package olivetti
  ;; :config
  ;; (progn
  ;; (add-hook 'text-mode-hook (lambda()
  ;;                             (interactive)
  ;;                             (message "Olivetti text-mode-hook")
  ;;                             (setq olivetti-body-width 81)
  ;;                             ;(hide-mode-line-mode)
  ;;                             (olivetti-mode 1)))
  ;; (add-hook 'prog-mode-hook (lambda()
  ;;                             (interactive)
  ;;                             (message "Olivetti prog-mode-hook")
  ;;                             (setq olivetti-body-width 81)
  ;;                             ;(hide-mode-line-mode)
  ;;                             (olivetti-mode 1)))))
#+end_src

#+RESULTS:

** Theme
   
The idea is to leave a few options here.
   
*Note*. In the past, fixed this by using =customize-theme=.  Probably this is the way I want to set it.
   
   #+begin_src emacs-lisp
     ;; (use-package spacemacs-theme
     ;;   :defer t
     ;;   :init (load-theme 'spacemacs-light t)
     ;;   )
   #+end_src

   #+begin_src emacs-lisp
     (use-package spacemacs-theme
       :defer t
       :init (load-theme 'spacemacs-dark t)
       )
   #+end_src

   #+RESULTS:
   : t

** Mode line
   
I want a simple mode line.

#+begin_src emacs-lisp
  (setq-default mode-line-format '("%e" mode-line-front-space buffer-file-name))
#+end_src

#+RESULTS:
| %e | mode-line-front-space | buffer-file-name |

* Bind keys
  
Need this package to set some of the shortcuts.

*Update*. Maybe not.

#+begin_src emacs-lisp
  (require 'bind-key)
  ;;(use-package bind-key
  ;;  :ensure t
  ;;  :defer t
  ;;  )
#+end_src

#+RESULTS:

* Evil mode

** Load it
Make emacs be like Vim.

#+BEGIN_SRC emacs-lisp
  ;; I have to load evil-leader before evil
  (use-package evil-leader
    :ensure t
    :init 
    ;; I had to load these things first for evil collection
    (setq evil-want-integration t)
    (setq evil-want-keybinding nil)
    ;;(setq evil-want-minibuffer t) ; try out minibuffer evil
    (global-evil-leader-mode)
    :config (progn
              (setq evil-leader/in-all-states t)
              )
    )

  (use-package evil
    :ensure t
    :after evil-leader
    :init (progn
            (evil-mode 1)
            )
    )
#+END_SRC

#+RESULTS:

=evil-collection= makes various modes more evil.

#+BEGIN_SRC emacs-lisp
  (use-package evil-collection
    :ensure t
    :after evil
    :config (evil-collection-init))
#+END_SRC

#+RESULTS:
: t

** Evil surround
   
Use the surround package.

*Update*. I don't really use this.  I just manually surround things.

*Shortcuts*.

/Visual/. =S<textobject>= or =gS<textobject>=

/Normal/. =ys<textobject>= or =yS<textobject>=

/Change/. =cs<old><new>=

/Delete/. =ds<textobject>=

/Add new surround pairs./ You can.  Perhaps look at =C-h v evil-surround-pairs-alist= for more information.
   
#+begin_src emacs-lisp
  ;;(use-package evil-surround
  ;;  :ensure t
  ;;  :after evil
  ;;  :config
  ;;  (global-evil-surround-mode 1))
#+end_src

#+RESULTS:
: t

** Paragraphs
   
The default is un-Vim-like.  I want paragraphs to be blocks of text.
   
#+begin_src emacs-lisp

  (defadvice forward-evil-paragraph (around default-values activate)
    (let ((paragraph-start (default-value 'paragraph-start))
          (paragraph-separate (default-value 'paragraph-separate)))
      ad-do-it))

#+end_src

#+RESULTS:
: forward-evil-paragraph

** Global sub
   
#+BEGIN_SRC emacs-lisp
  (with-eval-after-load 'evil
    (setq evil-ex-substitute-global t)
    )
#+END_SRC

#+RESULTS:
: t

** Right at end of line
   
This variable makes it so that right at end of line wraps onto the beginning of the next line.

#+BEGIN_SRC emacs-lisp
  (with-eval-after-load 'evil
    (setq-default evil-cross-lines t)
    )
#+END_SRC

#+RESULTS:
: t

** Evil leader keys
   
Here are some basic leader keys

#+begin_src emacs-lisp
  (with-eval-after-load 'evil-leader
    (evil-leader/set-leader "<SPC>")
    (evil-leader/set-key
      ;; simple shortcuts from my vimrc
      ;; need to add the other-window part to make the splitting act the way I am used to
      "v" (lambda() (interactive) (evil-window-vsplit) (other-window 1))
      "s" (lambda() (interactive) (evil-window-split) (other-window 1))
      ;;"w" 'save-buffer
      "w" (lambda() (interactive) (message-box "Stop hitting SPC-w!"))
      ;; change this to helm?
      ;;"b" 'buffer-menu
      ;;"b" 'helm-buffers-list
      ;;"n" 'previous-buffer
      ;; edit emacs config
      "1" (lambda() (interactive)(find-file "~/.emacs.d/dotemacs.org"))
      ;; org-mode
      "p" 'org-toggle-latex-fragment
      "P" (lambda() (interactive) (setq current-prefix-arg '(16)) (call-interactively 'org-toggle-latex-fragment))
      "r" (lambda () (interactive) (org-edit-src-exit) (org-ctrl-c-ctrl-c))
      "e" 'org-edit-src-exit
      "c" 'evil-close-folds
      "o" 'evil-open-folds
      "h" 'hide-mode-line-mode
      "i" 'yas-insert-snippet
      )
    )

#+end_src

#+RESULTS:

** Window movement keys
   
I like using =C-[dir key]= to move between split windows.

#+begin_src emacs-lisp
  (eval-after-load 'evil
    '(progn
       (define-key evil-normal-state-map (kbd "C-h") #'evil-window-left)
       (define-key evil-normal-state-map (kbd "C-j") #'evil-window-down)
       (define-key evil-normal-state-map (kbd "C-k") #'evil-window-up)
       (define-key evil-normal-state-map (kbd "C-l") #'evil-window-right)
       (with-eval-after-load 'evil-maps
         '(progn
            (define-key evil-window-map (kbd "C-h") #'evil-window-left)
            (define-key evil-window-map (kbd "C-j") #'evil-window-down)
            (define-key evil-window-map (kbd "C-k") #'evil-window-up)
            (define-key evil-window-map (kbd "C-l") #'evil-window-right)
            )
         )
       )
    )
#+end_src

#+RESULTS:
| progn | (define-key evil-window-map (kbd C-h) #'evil-window-left) | (define-key evil-window-map (kbd C-j) #'evil-window-down) | (define-key evil-window-map (kbd C-k) #'evil-window-up) | (define-key evil-window-map (kbd C-l) #'evil-window-right) |

** Window resize

#+begin_src emacs-lisp
  (eval-after-load 'evil
    '(progn
       (define-key evil-normal-state-map (kbd "+") #'enlarge-window)
       (define-key evil-normal-state-map (kbd "-") #'shrink-window)
       )
    )
#+end_src

#+RESULTS:
: shrink-window
  
** Visual lines
   
I want direction commands to go up and down "visual" lines.

#+begin_src emacs-lisp
  (define-key evil-normal-state-map (kbd "<remap> <evil-next-line>") 'evil-next-visual-line)
  (define-key evil-normal-state-map (kbd "<remap> <evil-previous-line>") 'evil-previous-visual-line)
  (define-key evil-motion-state-map (kbd "<remap> <evil-next-line>") 'evil-next-visual-line)
  (define-key evil-motion-state-map (kbd "<remap> <evil-previous-line>") 'evil-previous-visual-line)
  (evil-define-minor-mode-key 'motion 'visual-line-mode "0" 'evil-beginning-of-visual-line)
  (evil-define-minor-mode-key 'motion 'visual-line-mode "$" 'evil-end-of-visual-line)
  (evil-define-minor-mode-key 'motion 'visual-line-mode "^" 'evil-first-non-blank-of-visual-line)
#+end_src

* Hydras
  
#+BEGIN_SRC emacs-lisp
  (use-package hydra
    :ensure t)
#+END_SRC

#+RESULTS:
  
Here is one for resizing windows.  Set it to leader =+=.

#+BEGIN_SRC emacs-lisp
  (eval-after-load 'hydra
    '(progn
       (defhydra my/hydra-resize ()
         "resize"
         ("=" shrink-window-horizontally)
         ("-" enlarge-window-horizontally)
         )
       (with-eval-after-load 'evil-leader
         (evil-leader/set-key
           "+" 'my/hydra-resize/body))
       ) 
       )
    #+END_SRC

#+RESULTS:

* Compilation shortcut
  
** Don't ask

Don't ask what compilation command to use.  Just assume what we want is =make -k=.  Typically I should have a =Makefile= handy.

#+begin_src emacs-lisp
(setq compilation-read-command nil)
#+end_src

#+RESULTS:

Don't ask me to save before compile: just do it.

#+begin_src emacs-lisp
(setq compilation-ask-about-save nil)
#+end_src

#+RESULTS:

** Nice compilation buffer

I want the compilation buffer to just go away if there were no problems.

#+begin_src emacs-lisp
(setq compilation-finish-functions
      (lambda (buf str)
        (if (null (string-match ".*exited abnormally.*" str))
            ;; no errors, make the compilation window go away
            (progn
              (run-at-time
               "2 sec" nil 'delete-windows-on
               (get-buffer-create "*compilation*"))
              (message "No Compilation Errors!")))))
#+end_src

#+RESULTS:
| lambda | (buf str) | (if (null (string-match .*exited abnormally.* str)) (progn (run-at-time 2 sec nil 'delete-windows-on (get-buffer-create *compilation*)) (message No Compilation Errors!))) |

I want the compilation buffer to be small and always a 'split'.

#+begin_src emacs-lisp
  (defun my/compile ()
    "Run compile and resize the compile window"
    (interactive)
    (progn
      (call-interactively 'compile)
      (setq cur (selected-window))
      (setq w (get-buffer-window "*compilation*"))
      (select-window w)
      (setq h (window-height w))
      (shrink-window (- h 10))
      (select-window cur)
      )
    )

  ;; I want compile buffer to always be a split
  (setq split-height-threshold 0)
  (setq split-width-threshold nil)
#+end_src

#+RESULTS:

** Shortcut
   
Bind =my/compile= to a leader key.  Have been using =m= for =Make=.

#+BEGIN_SRC emacs-lisp
  (with-eval-after-load 'evil-leader
    (evil-leader/set-key
      "m" 'my/compile
      )
    )
#+END_SRC
#+RESULTS:

* org-mode
  
#+BEGIN_SRC emacs-lisp
  ;;(use-package org)
  (require 'org)
#+END_SRC

#+RESULTS:
: org

** Folding

Startup unfolded is default.

#+begin_src emacs-lisp
(setq org-startup-folded nil)
#+end_src

#+RESULTS:

** Indenting
   
The following seems to make things look nice.

#+begin_src emacs-lisp
  (eval-after-load 'org-indent
    (org-indent-mode t)
    )
#+end_src

#+RESULTS:
: t

** LaTeX preview
   
Don't startup in preview.

#+begin_src emacs-lisp
(setq org-startup-with-latex-preview nil)
#+end_src

#+RESULTS:

Set the scale as shown to make the font size (set above) match the fragments well.

#+begin_src emacs-lisp
(setq org-format-latex-options (plist-put org-format-latex-options :scale 1.6))
#+end_src

#+RESULTS:
| :foreground | default | :background | default | :scale | 1.6 | :html-foreground | Black | :html-background | Transparent | :html-scale | 1.0 | :matchers | (begin $1 $ $$ \( \[) |

** Images

Show images when opening a file.

#+begin_src emacs-lisp
(setq org-startup-with-inline-images t)
#+end_src

#+RESULTS:
: t

Show images after evaluating code blocks

#+begin_src emacs-lisp
(add-hook 'org-babel-after-execute-hook 'org-display-inline-images 'append)
#+end_src

#+RESULTS:
| org-display-inline-images |

** don't ask
   
Don't double check if I want to compile a code block.

#+begin_src emacs-lisp
(setq org-confirm-babel-evaluate nil)
#+end_src

#+RESULTS:

** languages
   
Need this for syntax coloring stuff??

#+begin_src emacs-lisp
(setq org-src-fontify-natively t)
#+end_src

#+RESULTS:
: t

Things to make languages work.
  
#+begin_src emacs-lisp
(setq org-highlight-latex-and-related '(latex script entities))
(org-babel-do-load-languages
 'org-babel-load-languages
 '((python . t)
   (latex . t)))
#+end_src

#+RESULTS:

** Python
   
Here is a thing which we need for some reason.
   
#+begin_src emacs-lisp
(setq python-shell-completion-native-enable nil)
#+end_src

#+RESULTS:

Set the default header.
   
#+begin_src 
(setq org-babel-default-header-args:python
             '((:exports . "both")
               (:results . "output")
               (:session . "*org-python*")))
#+end_src

** Sagemath
   
Set default header.  *Note*. Must have =:session= true at all times.
   
#+begin_src emacs-lisp
(setq org-babel-default-header-args:sage '((:session . t)
                                           (:results . "output")
                                           (:exports . "both")))
#+end_src

=C-c c= for asynchronous evaluating (only for SageMath code blocks).

TODO: I should bind this to a leader expression?

#+begin_src emacs-lisp
(with-eval-after-load "org"
  (define-key org-mode-map (kbd "C-c c") 'ob-sagemath-execute-async))
#+end_src


** org-slides
  
I want a simple setup for showing slides.

*** slides movement
   
Here are beginning and next slides.  I just want to cycle through the headings.

#+begin_src emacs-lisp
  (eval-after-load 'org
    '(progn

       (defun my/org-next-slide ()
         (interactive)
         (widen)
         (org-next-visible-heading 1)
         (org-narrow-to-subtree)
         (evil-close-folds)
         (evil-open-fold))

       (defun my/org-previous-slide ()
         (interactive)
         (widen)
         (org-previous-visible-heading 1)
         (org-narrow-to-subtree)
         (evil-close-folds)
         (evil-open-fold))


       (with-eval-after-load 'evil-leader
         (evil-leader/set-key-for-mode 'org-mode
           "," 'my/org-previous-slide
           "." 'my/org-next-slide
           )
         )
       )
    )
#+end_src

#+RESULTS:

Defined to be =,= and =.=.

*** zoom
    
Have to also modify the latex scaling.

#+BEGIN_SRC emacs-lisp
  (eval-after-load 'org
    '(progn
       (defun my/org-increase-text-size (&optional arg)
         (interactive "P")
         (text-scale-increase 1.5)
         (plist-put org-format-latex-options :scale (* 1.5 (plist-get org-format-latex-options :scale)))
         )

       (defun my/org-decrease-text-size (&optional arg)
         (interactive "P")
         (text-scale-decrease 1.5)
         (plist-put org-format-latex-options :scale (/ 1.5 (plist-get org-format-latex-options :scale)))
         )

       (eval-after-load 'hydra
         '(progn
            (defhydra my/hydra-org-resize ()
              "resize"
              ("+" my/org-increase-text-size)
              ("-" my/org-decrease-text-size)
              )

            (with-eval-after-load 'evil-leader
              (evil-leader/set-key-for-mode 'org-mode
                "+" 'my/hydra-org-resize/body
                )
              )
            )
         )
       )

    )
#+END_SRC

#+RESULTS:

** src window
   
I want to pop out the src as its own window.

*Update*. I'm actually splittng it as a window below.

#+begin_src emacs-lisp
  (setq org-src-window-setup 'split-window-below)
#+end_src

#+RESULTS:
: split-window-below

I want =ZZ= to just do the exit (and not close and save).


#+begin_src emacs-lisp
  (with-eval-after-load 'evil
    (eval-after-load 'org
      '(evil-define-minor-mode-key 'normal 'org-src-mode
         (kbd "ZZ") 'org-edit-src-exit)
      )
    )
#+end_src

#+RESULTS:


** Meta return
   
*TODO*. I need to figure out what I have in my other file.

Note that the following simpler thing also works.
   
#+begin_src emacs-lisp
  (eval-after-load 'org
    '(progn

       (defun my/org-meta-ret ()
         (interactive)
         (evil-append-line 1)
         (org-meta-return)
         )

       (defun my/org-meta-ret-backwards ()
         (interactive)
         (evil-previous-line)
         (evil-append-line 1)
         (org-meta-return))

       (eval-after-load 'evil
         '(progn
            (evil-define-key 'normal org-mode-map (kbd "go") 'my/org-meta-ret)
            (evil-define-key 'normal org-mode-map (kbd "gO") 'my/org-meta-ret-backwards)
            ))
       )
    )
#+end_src

#+RESULTS:

I set these to =go= and =gO=.


** evil leader

To get the LaTeX-environment function, I think I need to load the =latex= environment.

#+BEGIN_SRC emacs-lisp
  (add-hook 'org-mode-hook (lambda() (require 'latex)))

#+END_SRC

Here are some leader shortcuts for orgmode only.

#+begin_src emacs-lisp
  (with-eval-after-load 'evil-leader
    (eval-after-load 'org
      '(evil-leader/set-key-for-mode 'org-mode
         ;;"e" (lambda () (interactive) (org-edit-src-code) (evil-insert 1))
         "e" 'org-edit-src-code
         "r" 'org-ctrl-c-ctrl-c
         "R" 'org-babel-execute-buffer
         "C" 'org-content
         "W" 'widen
         "l" 'LaTeX-environment ;; have to load latex as above for this
         "z" 'my/hydra-org-resize/body
         "," 'my/org-previous-slide
         "." 'my/org-next-slide
         )
      )
    )
#+end_src

* Templates
  
  For various files.

  #+begin_src emacs-lisp
    (use-package autoinsert
      :ensure t
      :init
      ;; Don't get prompted before insertion
      (setq auto-insert-query nil) ;;; Don't ask before inserting
      (setq auto-insert-directory (locate-user-emacs-file "templates")) ;;; Trailing slash necessary for some reason
      (add-hook 'find-file-hook 'auto-insert)
      (auto-insert-mode 1)

      :config
      (define-auto-insert "\\.c" "c.template")
      (define-auto-insert "\\.py" "python.template")
      (define-auto-insert "\\.sage" "sage.template")
      (define-auto-insert "Makefile" "Makefile_for_tex")
      (define-auto-insert "\\.tex" "latex-template.tex")
      )
  #+end_src

  #+RESULTS:
  : t

* LaTeX
  
Use =auctex=.

#+BEGIN_SRC emacs-lisp
  (use-package auctex
    :defer t
    :ensure t)

  (add-hook 'LaTeX-mode-hook 'LaTeX-math-mode)
#+END_SRC

#+RESULTS:
| LaTeX-math-mode |
  
#+begin_src emacs-lisp
  (eval-after-load 'latex
    '(progn
       (defun my/latex-meta-ret ()
         (interactive)
         (evil-append-line 1)
         (latex-insert-item)
         )

       (defun my/latex-meta-ret-backwards ()
         (interactive)
         (evil-previous-line)
         (evil-append-line 1)
         (latex-insert-item))

       (eval-after-load 'evil
         '(progn
            (evil-define-key 'normal LaTeX-mode-map (kbd "go") 'my/latex-meta-ret)
            (evil-define-key 'normal LaTeX-mode-map (kbd "gO") 'my/latex-meta-ret-backwards)
            )
         )
       )
    )
#+end_src

Leader keys.

#+BEGIN_SRC emacs-lisp
  (with-eval-after-load 'evil-leader
    (evil-leader/set-key-for-mode 'latex-mode
      "l" 'LaTeX-environment
      )
    )
#+END_SRC

#+RESULTS:

I want aggresive indenting.

#+BEGIN_SRC emacs-lisp
  (use-package aggresive-indent
    :hook (LaTeX-mode . aggresive-indent-mode)
    )
#+END_SRC

#+RESULTS:
| aggresive-indent-mode | (lambda nil (TeX-fold-mode 1)) | LaTeX-math-mode |

I want folding.

*TODO*. Figure this out.

#+BEGIN_SRC emacs-lisp
  (add-hook 'LaTeX-mode-hook (lambda() (TeX-fold-mode 1)))
#+END_SRC

#+RESULTS:
| (lambda nil (TeX-fold-mode 1)) | aggresive-indent-mode | LaTeX-math-mode |

* Rainbow delimiters
  
#+begin_src emacs-lisp
(use-package rainbow-delimiters
    :ensure t
    :init
    (progn
    (add-hook 'prog-mode-hook 'rainbow-delimiters-mode)))
#+end_src


* Smartparens
  
Simple config.

TODO. There are some completions in LaTeX which don't work yet.
  
#+begin_src emacs-lisp
  (use-package smartparens
    :ensure t
    :config
    (progn
      (require 'smartparens-config)
      (smartparens-global-mode 1)))
#+end_src

* Smooth scrolling
  
Simple config.

TODO. The scrolling isn't that smooth.  Would need a pixel mode, available in later emacs versions.

#+begin_src emacs-lisp
  (use-package smooth-scrolling
    :ensure t
    :config
    (progn
      (require 'smooth-scrolling)
      (smooth-scrolling-mode 1)))
#+end_src

* Autosave
  
Have a directory for backup files.

#+begin_src emacs-lisp
  (setq backup-directory-alist
        `(("." . ,(concat user-emacs-directory "backups"))))
#+end_src

There is a "real autosave" package.

#+begin_src emacs-lisp
  ;; (use-package real-auto-save
  ;;   :ensure t
  ;;   :init (setq real-auto-save-interval 5)
  ;;   :config (progn
  ;;          (require 'real-auto-save)
  ;;          (add-hook 'prog-mode-hook 'real-auto-save-mode)
  ;;          (add-hook 'text-mode-hook 'real-auto-save-mode)
  ;;          )
  ;;   )
#+end_src

For later versions of emacs, there is an option

#+begin_src emacs-lisp
  (auto-save-visited-mode)
#+end_src

* Garbage collection
  
The following /should/ make the system feel snappier.

#+BEGIN_SRC emacs-lisp
  ;;(add-hook 'focus-out-hook #'garbage-collect)
#+END_SRC

#+RESULTS:

* Helm
  
*TODO*: I should configure this more.
  
#+begin_src emacs-lisp
  ;; (use-package helm-config
  ;; :ensure helm
  ;; :config
  ;; (setq helm-M-x-fuzzy-match t)
  ;; (setq helm-mode-fuzzy-match t)
  ;; (setq helm-completion-in-region-fuzzy-match t)
  ;; (helm-mode 1)
  ;; :bind ("M-x" . helm-M-x)
  ;; )
#+end_src

#+RESULTS:
: helm-M-x

I should use =helm-company=.

*UPDATE*. Didn't like it.

#+begin_src emacs-lisp
  ;; (use-package helm-company
  ;;   :ensure t
  ;;   :after company
  ;;   :config
  ;;   (bind-key (kbd "TAB") 'helm-company company-mode-map)
  ;;   (bind-key (kbd "<tab>") 'helm-company company-mode-map)
  ;;   (bind-key (kbd "TAB") 'helm-company company-active-map)
  ;;   (bind-key (kbd "<tab>") 'helm-company company-active-map)
  ;;   )
#+end_src

#+RESULTS:
: t

I think that I need to do the following to remove some errors.

#+BEGIN_SRC emacs-lisp
  ;;(evil-declare-change-repeat 'company-complete)
  ;;(evil-declare-change-repeat 'helm-company)
#+END_SRC

#+RESULTS:
: change

** descbinds
   
A helm interface to this.

#+BEGIN_SRC emacs-lisp
  ;;(use-package helm-descbinds
  ;;  :ensure t
  ;;  :config
  ;;  (helm-descbinds-mode))
#+END_SRC

#+RESULTS:
: t


* Autocompletion
  
** hippie-expand version
   
#+BEGIN_SRC emacs-lisp

  (setq hippie-expand-try-functions-list '(yas-hippie-try-expand try-complete-file-name-partially try-complete-file-name try-expand-all-abbrevs try-expand-list try-expand-line try-expand-dabbrev try-expand-dabbrev-all-buffers try-expand-dabbrev-from-kill try-complete-lisp-symbol-partially try-complete-lisp-symbol))

  ;;(global-set-key (kbd "<tab>") 'hippie-expand)
  ;;(global-set-key (kbd "TAB") 'hippie-expand)

  (bind-key (kbd "TAB") 'hippie-expand prog-mode-map)
  (bind-key (kbd "TAB") 'hippie-expand text-mode-map)
  (bind-key (kbd "<tab>") 'hippie-expand prog-mode-map)
  (bind-key (kbd "<tab>") 'hippie-expand text-mode-map)
  (bind-key (kbd "TAB") 'hippie-expand org-mode-map)
  (bind-key (kbd "<tab>") 'hippie-expand org-mode-map)
#+END_SRC

#+RESULTS:
: hippie-expand

  
** Company mode
  
Enable company mode in all buffers

#+begin_src emacs-lisp
  ;; (use-package company
  ;;   :ensure t
  ;;   :init
  ;;   (setq company-idle-delay 0)
  ;;   (setq company-minimum-prefix-length 2)
  ;;   (setq company-selection-wrap-around t)
  ;;   :config
  ;;   (add-hook 'after-init-hook 'global-company-mode)
  ;;   )
#+end_src

#+RESULTS:

** Tab and go
   

   
Use tab key to cycle through suggestions.
('=tng=' means 'tab and go')

#+BEGIN_SRC emacs-lisp
  ;; (eval-after-load 'company
  ;;   '(progn
  ;;      (company-tng-configure-default)
  ;;      (define-key company-active-map (kbd "TAB") 'company-select-next)
  ;;      (define-key company-active-map (kbd "<backtab>") 'company-select-previous)
  ;;      (define-key company-active-map (kbd "RET") nil)
  ;;      )
  ;;   )


  ;; (with-eval-after-load 'company
  ;;   (company-tng-configure-default)
  ;;   )
#+END_SRC

#+RESULTS:
: company-select-previous

** Configure backends

An annoying thing is that often dabbrev isn't activated unless I do the following hack.

#+begin_src emacs-lisp
  ;;(setq company-backends '((company-bbdb company-nxml company-css company-eclim company-semantic company-clang company-xcode company-cmake company-capf company-files company-dabbrev-code company-gtags company-etags company-keywords company-oddmuse company-dabbrev company-yasnippet)))

  ;; (with-eval-after-load 'company
  ;;   ;;(setq company-dabbrev-code-everywhere t)
  ;;   ;;(setq company-backends '(company-capf company-dabbrev-code))
  ;;   (setq company-backends '(company-dabbrev-code))
  ;;   )

#+end_src

#+RESULTS:
| company-capf | company-dabbrev-code | company-dabbrev |

** Sorting
   
I want to sort by occurance I think.

#+begin_src emacs-lisp
  ;; (setq company-transformers '(company-sort-by-occurrence))
#+end_src

** dabbrev
   
There is also a =dabbrev= function which I might want to call instead of the full autocomplete sometimes.

#+BEGIN_SRC emacs-lisp
  (bind-key (kbd "M-SPC") 'dabbrev-expand)
#+END_SRC

#+RESULTS:
: dabbrev-expand

* Yasnippets
  
For now, don't use the snippet collection package.

Instead, when I want a snippet, use that as a reference, and put in my snippets directory.
  
#+begin_src emacs-lisp
  (use-package yasnippet                  ; Snippets
    :ensure t
    :config
    ;; (use-package yasnippet-snippets         ; Collection of snippets
    ;;   :ensure t)
    (yas-global-mode t)
    (add-to-list #'yas-snippet-dirs "~/.emacs.d/snippets")
    (yas-reload-all)
    )

#+end_src

#+RESULTS:
: t

#+RESULTS:

* Undo-tree
  
*TODO* figure this package out.

#+BEGIN_SRC emacs-lisp
  (use-package undo-tree
    :init (undo-tree-mode)
    :config (setq undo-tree-auto-save-history t))
#+END_SRC

#+RESULTS:
: t

* Shell pop
  
#+BEGIN_SRC emacs-lisp
  ;; (use-package shell-pop
  ;;   :ensure t
  ;;   :init
  ;;   (setq shell-pop-term-shell "/bin/bash")
  ;;   (setq shell-pop-full-span t)
  ;;   (setq shell-pop-window-position "bottom")
  ;;   :config
  ;;   (with-eval-after-load 'evil-leader
  ;;     (evil-leader/set-key
  ;;       "t" 'shell-pop))
  ;;   )
#+END_SRC

#+RESULTS:
: t

For some reason the first time there is a shell pop something weird happens.  Then, it works after that.  I guess just ignore it because it is convenient when it works.

*TODO*. Figure out why this is the case.

* Buffer move
  
#+BEGIN_SRC emacs-lisp
  (use-package buffer-move
    :ensure t
    :config
    (eval-after-load 'evil
      '(progn
         (define-key evil-normal-state-map (kbd "C-S-h") #'buf-move-left)
         (define-key evil-normal-state-map (kbd "C-S-j") #'buf-move-down)
         (define-key evil-normal-state-map (kbd "C-S-k") #'buf-move-up)
         (define-key evil-normal-state-map (kbd "C-S-l") #'buf-move-right)
         (with-eval-after-load 'evil-maps
           '(progn
              (define-key evil-window-map (kbd "C-S-h") #'buf-move-left)
              (define-key evil-window-map (kbd "C-S-h") #'buf-move-down)
              (define-key evil-window-map (kbd "C-S-h") #'buf-move-up)
              (define-key evil-window-map (kbd "C-S-h") #'buf-move-right)
              )
           )
         )
      )
    )
#+END_SRC

#+RESULTS:
: t


* Today's date
  
#+begin_src emacs-lisp
  (defun my/insert-todays-date (arg)
    (interactive "P")
    (insert (format-time-string "%a %b %d %Y")))

  (evil-leader/set-key
    "G" 'my/insert-todays-date)
#+end_src

#+RESULTS:
* Buffer management
  
Sometimes I might want to flip through buffers.  This gives really convenient keys for doing this.  (Currently, use my up and down keys to navigate.)  Or, call =helm-mini=.  Or, call classic =buffer-menu=.
  
#+BEGIN_SRC emacs-lisp
  (eval-after-load 'hydra
    '(progn
       (defhydra my/hydra-buffers ()
         "navigate buffers"
         ("k" previous-buffer "prev")
         ("j" next-buffer "next")
         ;;("b" helm-mini "helm-mini" :color blue)
         ;;("B" buffer-menu "buffer-menu" :color blue)
         ("b" buffer-menu "buffer-menu" :color blue)
         )
       (with-eval-after-load 'evil-leader
         (evil-leader/set-key
           "b" 'my/hydra-buffers/body))
       ) 
    )
    #+END_SRC

    #+RESULTS:

* Indent guide
  
This is a thing that draws indent lines.  I don't want it on all the time I think: only bring it out when I need it.
  
#+BEGIN_SRC emacs-lisp
  (use-package indent-guide
    :ensure t
    :config
    ;;(indent-guide-global-mode)
    (set-face-background 'indent-guide-face "yellow")
    (setq indent-guide-delay 0.1))
#+END_SRC

#+RESULTS:
: t

* vimish folds
  
The commands ='vimish-unfold-all= and ='vimish-refold-all= are also useful.
  
#+BEGIN_SRC emacs-lisp
  (use-package vimish-fold
    :ensure t
    :config
    (with-eval-after-load 'evil-leader
      (evil-leader/set-key
        "f" #'vimish-fold
        "F" #'vimish-fold-delete
        )))
#+END_SRC

#+RESULTS:
: t

* Miscellaneous
  
** Buffers match newest version
   
#+begin_src emacs-lisp
  (global-auto-revert-mode t)
#+end_src

** "yes or no"
  
Don't ask me to type the whole word "yes" or "no".

#+begin_src emacs-lisp
  (fset 'yes-or-no-p 'y-or-n-p)
#+end_src

** Server
   
I always want to start a server.

#+begin_src emacs-lisp
  (server-start)
#+end_src

** Open new window
   
Try the following shortcut.

#+begin_src emacs-lisp
  (with-eval-after-load 'bind-key
    (bind-key* (kbd "C-M-e") #'make-frame)
    )
#+end_src

#+RESULTS:

** Spaces instead of tabs
   
Probably just better this way: makes alignment unambiguous.
   
#+begin_src emacs-lisp
  (setq-default indent-tabs-mode nil)
#+end_src

*Note*. To replace the tabs with spaces in a region (example: mark entire buffer) call the function =untabify=.

* Wishlist
  
#+RESULTS:
: dabbrev-expand

- try ivy instead of helm ??
- swiper helm??
- why is olivetti so slow?
- Figure out all the visual lines things
- organize snippets more
- make-it-so extension: could use to faciliate ffmpeg stuff
- shell-pop doesn't work nicely on the first run
