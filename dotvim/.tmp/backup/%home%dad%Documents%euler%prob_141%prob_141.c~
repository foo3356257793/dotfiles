#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <math.h>
#include <uthash.h>
#include <omp.h>

/*
 * Bringing in this hash table implementation
 */
struct hash_struct {
    int64_t id; /* each entry is an int64_t for this table */
    /* key */
    char name[10];
    UT_hash_handle hh;
};

// instructions are to add this thing here
struct hash_struct *hash_table = NULL;

// function to find if a value is in the table
struct hash_struct *find_key(int64_t key_id) {
    struct hash_struct *s;

    HASH_FIND_INT( hash_table, &key_id, s );

    return s;
}

// function to add a value to the hash table
void add_int(int64_t key_id)
{
    struct hash_struct *key = (struct hash_struct *) malloc(sizeof (struct hash_struct));
    key->id = key_id;
    HASH_ADD_INT( hash_table, id, key);
}

int is_square(int64_t n)
{
    double sqrt_n = sqrt(n);
    int64_t sqrt_n_int = (int64_t) round(sqrt_n);

    return n == (sqrt_n_int * sqrt_n_int);
}

/*
 * Stuff to optimize:
 *
 * make parallel
 */

int main(int argc, char *argv[])
{

    int64_t sum = 0;

    //max_print = 16;
    //num_print = 0;

    int64_t *prog_squares = (int64_t *) malloc((1<<16) * sizeof(int64_t));
    int num_squares = 0;

    #pragma omp parallel for
    for(int64_t p=1; p<=10000; p++)
    {
        for(int64_t q=1; q<p; q++)
        {
            // a^2*p^3*q + a*q^2
            int64_t c_2 = p*p*p*q;
            int64_t c_1 = q*q;
            int64_t a = 1;
            int64_t n = c_2*a*a + c_1*a;
            while(n < 1000000000000)
            //while(n < 100000)
            {
                if(is_square(n))
                {
                    if(find_key(n) == NULL)
                    {
                        #pragma omp critical
                        {
                                add_int(n);
                                sum += n;
                        }
                    }
                }
                a += 1;
                n = c_2*a*a + c_1*a;
            }
        }
    }

    printf("sum = %ld\n", sum);

    free(prog_squares);


}

