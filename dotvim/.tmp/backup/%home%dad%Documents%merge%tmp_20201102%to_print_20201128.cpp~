class Fmpz
{
  public:
    fmpz_t number;

    Fmpz();
    Fmpz(const int64_t& in_number);
    Fmpz(const fmpz_t& in_number);
    Fmpz(const string in_string);
    Fmpz(const Fmpz &other);
    Fmpz(Fmpz&& other) noexcept; // move constructor

    Fmpz& operator=(const Fmpz &other);
    Fmpz& operator=(const int64_t &other);
    Fmpz& operator=(Fmpz &&other) noexcept; // move assignment

    ~Fmpz();

    Fmpz& operator+=(const Fmpz& rhs);
    Fmpz operator+(const Fmpz &rhs) const;
    Fmpz& operator-=(const Fmpz &rhs);
    Fmpz operator-(const Fmpz &rhs) const;
    Fmpz operator-() const;
    Fmpz& operator*=(const Fmpz &rhs);
    Fmpz operator*(const Fmpz &rhs) const;
    Fmpz& operator%=(const Fmpz &rhs);
    Fmpz operator%(const Fmpz &rhs) const;
    Fmpz& operator/=(const Fmpz &rhs);
    Fmpz operator/(const Fmpz &rhs) const;

    void addmul(const Fmpz &in0, const Fmpz &in1);
    void submul(const Fmpz &in0, const Fmpz &in1);

    bool is_divisible_by(const Fmpz& poss_factor) const;
};

Fmpz::Fmpz(Fmpz&& other) noexcept : Fmpz() {
  swap(number,other.number);
}
Fmpz& Fmpz::operator=(Fmpz &&other) noexcept {
  swap(number,other.number);
  return *this;
}

ostream& operator<<(ostream& os, const Fmpz& f);

Fmpz pow(Fmpz base, int64_t exponent);
Fmpz abs(const Fmpz& in);
bool is_prime(const Fmpz& in);

// Fmpq similar header
Fmpq operator+(const Fmpz &lhs, const Fmpq &rhs);
Fmpq operator-(const Fmpz &lhs, const Fmpq &rhs);
Fmpq operator*(const Fmpz &lhs, const Fmpq &rhs);
Fmpq operator/(const Fmpz &lhs, const Fmpq &rhs);
bool operator==(const Fmpz &lhs, const Fmpq &rhs);
bool operator!=(const Fmpz &lhs, const Fmpq &rhs);
bool operator<(const Fmpz &lhs, const Fmpq &rhs);
bool operator<=(const Fmpz &lhs, const Fmpq &rhs);
bool operator>=(const Fmpz &lhs, const Fmpq &rhs);
bool operator>(const Fmpz &lhs, const Fmpq &rhs);
auto pow(Fmpq base, int64_t exponent);

// FmpzMat similar

class FmpzMat {
  public:
    fmpz_mat_t mat;

    auto nrows() const { return mat->r; }
    auto ncols() const { return mat->c; }

    FmpzMat(int nrows, int ncols) {
      fmpz_mat_init(mat,nrows,ncols);
    }

    auto operator()(const int& row, const int& col) const {
      if((row<0) || (col<0) || (row>=nrows()) || (col>=ncols())) {
        throw invalid_argument("Out of bounds matrix access");
      }

      auto entry = fmpz_mat_entry(mat, row, col);
      return entry;
    }

    auto operator[](const tuple<int,int>& row_col) const {
      const auto[row,col] = row_col;
      auto result = Fmpz();
      fmpz_set(result.number,(*this)(row,col));
      return result;
    }

    FmpzMat(const vector<vector<Fmpz>>& mat_as_vectors) {
      size_t nrows = mat_as_vectors.size();
      size_t ncols;
      if(nrows == 0) { ncols = 0; }
      else { ncols = mat_as_vectors[0].size(); }

      fmpz_mat_init(mat,nrows,ncols);

      for(size_t row = 0; row<nrows; row++) {
        if(mat_as_vectors[row].size() != ncols) {
          throw invalid_argument("list of vectors not a matrix!");
        }
        for(size_t col = 0; col<ncols; col++) {
          fmpz_set((*this)(row,col),mat_as_vectors[row][col].number);
        }
      }
    }

    bool dim_match(const FmpzMat &other) {
      return ((nrows() == other.nrows()) && (ncols() == other.ncols()));
    }

    FmpzMat& operator=(const FmpzMat &other) {
      if(!dim_match(other)) {
        // clear and reallocate
        fmpz_mat_clear(mat);
        fmpz_mat_init_set(mat,other.mat);
        return *this;
      }
      fmpz_mat_set(mat,other.mat);
      return *this;
    }

    auto det() {
      auto result = Fmpz();
      fmpz_mat_det(result.number, mat);
      return result;
    }

    auto swap_rows(const int& i, const int& j) {
      const auto num_rows = nrows();
      if(i<0 || j<0 || i>=num_rows || j>=num_rows){
        throw invalid_argument("indices out of bounds");
      }
      fmpz_mat_swap_rows(mat, NULL, i, j);
    }

    auto add_a_times_row_b_to_row_c(const Fmpz& a, const int& b, const int& c) {
      const auto num_rows = nrows();
      const auto num_cols = ncols();

      if(b<0 || c<0 || b>=num_rows || c>=num_rows){
        throw invalid_argument("indices out of bounds");
      }
      for(int col=0; col<num_cols; col++)
      {
        fmpz_addmul((*this)(c,col),a.number,(*this)(b,col));
      }
    }

    tuple<bool,tuple<int,int>> dim_block_mat_valid(vector<vector<FmpzMat>> block_mat) {
      const auto fail = tuple(false, tuple(0,0));
      if(block_mat.size() == 0) return fail;
      int nrows = 0;
      int ncols = 0;
      for(const auto &vec : block_mat) {
        if(vec.size() == 0) return fail;

        int vec_nrows = 0;
        int vec_ncols = 0;
        for(const auto &mat : vec) {
          if(vec_nrows == 0) vec_nrows = mat.nrows();
          else if(vec_nrows != mat.nrows()) return fail;

          vec_ncols += mat.ncols();
        }

        // dim 0 bad
        if(vec_nrows == 0) return fail;
        if(vec_ncols == 0) return fail;

        if(ncols == 0) ncols = vec_ncols;
        else if(ncols != vec_ncols) return fail;

        nrows += vec_nrows;
      }
      return tuple(true, tuple(nrows,ncols));
    }

    auto block_matrix(vector<vector<FmpzMat>> block_mat) {
      // verify that the dimensions are good
      const auto[valid,dims] = dim_block_mat_valid(block_mat);
      const auto[nrows,ncols] = dims;

      if(!valid) {
        throw invalid_argument("invalid dimensions for a block matrix");
      }

      auto result = FmpzMat(nrows,ncols);

      int row_offset = 0;
      for(auto &block_row : block_mat) {
        int col_offset = 0;
        const int nrows_block = block_row[0].nrows();
        for(const auto &block : block_row) {
          const int ncols_block = block.ncols();
          for(int row=0; row<nrows_block; row++) {
            for(int col=0; col<ncols_block; col++) {
              //fmpz_set(fmpz_mat_entry(result.mat,row_offset+row,col_offset+col),fmpz_mat_entry(block.mat,row,col));
              fmpz_set(result(row_offset+row,col_offset+col),block(row,col));
            }
          }
          col_offset += ncols_block;
        }
        row_offset += nrows_block;
      }

      return result;
    }

    auto zero_matrix(int nrows, int ncols) {
      if((nrows<0) || (ncols<0)){
        throw invalid_argument("negative dimension for zero_matrix not defined");
      }

      auto result = FmpzMat(nrows,ncols);
      fmpz_mat_zero(result.mat);
      return result;
    }

    auto identity_matrix(int dim) {
      if(dim < 0){
        throw invalid_argument("negative dimension for identity_matrix not defined");
      }
      auto result = FmpzMat(dim,dim);
      fmpz_mat_one(result.mat);
      return result;
    }

};

// FmpqMat similar

template<typename T>
class Factorization {
  public:
    vector<tuple<T,int64_t>> prime_factors;
    vector<tuple<T,int64_t>> other_factors;

    Factorization();
    Factorization(const T& in);
    Factorization(const vector<tuple<T,int64_t>>& in);
    Factorization(const Factorization<T>& other);

    Factorization<T>& operator=(const Factorization<T>& other);

    Factorization<T>& operator*=(const Factorization<T>& rhs);
    Factorization<T>& operator*(const Factorization<T>& rhs) const;

    Factorization<T>& operator/=(const Factorization<T>& rhs);
    Factorization<T>& operator/(const Factorization<T>& rhs) const;

    T product() const;
};

  template <typename T>
Factorization<T>::Factorization() {
  prime_factors = {};
  other_factors = {};
}

  template <typename T>
Factorization<T>::Factorization(const Factorization<T>& other) {
  prime_factors = other.prime_factors;
  other_factors = other.other_factors;
}

  template <typename T>
Factorization<T>& Factorization<T>::operator=(const Factorization<T>& other) {
  prime_factors = other.prime_factors;
  other_factors = other.other_factors;
  return *this;
}

auto print_factor_array(ostream &os, vector<tuple<Fmpz,int64_t>> in, bool include_times) {

  for(auto &tup : in) {
    auto[base, exponent] = tup;

    if(exponent == 0) continue;

    if(include_times) {
      os << " * ";
    }
    include_times = true;

    os << base;

    if(exponent != 1) {
      os << "^" << exponent;
    }
  }

  return include_times;
}

ostream& operator<<(ostream& os, const Factorization<Fmpz>& factors) {
  if((factors.prime_factors.size() + factors.other_factors.size()) == 0) {
    os << "1";
    return os;
  }

  bool include_times = false;

  include_times = print_factor_array(os, factors.prime_factors, include_times);
  include_times = print_factor_array(os, factors.other_factors, include_times);

  return os;
}


class Factor {
  public:
    fmpz_factor_t data;
    slong bits;

    Factor();
    Factor(slong in_bits);

    // do not duplicate a factor object
    Factor(const Factor &other) = delete;
    Factor& operator=(const Factor &other) = delete;

    Factorization<Fmpz> operator()(const Fmpz& in);

    ~Factor();
};

Factor::Factor(int64_t in) {
  fmpz_factor_init(data);
  bits = in;
}

Factor::Factor() : Factor(15L) {}; // default param

Factor::~Factor() {
  fmpz_factor_clear(data);
}

template <typename T>
void sort_factorization_vec(vector<tuple<T,int64_t>>& vec) {

  sort(vec.begin(), vec.end(), [](tuple<T,int64_t>& a, tuple<T,int64_t>& b){
      auto[a_fac,a_exponent] = a;
      auto[b_fac,b_exponent] = b;
      return a_fac < b_fac;
      });
}


  template <typename T>
void Factorization<T>::sort()
{
  sort_factorization_vec(prime_factors);
  sort_factorization_vec(other_factors);
}

Factorization<Fmpz> Factor::operator()(const Fmpz& in)
{
  int success = fmpz_factor_smooth(data,in.number,bits,0);

  auto num_factors = data->num;
  auto result = Factorization<Fmpz>();

  auto remainder = abs(in);

  for(int index=0; index<num_factors; index++)
  {
    auto fac = Fmpz();
    fmpz_factor_get_fmpz(fac.number, data, index);

    int64_t exponent = 0;
    while(remainder.is_divisible_by(fac))
    {
      remainder /= fac;
      exponent++;
    }

    if(exponent == 0) continue;

    const auto tup = tuple(fac,exponent);

    if((success==1) || index<num_factors-1) {
      result.prime_factors.push_back(tup);
    }
    else {
      result.other_factors.push_back(tup);
    }
  }

  if(remainder != 1)
  {
    result.other_factors.push_back(tuple(remainder,1));
  }

  result.sort();

  return result;
}

ostream& operator<<(ostream& os, const Factor& f) {
  os << "Factor class element (bits = " << f.bits << ")";
  return os;
}

template <>
Fmpz Factorization<Fmpz>::product() const
{
  auto result = Fmpz(1);

  for(const auto[base,exponent] : prime_factors) {
    result *= pow(base,exponent);
  }
  for(const auto[base,exponent] : other_factors) {
    result *= pow(base,exponent);
  }

  return result;
}

  template <typename T>
auto merge_factorization_vectors(
    const vector<tuple<T,int64_t>>& in_0,
    const vector<tuple<T,int64_t>>& in_1,
    function<auto(vector<tuple<T,int64_t>>&)> push_0,
    function<auto(vector<tuple<T,int64_t>>&)> push_1,
    function<int64_t(int64_t,int64_t)> combine)
{

  auto it_0 = in_0.begin();
  const auto end_0 = in_0.end();

  auto it_1 = in_1.begin();
  const auto end_1 = in_1.end();

  vector<tuple<T,int64_t>> result = {};

  while(it_0 < end_0 && it_1 < end_1) {
    const auto[number_0,exponent_0] = *it_0;
    const auto[number_1,exponent_1] = *it_1;

    if(number_0 < number_1) {
      result.push_back(push_0(*it_0));
      ++it_0;
    }
    else if(number_0 > number_1) {
      result.push_back(push_1(*it_1));
      ++it_1;
    }
    else {
      auto exponent = combine(exponent_0,exponent_1);
      if(exponent != 0) {
        result.push_back(push_0(tuple(number_0,exponent)));
      }
      ++it_0;
      ++it_1;
    }
  }

  // insert leftovers
  // at least one of these does nothing
  while(it_0 < end_0) {
    result.push_back(push_0(*it_0));
    ++it_0;
  }
  while(it_1 < end_1) {
    result.push_back(push_1(*it_1));
    ++it_1;
  }

  return result;
}

  template <typename T>
vector<tuple<T,int64_t>> merge_factorization_vectors(
    const vector<tuple<T,int64_t>>& in_0,
    const vector<tuple<T,int64_t>>& in_1,
    function<auto(vector<tuple<T,int64_t>>&)> push_1,
    function<int64_t(int64_t,int64_t)> combine)
    { return merge_factorization_vectors(in_0,in_1,push_1,push_1,combine); }

  template <typename T>
vector<tuple<T,int64_t>> merge_factorization_vectors(
    const vector<tuple<T,int64_t>>& in_0,
    const vector<tuple<T,int64_t>>& in_1,
    function<auto(vector<tuple<T,int64_t>>&)> push_1)
{ return merge_factorization_vectors(in_0,in_1,push_1,push_1,[](int64_t& a,int64_t& b){return a+b}); }

template<typename T>
Factorization<T>& Factorization<T>::operator*=(const Factorization &rhs) {
  prime_factors = merge_factorization_vectors(prime_factors,rhs.prime_factors);
  other_factors = merge_factorization_vectors(other_factors,rhs.other_factors);
  return *this;
}

template<typename T>
Factorization<T> Factorization<T>::operator*(const Factorization &rhs) const {
  auto result = Factorization<T>();
  result.prime_factors = merge_factorization_vectors(prime_factors,rhs.prime_factors);
  result.other_factors = merge_factorization_vectors(other_factors,rhs.other_factors);
  return *this;
}

template<typename T>
Factorization<T>& Factorization<T>::operator/=(const Factorization &rhs) {
  prime_factors = merge_factorization_vectors(prime_factors,rhs.prime_factors,-1);
  other_factors = merge_factorization_vectors(other_factors,rhs.other_factors,-1);
  return *this;
}

template<typename T>
Factorization<T> Factorization<T>::operator/(const Factorization &rhs) const {
  auto result = Factorization<T>();
  result.prime_factors = merge_factorization_vectors(prime_factors,rhs.prime_factors,-1);
  result.other_factors = merge_factorization_vectors(other_factors,rhs.other_factors,-1);
  return *this;
}

TEST(Tests, TestDivision) {
  EXPECT_EQ(A,B);
}

int main(int argc, char *argv[]) {

  ::testing::InitGoogleTest(&argc, argv);
  return RUN_ALL_TESTS();
}
