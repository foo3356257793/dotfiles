#pragma once

#include "myflint_ZZ.hpp"
#include <flint/fmpz_mat.h>

struct ZZ_vec_ptr {
  fmpz* row;

  ZZ_vec_ptr(fmpz* in_row) : row(in_row) {}

  ZZ_ptr operator[](const int col) const {
    return row + col;
  }
};

struct ZZ_mat {

  fmpz_mat_t data;

  explicit operator fmpz_mat_struct*() { return (fmpz_mat_struct*) data; }
  explicit operator const fmpz_mat_struct*() const { return (const fmpz_mat_struct*) data; }

  slong nrows() const;
  slong ncols() const;

  // get entries
  fmpz* operator()(const int& row, const int& col) const;
  ZZ_mat& operator()(const int& row, const int& col, const ZZ& in);
  ZZ_mat& operator()(const int& row, const int& col, ZZ&& in);
  ZZ_vec_ptr operator[](const int row) const;

  ZZ_mat(int nrows, int ncols);
  ZZ_mat();

  template <typename T>
    ZZ_mat(const vector<vector<T>>& mat_as_vectors);

  ZZ_mat(const fmpz_mat_t other);
  ZZ_mat(const ZZ_mat& other);
  ZZ_mat(ZZ_mat &&other) noexcept;

  bool dim_match(const ZZ_mat &other);

  ZZ_mat& operator=(const ZZ_mat &other);
  ZZ_mat &operator=(ZZ_mat &&other) noexcept;
  ~ZZ_mat();

  ZZ_mat &apply_fmpz_mat_fun_eq(const ZZ_mat &rhs,
      const function<void(fmpz_mat_t, fmpz_mat_t, const fmpz_mat_t)>& fun);
  ZZ_mat &apply_fmpz_mat_fun_eq(const ZZ& rhs,
      const function<void(fmpz_mat_t, fmpz_mat_t, const fmpz_t)>& fun);


  ZZ_mat& operator+=(const ZZ_mat& rhs);
  ZZ_mat& operator-=(const ZZ_mat& rhs);
  ZZ_mat& operator*=(const ZZ_mat& rhs);
  ZZ_mat& operator*=(const ZZ& rhs);
  ZZ_mat& addmul(const ZZ& scalar, const ZZ_mat& other);
  ZZ_mat& addmul(const ZZ_mat& other, const ZZ& scalar);
  ZZ_mat& submul(const ZZ& scalar, const ZZ_mat& other);
  ZZ_mat& submul(const ZZ_mat& other, const ZZ& scalar);

  ZZ_mat operator+(const ZZ_mat& rhs);
  ZZ_mat operator-(const ZZ_mat& rhs);
  ZZ_mat operator-();
  ZZ_mat operator*(const ZZ_mat& rhs);
  ZZ_mat operator*(const ZZ& rhs) const;

  bool operator==(const ZZ_mat &rhs) const;
  bool operator==(const int64_t &rhs) const;
  bool operator==(const ZZ& rhs) const;

  auto to_string_vectors() const;
  ZZ_mat& transpose_inplace();
  auto swap_rows(const int& i, const int& j);
  auto add_a_times_row_b_to_row_c(const ZZ& a, const int& b, const int& c);

};


ZZ_mat apply_fmpz_mat_fun(const ZZ_mat &lhs, const ZZ_mat &rhs,
    const int& num_rows, const int& num_cols,
    const function<void(fmpz_mat_t, const fmpz_mat_t, const fmpz_mat_t)>& fun);

ZZ_mat apply_fmpz_mat_fun(const ZZ_mat &rhs,
    const int& num_rows, const int& num_cols,
    const function<void(fmpz_mat_t, const fmpz_mat_t)>& fun);

ZZ_mat apply_fmpz_mat_fun(const ZZ_mat &rhs,
    const function<void(fmpz_mat_t, const fmpz_mat_t)>& fun);

ZZ apply_fmpz_mat_fun(const ZZ_mat &rhs,
    const function<void(fmpz_t, const fmpz_mat_t)>& fun);

ZZ_mat apply_fmpz_mat_fun(const ZZ& rhs,
    const function<void(fmpz_mat_t, const fmpz_mat_t, const fmpz_t)>& fun) ;


ZZ_mat transpose(const ZZ_mat& in);
ZZ determinant(const ZZ_mat &in);

tuple<bool,tuple<int,int>> dim_block_mat_valid(vector<vector<ZZ_mat>> block_mat);
auto block_matrix(vector<vector<ZZ_mat>> block_mat);
auto zero_matrix(int nrows, int ncols);
auto identity_matrix(int dim);
size_t column_width(vector<vector<string>> string_vectors, size_t col);
std::vector<size_t> column_widths (vector<vector<string>> string_vectors);

ostream& operator<<(ostream& os, const ZZ_mat& f);
