#include <pybind11/pybind11.h>
#include <pybind11/stl.h>
#include <pybind11/complex.h>

#include <pybind11/functional.h>
#include <pybind11/chrono.h>

namespace py = pybind11;

#include <any>
#include <map>
#include <string>
#include <vector>
#include <sstream>
#include <memory>

using namespace std;

#include <iterator> // needed for ostram_iterator

template <typename T>
ostream& operator<< (ostream& out, const vector<T>& v) {
  if ( !v.empty() ) {
    out << '[';
    copy (v.begin(), v.end(), ostream_iterator<T>(out, ", "));
    out << "\b\b]";
  }
  return out;
}


struct Bar{
  vector<double> d;
  vector<double> e;
};

ostream& operator<< (ostream& out, const Bar &bar){
  out << "Bar:" << endl;
  out << "  d: " << bar.d << endl;
  out << "  e: " << bar.e;

  return out;
}

struct Foo{
  int a;
  int b;
  Bar c;
};

ostream& operator<< (ostream& out, const Foo &foo){
  out << "Foo:" << endl;
  out << "  a: " << foo.a << endl;
  out << "  b: " << foo.b << endl;
  out << "c:" << foo.c;

  return out;
}

template <typename T>
string repr(const T &in){
  stringstream ss;
  ss << in << endl;

  return ss.str();
}

int bits[2][2] = {{0,1},{1,0}};

struct Table {
  size_t size;
  unique_ptr<double[]> data;

  Table() : size(0) {}

  Table(const vector<double> &in_data) :
  size(in_data.size()),
  data(make_unique<double[]>(in_data.size()))
  {
    for(size_t i=0; i<in_data.size(); i++){
      data[i] = in_data[i];
    }
  }

  tuple<double,double> twist(double a, double b){
    if(size == 0) return tuple(0,0);
    if(size == 1) return tuple(a*data[0],0);

    return tuple(a * bits[0][0] + b * bits[0][1], a * bits[1][0] + b * bits[1][1]);
  }
};

PYBIND11_MODULE(foobar, m) {
  m.doc() = "pybind11 example plugin"; // docstring

  py::class_<Bar>(m, "Bar")
    .def(py::init<>())
    .def_readwrite("d", &Bar::d)
    .def_readwrite("e", &Bar::e)
    .def("__repr__", &repr<Bar>)
    ;

  py::class_<Foo>(m, "Foo")
    .def(py::init<>())
    .def_readwrite("a", &Foo::a)
    .def_readwrite("b", &Foo::b)
    .def_readwrite("c", &Foo::c)
    .def("__repr__", &repr<Foo>)
    ;

  py::class_<Table>(m, "Table")
    .def(py::init<>())
    .def(py::init<vector<double>>())
    .def("twist", &Table::twist)
    ;

}
