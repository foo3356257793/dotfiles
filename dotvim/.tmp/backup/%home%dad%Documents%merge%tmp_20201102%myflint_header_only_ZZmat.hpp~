#pragma once

#include "myflint_header_only_ZZ.hpp"
#include <flint/fmpz_mat.h>

class ZZmat {

  public:
    fmpz_mat_t mat;

    auto nrows() const { return mat->r; }
    auto ncols() const { return mat->c; }

    // get entries
    auto operator()(const int& row, const int& col) const {
      if((row<0) || (col<0) || (row>=nrows()) || (col>=ncols())) {
        throw invalid_argument("Out of bounds matrix access");
      }

      auto entry = fmpz_mat_entry(mat, row, col);
      return entry;
    }

    auto operator[](const tuple<int,int>& row_col) const {
      const auto[row,col] = row_col;
      auto result = ZZ();
      fmpz_set(result.number,(*this)(row,col));
      return result;
    }

    ZZmat(int nrows, int ncols) {
      fmpz_mat_init(mat,nrows,ncols);
    }

    ZZmat() : ZZmat(0,0) {};

    template <typename T>
    ZZmat(const vector<vector<T>>& mat_as_vectors,
        function<void(fmpz_t,const T&)> set_fun)
    {
      size_t nrows = mat_as_vectors.size();
      size_t ncols;
      if(nrows == 0)
      {
        ncols = 0;
      }
      else
      {
        ncols = mat_as_vectors[0].size();
      }

      fmpz_mat_init(mat,nrows,ncols);

      for(size_t row = 0; row<nrows; row++) {
        if(mat_as_vectors[row].size() != ncols) {
          throw invalid_argument("list of vectors not a matrix!");
        }
        for(size_t col = 0; col<ncols; col++) {
          set_fun((*this)(row,col),mat_as_vectors[row][col]);
        }
      }
    }

    ZZmat(const vector<vector<int64_t>>& mat_as_vectors) :
      ZZmat(mat_as_vectors,
          (function<void(fmpz_t,const int64_t&)>)
            [](fmpz_t out, const int64_t& in){
          return fmpz_set_si(out,in);
          })
      {};

    ZZmat(const vector<vector<ZZ>>& mat_as_vectors) :
      ZZmat(mat_as_vectors,
          (function<void(fmpz_t,const ZZ&)>)
          [](fmpz_t out, const ZZ& in){
          return fmpz_set(out,in.number);
          })
      {};

    ZZmat(const vector<vector<string>>& mat_as_vectors) :
      ZZmat(mat_as_vectors,
          (function<void(fmpz_t,const string&)>)
          [](fmpz_t out, const string& in){
          return fmpz_set_str(out,in.c_str(),10);
          })
    {};

    ZZmat(const fmpz_mat_t other) {
      fmpz_mat_init_set(mat,other);
    }

    ZZmat(const ZZmat& other) { // copy constructor
      fmpz_mat_init_set(mat,other.mat);
    }

    ZZmat(ZZmat &&other) noexcept : ZZmat() { // move constructor
      swap(mat, other.mat);
    }

    bool dim_match(const ZZmat &other) {
      return ((nrows() == other.nrows()) && (ncols() == other.ncols()));
    }

    ZZmat& operator=(const ZZmat &other) { // copy assignment
      if(!dim_match(other))
      {
        // clear and reallocate
        fmpz_mat_clear(mat);
        fmpz_mat_init_set(mat,other.mat);
        return *this;
      }

      fmpz_mat_set(mat,other.mat);
      return *this;
    }

    ZZmat &operator=(ZZmat &&other) noexcept { // move assignment
      swap(mat, other.mat);
      return *this;
    }

    ~ZZmat() { // destructor
      fmpz_mat_clear(mat);
    }

    auto &apply_fmpz_mat_fun_eq(const ZZmat &rhs,
        const function<void(fmpz_mat_t, fmpz_mat_t, const fmpz_mat_t)>& fun) {
      fun(mat, mat, rhs.mat);
      return *this;
    }

    auto apply_fmpz_mat_fun(const ZZmat &rhs,
        const int& num_rows, const int& num_cols,
        const function<void(fmpz_mat_t, const fmpz_mat_t, const fmpz_mat_t)>& fun) const {
      auto result = ZZmat(num_rows,num_cols);
      fun(result.mat, mat, rhs.mat);
      return result;
    }

    auto apply_fmpz_mat_fun(
        const int& num_rows, const int& num_cols,
        const function<void(fmpz_mat_t, const fmpz_mat_t)>& fun) const {
      auto result = ZZmat(num_rows,num_cols);
      fun(result.mat, mat);
      return result;
    }

    auto apply_fmpz_mat_fun(
        const function<void(fmpz_mat_t, const fmpz_mat_t)>& fun) const {
      return apply_fmpz_mat_fun(nrows(),ncols(),fun);
    }

    auto apply_fmpz_mat_fun(
        const function<void(fmpz_t, const fmpz_mat_t)>& fun) const {
      auto result = ZZ();
      fun(result.number, mat);
      return result;
    }

    // addition
    ZZmat& operator+=(const ZZmat& rhs)
    {
      if(!dim_match(rhs)) {
        throw invalid_argument("addition with unequal dimensions is undefined!");
      }
      return apply_fmpz_mat_fun_eq(rhs,fmpz_mat_add);
    }
    ZZmat operator+(const ZZmat& rhs)
    {
      if(!dim_match(rhs)) {
        throw invalid_argument("addition with unequal dimensions is undefined!");
      }
      return apply_fmpz_mat_fun(rhs,nrows(),ncols(),fmpz_mat_add);
    }

    ZZmat& operator-=(const ZZmat& rhs)
    {
      if(!dim_match(rhs)) {
        throw invalid_argument("subtraction with unequal dimensions is undefined!");
      }
      return apply_fmpz_mat_fun_eq(rhs,fmpz_mat_sub);
    }
    ZZmat operator-(const ZZmat& rhs)
    {
      if(!dim_match(rhs)) {
        throw invalid_argument("subtraction with unequal dimensions is undefined!");
      }
      return apply_fmpz_mat_fun(rhs,nrows(),ncols(),fmpz_mat_sub);
    }
    ZZmat operator-() { return apply_fmpz_mat_fun(fmpz_mat_neg); }

    // multiplication

    ZZmat operator*(const ZZmat& rhs)
    {
      if(ncols() != rhs.nrows()){
        throw invalid_argument("Incompatible dimensions for multiplication!");
      }
      return apply_fmpz_mat_fun(rhs,nrows(),rhs.ncols(),fmpz_mat_mul);
    }

    ZZmat& operator*=(const ZZmat& rhs)
    {
      if(ncols() != rhs.nrows()){
        throw invalid_argument("Incompatible dimensions for multiplication!");
      }

      if(rhs.ncols() != rhs.nrows()) {
        // have to create a temporary result
        auto result = *this * rhs;
        swap(result.mat,mat);
        return *this;
      }

      return apply_fmpz_mat_fun_eq(rhs,fmpz_mat_mul);
    }

    ZZmat &apply_fmpz_mat_fun_eq(const ZZ& rhs,
        const function<void(fmpz_mat_t, fmpz_mat_t, const fmpz_t)>& fun) {
      fun(mat, mat, rhs.number);
      return *this;
    }

    ZZmat apply_fmpz_mat_fun(const ZZ& rhs,
        const function<void(fmpz_mat_t, const fmpz_mat_t, const fmpz_t)>& fun) const {
      auto result = ZZmat(nrows(),ncols());
      fun(result.mat, mat, rhs.number);
      return result;
    }

    // scalar multiplication
    ZZmat& operator*=(const ZZ& rhs) {
      return apply_fmpz_mat_fun_eq(rhs, fmpz_mat_scalar_mul_fmpz);
    }

    ZZmat operator*(const ZZ& rhs) const {
      return apply_fmpz_mat_fun(rhs, fmpz_mat_scalar_mul_fmpz);
    }

    // addmul and submul with scalars
    auto addmul(const ZZ& scalar, const ZZmat& other) {
      if(!dim_match(other)){
        throw invalid_argument("incompatible dimensions on addmul!");
      }
      fmpz_mat_scalar_addmul_fmpz(mat, other.mat, scalar.number);
    }
    auto addmul(const ZZmat& other, const ZZ& scalar){addmul(scalar,other);}
    auto submul(const ZZ& scalar, const ZZmat& other) {
      if(!dim_match(other)){
        throw invalid_argument("incompatible dimensions on submul!");
      }
      fmpz_mat_scalar_submul_fmpz(mat, other.mat, scalar.number);
    }
    auto submul(const ZZmat& other, const ZZ& scalar){submul(scalar,other);}

    // comparison
    bool operator==(const ZZmat &rhs) {return fmpz_mat_equal(mat,rhs.mat);}
    bool operator==(const int64_t &rhs) {
      if(rhs != 0) {
        throw invalid_argument("Comparison to nonzero scalar not supported");
      }
      return fmpz_mat_is_zero(mat);
    }

    bool operator==(const ZZ& rhs) {
      if(!fmpz_is_zero(rhs.number)) {
        throw invalid_argument("Comparison to nonzero scalar not supported");
      }
      return fmpz_mat_is_zero(mat);
    }

    auto to_string_vectors() const
    {
      auto result = vector<vector<string>>();

      for(int row=0; row<nrows(); row++) {
        auto row_vec = vector<string>();
        for(int col=0; col<ncols(); col++) {
          stringstream ss;
          char *out_string = fmpz_get_str(NULL, 10, (*this)(row,col));
          ss << out_string;
          free(out_string);
          row_vec.push_back(ss.str());
        }
        result.push_back(row_vec);
      }

      return result;
    }


    auto transpose_inplace() {
      if(!fmpz_mat_is_square(mat)){
        throw invalid_argument("can only transpose in place on square matrices");
      }
      fmpz_mat_transpose(mat,mat);
    }

    auto swap_rows(const int& i, const int& j) {
      const auto num_rows = nrows();
      if(i<0 || j<0 || i>=num_rows || j>=num_rows){
        throw invalid_argument("indices out of bounds");
      }
      fmpz_mat_swap_rows(mat, NULL, i, j);
    }

    auto add_a_times_row_b_to_row_c(const ZZ& a, const int& b, const int& c) {
      const auto num_rows = nrows();
      const auto num_cols = ncols();

      if(b<0 || c<0 || b>=num_rows || c>=num_rows){
        throw invalid_argument("indices out of bounds");
      }
      for(int col=0; col<num_cols; col++)
      {
        fmpz_addmul((*this)(c,col),a.number,(*this)(b,col));
      }
    }

};

auto transpose(const ZZmat& in) {
  return in.apply_fmpz_mat_fun(in.ncols(),in.nrows(),fmpz_mat_transpose);
}

auto determinant(const ZZmat &in) {
  return in.apply_fmpz_mat_fun(fmpz_mat_det);
}

tuple<bool,tuple<int,int>> dim_block_mat_valid(vector<vector<ZZmat>> block_mat) {

  const auto fail = tuple(false, tuple(0,0));

  if(block_mat.size() == 0) return fail;

  int nrows = 0;
  int ncols = 0;
  for(const auto &vec : block_mat)
  {
    if(vec.size() == 0) return fail;

    int vec_nrows = 0;
    int vec_ncols = 0;
    for(const auto &mat : vec)
    {
      if(vec_nrows == 0) vec_nrows = mat.nrows();
      else if(vec_nrows != mat.nrows()) return fail;

      vec_ncols += mat.ncols();
    }

    // dim 0 bad
    if(vec_nrows == 0) return fail;
    if(vec_ncols == 0) return fail;

    if(ncols == 0) ncols = vec_ncols;
    else if(ncols != vec_ncols) return fail;

    nrows += vec_nrows;
  }

  return tuple(true, tuple(nrows,ncols));
}

auto block_matrix(vector<vector<ZZmat>> block_mat)
{
  // verify that the dimensions are good
  const auto[valid,dims] = dim_block_mat_valid(block_mat);
  const auto[nrows,ncols] = dims;

  if(!valid) {
    throw invalid_argument("invalid dimensions for a block matrix");
  }

  auto result = ZZmat(nrows,ncols);

  int row_offset = 0;
  for(auto &block_row : block_mat) {
    int col_offset = 0;
    const int nrows_block = block_row[0].nrows();
    for(const auto &block : block_row) {
      const int ncols_block = block.ncols();
      for(int row=0; row<nrows_block; row++) {
        for(int col=0; col<ncols_block; col++) {
          fmpz_set(result(row_offset+row,col_offset+col),block(row,col));
        }
      }
      col_offset += ncols_block;
    }
    row_offset += nrows_block;
  }

  return result;
}

auto zero_matrix(int nrows, int ncols)
{
  if((nrows<0) || (ncols<0)){
    throw invalid_argument("negative dimension for zero_matrix not defined");
  }

  auto result = ZZmat(nrows,ncols);
  fmpz_mat_zero(result.mat);
  return result;
}

auto identity_matrix(int dim)
{
  if(dim < 0){
    throw invalid_argument("negative dimension for identity_matrix not defined");
  }

  auto result = ZZmat(dim,dim);
  fmpz_mat_one(result.mat);
  return result;
}

auto column_width(vector<vector<string>> string_vectors, size_t col) {
  size_t max_val = 0;

  for(auto &vec : string_vectors) {
    if(vec.size() <= col) {
      throw invalid_argument("vector of vectors not a matrix");
    }

    max_val = max(max_val, vec[col].size());
  }

  return max_val;
}

auto column_widths (vector<vector<string>> string_vectors) {
  if(string_vectors.size() == 0)
  {
    throw invalid_argument("column_widths of empty vector undefined");
  }

  auto ncols = string_vectors[0].size();

  auto result = vector<size_t>(ncols);

  for(size_t col=0; col<ncols; col++) {
    result[col] = column_width(string_vectors,col);
  }

  return result;
}

ostream& operator<<(ostream& os, const ZZmat& f)
{

  if(f.nrows() == 0) {
    os << "[]";
    return os;
  }

  const auto string_vectors = f.to_string_vectors();
  const auto widths = column_widths(string_vectors);
  const auto nrows = f.nrows();
  const auto ncols = f.ncols();

  os << "[" << endl;
  for(int row=0; row<nrows; row++) {
    os << "  [";
    for(int col=0; col<ncols; col++) {
      os << setw(widths[col]);
      os << string_vectors[row][col];
      if(col != ncols-1) os << ", ";
    }
    os << "]";
    if (row != nrows-1) os << ",";
    os << endl;
  }
  os << "]";

  return os;
}
