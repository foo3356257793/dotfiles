#!/usr/bin/sage

import time

def check_slow_way(n):

    num_hit = 0
    for a in range((n//2)+1):

        b = n-a

        c = a & b

        if c == a:

            num_hit += 1

    return num_hit

def count_poss_by_carry(n_rem, in_carries, chunk_size):


    mask = (1<<chunk_size)-1

    if n_rem <= mask:

        ret = in_carries[0] * check_slow_way(n_rem)
        ret += in_carries[1] * check_slow_way(n_rem-1)

        return [ret,0], 0

    n_mod = n_rem & mask

    counts_0 = [0,0]

    for a in range(mask+2):

        b = (n_mod - a) & mask

        c = a&b

        if a==c:

            carry = (a+b) >> chunk_size

            counts_0[carry] += 1

    counts_1 = [0,0]

    n_mod = (n_mod-1) & mask

    for a in range(mask+2):

        b = (n_mod - a) & mask

        c = a&b

        if a==c:

            carry = (a+b+1) >> chunk_size

            counts_1[carry] += 1

    counts = [in_carries[0] * counts_0[i] + in_carries[1] * counts_1[i] for i in
            range(2)]

    return counts, n_rem >> chunk_size

def calculate_by_chunk(n, chunk_size):

    carries = [1,0] # init

    n_rem = n

    while n_rem > 0:

        carries, n_rem = count_poss_by_carry(n_rem, carries, chunk_size)

    return carries[0]

def branch_poss_sums(a,max_pow):

    if max_pow == 0:

        if a >= 0 and a <= 2:
            # exactly one way to decompose this into 1s
            return 1

        else:
            # not proper
            return 0

    pow_2 = 2**max_pow

    max_proper_followup = 2*pow_2 - 2

    S = 0

    if a <= max_proper_followup:

        # zero is valid
        S += branch_poss_sums(a,max_pow-1)

    a -= pow_2

    if a >= 0 and a <= max_proper_followup:

        # one is valid
        S += branch_poss_sums(a,max_pow-1)

    a -= pow_2

    if a >= 0 and a <= max_proper_followup:

        # two is valid
        S += branch_poss_sums(a,max_pow-1)

    return S


if __name__ == "__main__":

    n = 10**25

    chunk_size = 3

    """
    n = 10
    while True:

        if check_slow_way(n) != calculate_by_chunk(n, chunk_size):
            print(n)
            break

        n += 1
    """

    """
    n=32

    corr = check_slow_way(n)

    dbg = calculate_by_chunk(n, chunk_size)

    print(corr)
    print(dbg)
    """


    start = time.perf_counter()

    ans = calculate_by_chunk(n, chunk_size)

    end = time.perf_counter()

    print('took %lf sec' % (end-start))

    print('answer')
    print(ans)

    """
    print('dbg')
    print(dbg_ans)

    print(branch_poss_sums(n,floor(log(n,2))))
    """
