#!/usr/bin/sage

def num_lattice_points_on_line(b,n):

    # b and -b points
    a_max = floor( sqrt(n - b*b) )
    return 2*(2*a_max+1)

def process_chunk(tup):

    b_min = tup[0]
    b_max = tup[1]
    n = tup[2]

    S = 0
    for b in range(b_min, b_max):

        a_max = floor( sqrt(n - b*b) )
        S += 2*(2*a_max+1)

    return S


def num_lattice_points(n):

    b_max = floor( sqrt(n) )

    # b = 0 points
    S = 2*b_max+1

    """
    for b in range(1,b_max+1):

        a_max = floor( sqrt(n - b*b) )
        # b and -b points
        S += 2*(2*a_max+1)
    """

    #b_set = [[b,n] for b in range(1,b_max+1)]

    num_chunks = 100
    chunk_width = b_max//num_chunks

    if chunk_width <= 0:
        num_chunks = 1
        chunk_width = b_max-1

    chunks = [[1+i*chunk_width, 1+(i+1)*chunk_width, n] for i in range(num_chunks)]
    if num_chunks * chunk_width < b_max:
        chunks.append([1+num_chunks*chunk_width, b_max+1, n])

    with Pool(4) as p:
        data = p.map(process_chunk, chunks)

    S += sum(data)

    return S

def get_moebius_coeff(c):

    if c == 1:
        return 1

    fac_c = factor(c)

    coeff = 1

    for tup in fac_c:

        p = tup[0]

        if p == 2:
            if tup[1] == 1:
                coeff *= -1 # only one prime with norm 2
            else:
                return 0 # not squarefree

        elif p & 3 == 1:
            if tup[1] > 2:
                return 0 # not squarefree
            elif tup[1] == 2:
                coeff *= 1 # possibility of both of two distinct factors over p
            else:
                coeff *= -2 # use one of two distinct factors over p
        else:
            if tup[1] != 2:
                return 0 # either not squarefree or no solution
            else:
                coeff *= -1 # only one possible factor

    return coeff

def count_squarefree(n):

    c_max = floor(sqrt(n))

    # expensive
    num_pts = 0

    for c in range(1,c_max+1):

        verbose = (c==5)

        coeff = get_moebius_coeff(c)

        if verbose:
            print('c=%d' % c)

        if coeff == 0:
            if verbose:
                print('no sf elements with this norm')
            continue

        # count multiples of c^2
        m_max = n//(c*c) # points with norms at most this large

        if verbose:
            print('m_max = %d' % m_max)

        # exclude the 0 point
        num_multiples = (num_lattice_points(m_max) - 1) // 4

        if verbose:
            print('should be %d multiples of this' % num_multiples)
            print('adjust by %d' % coeff)

        num_pts += coeff * (num_multiples)

    return num_pts

if __name__ == "__main__":

    n = 10**2

    """
    poly_ZZ.<x> = ZZ[]
    K.<u> = NumberField(x^2+1)

    # generate all lattice pts

    b_max = floor(sqrt(n))

    lat_pts = []

    for b in range(0,b_max+1):

        a_max = floor(sqrt(n-b*b))

        for a in range(1,a_max+1):

            lat_pts.append([a,b])

    num_pts = len(lat_pts)

    est_num_pts = num_lattice_points(n)
    est_num_pts = (est_num_pts-1)//4

    print(num_pts)
    print(est_num_pts)

    num_mul_sq = 0
    p = 5
    for pt in lat_pts:

        v = pt[0] + pt[1] * u

        nm_v = norm(v)

        if ZZ(nm_v) % (p*p) == 0:

            is_sq_mul = False

            fac_v = factor(v)

            for tup in fac_v:

                if tup[1] > 1 and norm(tup[0]) == p:
                    is_sq_mul = True

            if is_sq_mul:
                num_mul_sq += 1

    print('p=%d: %d' % (p,num_mul_sq))
    """

    """
    print(num_sf)

    """

    """
    b_max = floor(n^(1/4))

    lat_pts = []

    for b in range(0,b_max+1):

        a_max = floor(sqrt(sqrt(n)-b*b))

        for a in range(1,a_max+1):

            lat_pts.append([a,b])

    ct_by_sf_factors = [0] * (10**2)

    for pt in lat_pts:

        a = pt[0] + pt[1] * u

        nm_a = norm(a)

        is_sf = moebius(a)

        if is_sf != 0:

            ct_by_sf_factors[nm_a] += 1
    """

    print(count_squarefree(n))
