#pragma once

#include "myflint_header_only_ZZ.hpp"
#include <flint/fmpz_factor.h>

template <typename T>
void sort_factorization_vec(vector<tuple<T,int64_t>>& vec) {

  sort(vec.begin(), vec.end(), [](tuple<T,int64_t>& a, tuple<T,int64_t>& b){
      auto[a_fac,a_exponent] = a;
      auto[b_fac,b_exponent] = b;
      return a_fac < b_fac;
      });
}

  template <typename T>
auto merge_factorization_vectors(
    const vector<tuple<T,int64_t>> in_0,
    const vector<tuple<T,int64_t>> in_1,
    function<auto(int64_t)> fun_0,
    function<auto(int64_t)> fun_1)
{

  auto it_0 = in_0.begin();
  const auto end_0 = in_0.end();

  auto it_1 = in_1.begin();
  const auto end_1 = in_1.end();

  vector<tuple<T,int64_t>> result = {};

  while(it_0 < end_0 && it_1 < end_1) {
    const auto[number_0,exponent_0] = *it_0;
    const auto[number_1,exponent_1] = *it_1;

    if(number_0 < number_1) {
      result.push_back(tuple(number_0,fun_0(exponent_0)));
      ++it_0;
    }
    else if(number_0 > number_1) {
      result.push_back(tuple(number_1,fun_1(exponent_1)));
      ++it_1;
    }
    else {
      auto exponent = fun_0(exponent_0) + fun_1(exponent_1);
      if(exponent != 0) {
        result.push_back(tuple(number_0,exponent));
      }
      ++it_0;
      ++it_1;
    }
  }

  // insert leftovers
  // at least one of these does nothing
  while(it_0 < end_0) {
    const auto[number_0,exponent_0] = *it_0;
    result.push_back(tuple(number_0,fun_0(exponent_0)));
    ++it_0;
  }
  while(it_1 < end_1) {
    const auto[number_1,exponent_1] = *it_1;
    result.push_back(tuple(number_1,fun_1(exponent_1)));
    ++it_1;
  }

  return result;
}

  template <typename T>
auto merge_factorization_vectors(
    const vector<tuple<T,int64_t>> in_0,
    const vector<tuple<T,int64_t>> in_1)
{
  return merge_factorization_vectors(in_0,in_1,
      [](int64_t& a){return a;},
      [](int64_t& a){return a;}
      );
}

  template <typename T>
auto merge_divide_factorization_vectors(
    const vector<tuple<T,int64_t>> in_0,
    const vector<tuple<T,int64_t>> in_1)
{
  return merge_factorization_vectors(in_0,in_1,
      [](int64_t& a){return a;},
      [](int64_t& a){return -a;}
      );
}

template<typename T>
class Factorization
{
  public:
    vector<tuple<T,int64_t>> prime_factors;
    vector<tuple<T,int64_t>> other_factors;

    template <typename T>
      Factorization()
      {
        prime_factors = {};
        other_factors = {};
      }

    // rule of zero: no copy or move defined

    template<typename T>
      Factorization<T>& operator*=(const Factorization &rhs) {
        prime_factors = merge_factorization_vectors(prime_factors,rhs.prime_factors);
        other_factors = merge_factorization_vectors(other_factors,rhs.other_factors);
        return *this;
      }

    template<typename T>
    Factorization<T>& operator*(const Factorization<T>& rhs) const {
      auto result = Factorization<T>();
      result.prime_factors = merge_factorization_vectors(prime_factors,rhs.prime_factors);
      result.other_factors = merge_factorization_vectors(other_factors,rhs.other_factors);
      return result;
    }

    template<typename T>
      Factorization<T>& operator/=(const Factorization &rhs) {
        prime_factors = merge_divide_factorization_vectors(prime_factors,rhs.prime_factors);
        other_factors = merge_divide_factorization_vectors(other_factors,rhs.other_factors);
        return *this;
      }

    template<typename T>
    Factorization<T>& operator*(const Factorization<T>& rhs) const {
      auto result = Factorization<T>();
      result.prime_factors = merge_divide_factorization_vectors(prime_factors,rhs.prime_factors);
      result.other_factors = merge_divide_factorization_vectors(other_factors,rhs.other_factors);
      return result;
    }

    template <typename T>
      void Factorization<T>::sort()
      {
        sort_factorization_vec(prime_factors);
        sort_factorization_vec(other_factors);
      }

    template <typename T>
      Fmpz Factorization<Fmpz>::product() const
      {
        auto result = T(1);

        for(const auto[base,exponent] : prime_factors) {
          result *= pow(base,exponent);
        }
        for(const auto[base,exponent] : other_factors) {
          result *= pow(base,exponent);
        }

        return result;
      }
};

auto print_factor_array(ostream &os, vector<tuple<Fmpz,int64_t>> in, bool include_times) {

  for(auto &tup : in) {
    auto[base, exponent] = tup;

    if(exponent == 0) continue;

    if(include_times) {
      os << " * ";
    }
    include_times = true;

    os << base;

    if(exponent != 1) {
      os << "^" << exponent;
    }
  }

  return include_times;
}

ostream& operator<<(ostream& os, const Factorization<Fmpz>& factors)
{
  if((factors.prime_factors.size() + factors.other_factors.size()) == 0) {
    os << "1";
    return os;
  }

  bool include_times = false;

  include_times = print_factor_array(os, factors.prime_factors, include_times);
  include_times = print_factor_array(os, factors.other_factors, include_times);

  return os;
}

class Factor
{
  public:
    fmpz_factor_t data;
    slong bits;

    Factor::Factor(int64_t in)
    {
      fmpz_factor_init(data);
      bits = in;
    }

    Factor::Factor() : Factor(15L) {}; // default param

    Factor::~Factor()
    {
      fmpz_factor_clear(data);
    }

    // do not duplicate a factor object
    Factor(const Factor &other) = delete;
    Factor& operator=(const Factor &other) = delete;

    Factorization<ZZ> operator()(const ZZ& in) {
      int success = fmpz_factor_smooth(data,in.number,bits,0);

      auto num_factors = data->num;
      auto result = Factorization<ZZ>();

      auto remainder = abs(in);

      for(int index=0; index<num_factors; index++) {
        auto fac = ZZ();
        fmpz_factor_get_fmpz(fac.number, data, index);

        int64_t exponent = 0;
        while(remainder.is_divisible_by(fac))
        {
          remainder /= fac;
          exponent++;
        }

        if(exponent == 0) continue;

        const auto tup = tuple(fac,exponent);

        if((success==1) || index<num_factors-1) {
          result.prime_factors.push_back(tup);
        }
        else {
          result.other_factors.push_back(tup);
        }
      }

      if(remainder != 1)
      {
        result.other_factors.push_back(tuple(remainder,1));
      }

      result.sort();

      return result;
    }

};

ostream& operator<<(ostream& os, const Factor& f)
{
  os << "Factor class element (bits = " << f.bits << ")";
  return os;
}
