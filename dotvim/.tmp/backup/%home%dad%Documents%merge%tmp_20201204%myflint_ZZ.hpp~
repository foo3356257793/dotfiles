#pragma once

#include <algorithm>
#include <functional>
#include <iomanip>
#include <iostream>
#include <memory>
#include <numeric>
#include <tuple>
#include <vector>
#include <compare>

using namespace std;

#include <fmt/core.h>
#include <fmt/ostream.h>

using fmt::print;
using fmt::format;

// flint
#include <flint/flint.h>
#include <flint/fmpz.h>

struct ZZ_ptr;
struct div_op_temporary;
struct pow_op_temporary;

struct ZZ_add;
struct ZZ_sub;
struct ZZ_mul;

struct ZZ {
  fmpz_t number;

  ZZ();
  ZZ(const int64_t &in_number);
  ZZ(const fmpz_t &in_number);
  ZZ(const ZZ_ptr &ptr);
  ZZ(const string in_string);
  ZZ(const ZZ &other);  // copy constructor
  ZZ(ZZ &&other) noexcept; // move constructor
  ZZ &operator=(const ZZ &other); // copy assignment
  ZZ &operator=(div_op_temporary rhs);
  //ZZ &operator=(pow_op_temporary rhs);
  ZZ &operator=(ZZ &&other) noexcept; // move assignment

  ZZ &operator=(const ZZ_add &rhs); // copy assignment
  ZZ &operator=(const ZZ_sub &rhs); // copy assignment
  ZZ &operator=(const ZZ_mul &rhs); // copy assignment

  ~ZZ(); // destructor

  explicit operator fmpz*() { return (fmpz*) number; }
  explicit operator const fmpz*() const { return (const fmpz*) number; }

  explicit operator const double() const { return fmpz_get_d((const fmpz*) number); }

  ZZ& apply_fmpz_fun_eq(const ZZ &rhs,
     const function<void(fmpz_t, fmpz_t, const fmpz_t)>& fun);
  ZZ& apply_fmpz_fun_eq(
     const function<void(fmpz_t, fmpz_t)>& fun);
  ZZ& apply_fmpz_fun_eq(int64_t in,
      const function<void(fmpz_t, fmpz_t, int64_t)>& fun);

  ZZ& operator+=(const ZZ &rhs);

  ZZ& operator+=(const ZZ_mul &other);

  ZZ& operator-=(const ZZ &rhs);

  ZZ& operator-=(const ZZ_mul &other);

  ZZ& operator*=(const ZZ &rhs);
  ZZ& operator%=(const ZZ &rhs);
  ZZ& operator/=(const ZZ &rhs);
  ZZ& operator-();
  ZZ& addmul(const ZZ &in0, const ZZ &in1);
  ZZ& submul(const ZZ &in0, const ZZ &in1);

  ZZ_add operator+(const ZZ &rhs) const;
  ZZ_sub operator-(const ZZ &rhs) const;
  ZZ_mul operator*(const ZZ &rhs) const;

  ZZ operator*(const ZZ_mul &rhs) const;
  ZZ operator*(const int64_t rhs) const;

  ZZ operator%(const ZZ &rhs) const;
  ZZ operator/(const ZZ &rhs) const;
  ZZ operator-() const;

  bool operator==(const ZZ &rhs) const;
  #if 0
  bool operator!=(const ZZ &rhs) const;
  #endif

  strong_ordering operator<=>(const ZZ &rhs) const;

  bool is_divisible_by(const ZZ &poss_factor) const;

  ZZ& next_prime();

};

ZZ apply_fmpz_fun(
    const ZZ &lhs,
    const ZZ &rhs,
    const function<void(fmpz_t, const fmpz_t, const fmpz_t)>& fun);
ZZ apply_fmpz_fun(const ZZ &lhs, function<void(fmpz_t, const fmpz_t)> fun);
ZZ apply_fmpz_fun(const ZZ &lhs, int64_t in, function<void(fmpz_t, const fmpz_t, int64_t)> fun);

ZZ abs(const ZZ &in);
bool is_prime(const ZZ &in);
ZZ pow(ZZ base, int64_t exponent);
ZZ gcd(const ZZ &a, const ZZ &b);
ZZ next_prime(const ZZ &a);

ostream &operator<<(ostream &os, const ZZ &f);

namespace std{
  template <>
    struct hash<ZZ> {
      size_t operator()(const ZZ& in) const noexcept {
        return hash<double>{}(fmpz_get_d((const fmpz*) in.number));
      }
    };
}

struct ZZ_ptr{
  fmpz* ptr;

  explicit operator fmpz*() { return ptr; }
  explicit operator const fmpz*() const { return ptr; }

  ZZ_ptr(fmpz* in) : ptr(in) {}

  ZZ_ptr& operator=(const ZZ_ptr &other); // copy assignment from ZZ_ptr
  ZZ_ptr& operator=(const ZZ &other); // copy assignment from ZZ
  ZZ_ptr& operator=(const int64_t &other); // copy assignment from int64_t
  ZZ_ptr& operator=(const string &other); // copy assignment from string

  ZZ_ptr& apply_fmpz_fun_eq(const ZZ &rhs,
      const function<void(fmpz_t, fmpz_t, const fmpz_t)>& fun);
  ZZ_ptr& apply_fmpz_fun_eq(
      const function<void(fmpz_t, fmpz_t)>& fun);
  ZZ_ptr& apply_fmpz_fun_eq(int64_t in,
      const function<void(fmpz_t, fmpz_t, int64_t)>& fun);

  ZZ_ptr &operator+=(const ZZ &rhs);
  ZZ_ptr &operator-=(const ZZ &rhs);
  ZZ_ptr &operator*=(const ZZ &rhs);
  ZZ_ptr &operator%=(const ZZ &rhs);
  ZZ_ptr &operator/=(const ZZ &rhs);
  ZZ_ptr &operator-();
  ZZ_ptr& addmul(const ZZ &in0, const ZZ &in1);
  ZZ_ptr& submul(const ZZ &in0, const ZZ &in1);

  ZZ operator+(const ZZ &rhs) const;
  ZZ operator-(const ZZ &rhs) const;
  ZZ operator*(const ZZ &rhs) const;
  ZZ operator%(const ZZ &rhs) const;
  ZZ operator/(const ZZ &rhs) const;
  ZZ operator-() const;

  bool operator==(const ZZ &rhs) const;
  bool operator==(const int64_t &rhs) const;

  strong_ordering operator<=>(const ZZ &rhs) const;

  bool is_divisible_by(const ZZ &poss_factor) const;

  ZZ_ptr& next_prime();
};

ZZ apply_fmpz_fun(
    const ZZ_ptr &lhs,
    const ZZ &rhs,
    const function<void(fmpz_t, const fmpz_t, const fmpz_t)>& fun);
ZZ apply_fmpz_fun(const ZZ_ptr &lhs, function<void(fmpz_t, const fmpz_t)> fun);
ZZ apply_fmpz_fun(const ZZ_ptr &lhs, int64_t in, function<void(fmpz_t, const fmpz_t, int64_t)> fun);

ZZ abs(const ZZ_ptr &in);
bool is_prime(const ZZ_ptr &in);
ZZ pow(ZZ_ptr base, int64_t exponent);
ZZ gcd(const ZZ_ptr &a, const ZZ &b);
ZZ next_prime(const ZZ_ptr &a);

ostream &operator<<(ostream &os, const ZZ_ptr &f);

struct ZZ_add{
  const fmpz* lhs;
  const fmpz* rhs;

  ZZ_add(const fmpz* a, const fmpz* b) : lhs(a), rhs(b) {}

  operator ZZ() const { 
    auto result = ZZ();
    fmpz_add((fmpz*) result, lhs, rhs);
    return result; }
};


struct ZZ_sub{
  const fmpz* lhs;
  const fmpz* rhs;

  ZZ_sub(const fmpz* a, const fmpz* b) : lhs(a), rhs(b) {}

  operator ZZ() const { 
    auto result = ZZ();
    fmpz_sub((fmpz*) result, lhs, rhs);
    return result; }
};

struct ZZ_mul{
  const fmpz* lhs;
  const fmpz* rhs;

  ZZ_mul(const fmpz* a, const fmpz* b) : lhs(a), rhs(b) {}

  operator ZZ() const { 
    auto result = ZZ();
    fmpz_mul((fmpz*) result, lhs, rhs);
    return result; }

  ZZ operator*(const ZZ &rhs) const;
  ZZ operator+(const ZZ &rhs) const;
};
