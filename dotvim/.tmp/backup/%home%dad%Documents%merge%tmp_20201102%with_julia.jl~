using Nemo

using LoadFlint
const libflint = LoadFlint.libflint

ZZ = FlintZZ

function _my_factor(a::fmpz)
    F = Nemo.fmpz_factor()
    ccall((:fmpz_factor, libflint), Nothing, (Ref{Nemo.fmpz_factor}, Ref{fmpz}), F, a)
    res = Dict{fmpz, Int}()
    for i in 1:F.num
        z = fmpz()
        ccall((:fmpz_factor_get_fmpz, libflint), Nothing,
              (Ref{fmpz}, Ref{Nemo.fmpz_factor}, Int), z, F, i - 1)
        res[z] = unsafe_load(F.exp, i)
    end
    return res, canonical_unit(a)
end

function _my_factor_smooth(a::fmpz,bits::Int64)
    F = Nemo.fmpz_factor()
    ccall((:fmpz_factor_smooth, libflint), Nothing, (Ref{Nemo.fmpz_factor}, Ref{fmpz}, Int64, Int32), F, a, bits, 0)
    res = Dict{fmpz, Int}()
    for i in 1:F.num
        z = fmpz()
        ccall((:fmpz_factor_get_fmpz, libflint), Nothing,
              (Ref{fmpz}, Ref{Nemo.fmpz_factor}, Int), z, F, i - 1)
        res[z] = unsafe_load(F.exp, i)
    end
    return res, canonical_unit(a)
end

function my_factor(a::fmpz)
    if iszero(a)
        throw(ArgumentError("Argument is not non-zero"))
    end
    fac, z = _my_factor(a)
    return Fac(z, fac)
end

function my_factor_smooth(a::fmpz,bits::Int64)
    if iszero(a)
        throw(ArgumentError("Argument is not non-zero"))
    end
    fac, z = _my_factor_smooth(a,bits)
    return Fac(z, fac)
end

function check_numbers()

    A = ZZ(2*3*5*7)
    B = ZZ("23422561884997507608543774956236195382509542924871")
    C = ZZ("79557331528177904062615411769")
    D = 171 * C

    fac_A = my_factor_smooth(A,15)
    fac_B = my_factor_smooth(B,15)
    fac_C = my_factor_smooth(C,15)
    fac_D = my_factor_smooth(D,15)

    println(A)
    println(fac_A)
    println(B)
    println(fac_B)
    println(C)
    println(fac_C)
    println(D)
    println(fac_D)
end

check_numbers()

NumberField = Nemo.AnticNumberField

# function check_nf()
# 
#     R, x = PolynomialRing(QQ, "x")
#     K, a = NumberField(x^3 + 3x + 1, Symbol("a"))
# 
#     f = a^2 + 2a + 7
# 
#     println(f)
# 
# end
# 
# check_nf()
