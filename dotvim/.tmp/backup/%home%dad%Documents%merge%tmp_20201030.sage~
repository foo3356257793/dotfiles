#!/usr/bin/sage

from sage.rings.factorint import factor_trial_division

from subprocess import Popen, PIPE

poly_ZZ.<x> = ZZ[]

ELEMENT_TYPE = sage.rings.number_field.number_field_element_quadratic.NumberFieldElement_quadratic
IDEAL_TYPE = sage.rings.number_field.number_field_ideal.NumberFieldFractionalIdeal

ECM_B1_list = ECM()._recommended_B1_list
min_ECM_factor = min(ECM_B1_list.keys())
max_ECM_factor = max(ECM_B1_list.keys())

def run_ecm(n, factor_size=15):

    factor_size = round(factor_size/5) * 5
    factor_size = max(factor_size,min_ECM_factor)
    factor_size = min(factor_size,max_ECM_factor)

    cmd = ['ecm', '-v', str(ECM_B1_list[factor_size])]

    popen = Popen(cmd, stdout=PIPE, stdin=PIPE, stderr=PIPE, encoding='latin-1')

    out, err = popen.communicate(input=str(n))

    out_lines = out.lstrip().splitlines()

    facs_found = []

    for line in out_lines:

        if 'Factor found' in line:
            words = line.split()

            try:
                fac = ZZ(words[-1])
                facs_found.append(fac)
            except:
                print("couldn't parse this line:")
                print(line)

    return facs_found

def lazy_factor_integer(n, trial_bound=2^15, ecm_limit=25, verbose=False):

    factors_n = Factorization([])

    trial_factors = factor_trial_division(n, limit=trial_bound)

    rough_factors = []

    for fac,mul in trial_factors:

        if is_prime(fac):
            factors_n *= Factorization([(fac,mul)])
        else:
            rough_factors.append(fac)

    if not ecm_limit or not rough_factors:
        return factors_n, rough_factors

    for ecm_bound in range(min_ECM_factor, ecm_limit+5, 5):

        continuing_rough_factors = []

        for rough_fac in rough_factors:

            if verbose:
                print(f"running ecm with bound {ecm_bound}")
                print(f"\tnum = {rough_fac}")

            facs_found = run_ecm(rough_fac,factor_size=ecm_bound)

            if verbose:
                print("here are the factors we found:")
                print(facs_found)

            for new_fac in facs_found:

                if new_fac <= 1:
                    continue

                m = 0
                while rough_fac % new_fac == 0:
                    rough_fac = rough_fac//new_fac
                    m += 1

                if m == 0:
                    raise ArithmeticError("Somehow ecm gave a non-factor!")

                factors_n *= Factorization([(new_fac,m)])

            if rough_fac == 1:
                continue
            elif is_prime(rough_fac):
                factors_n *= Factorization([(rough_fac,1)])
            else:
                continuing_rough_factors.append(rough_fac)

        rough_factors = continuing_rough_factors

        if not rough_factors:
            return factors_n, rough_factors

    return factors_n, rough_factors

def get_ideal_factors_from_rough_factor(iota, rough_fac):

    iota_parent = iota.parent()

    jota = iota_parent(rough_fac)

    G = iota + jota

    if G == 1:
        return Factorization([])

    remainder = iota / G

    result, remainder = get_ideal_factors_from_rough_factor(remainder, G)

    for key, _ in result:

        nu = 0
        while key.divides(G):
            G = G / key
            nu += 1

        result *= Factorization([(key,nu)])

    if G != 1:
        result *= Factorization([(G,1)])

    return result, remainder

def get_ideal_factors_from_norm_factors(iota, norm_factorization):

    iota_parent = iota.parent()

    result = Factorization([])

    for key, _ in norm_factorization:

        jota = iota_parent(key)

        common_fac = iota + jota

        # should be find because these are integer primes
        common_factors = [fac for fac,mul in factor(common_fac)]

        for common_fac in common_factors:

            nu = iota.valuation(common_fac)

            if nu == 0:
                raise ArithmeticError("Found a non-factor!")

            result *= Factorization([(common_fac,nu)])

            iota /= common_fac^nu

    return result, iota

def lazy_factor_ideal(iota, trial_bound=2^15, ecm_limit=25, verbose=False):

    norm_iota = norm(iota)

    norm_iota_num = numerator(norm_iota)
    norm_iota_den = denominator(norm_iota)

    norm_fac_num, rough_factors_num = lazy_factor_integer(norm_iota_num, trial_bound=trial_bound, ecm_limit=ecm_limit, verbose=verbose)

    norm_fac_den, rough_factors_den = lazy_factor_integer(norm_iota_den, trial_bound=trial_bound, ecm_limit=ecm_limit, verbose=verbose)

    result, iota = get_ideal_factors_from_norm_factors(iota, norm_fac_num)

    if iota == 1:
        return result

    den_result, iota = get_ideal_factors_from_norm_factors(1/iota, norm_fac_den)

    result /= den_result

    iota = 1/iota

    if iota == 1:
        return result

    for key, _ in norm_fac_den:

        jota = iota_parent(key)

        common_fac = iota + jota

        # should be fine because these are integer primes
        common_factors = [fac for fac,mul in factor(common_fac)]

        for common_fac in common_factors:

            nu = iota.valuation(common_fac)

            if nu == 0:
                raise ArithmeticError("Found a non-factor!")

            result *= Factorization([(common_fac,-nu)])

            iota /= common_fac^nu

    if iota == 1:
        return result

    iota = 1/iota

    rough_ideal_factors = [iota + iota_parent(rough_fac) for rough_fac in set(rough_factors_num + rough_factors_den)]

    for rough_fac in rough_factors_num:

        rough_result, iota = get_ideal_factors_from_rough_factor(iota, rough_fac)

        result *= rough_result

        if iota == 1:
            return result

    iota = 1/iota

    for rough_fac in rough_factors_den:

        rough_result, iota = get_ideal_factors_from_rough_factor(iota, rough_fac)

        result /= rough_result

        if iota == 1:
            return result

    if iota != 1:
        raise ArithmeticError("I think we should have ideal factored by now!")

    iota = 1/iota
    result *= Factorization([(iota,1)])

    return result

def gen_random_coprime_tuple(bd,len_tuple):

    result = [randrange(-bd,bd+1) for _ in range(len_tuple)]

    if gcd(result) == 1:

        return tuple(result)

    return gen_random_coprime_tuple(bd,len_tuple)

class LazyFactorization:

    def __init__(self,a):

        self.factored = Factorization([])
        self.unfactored = []

        if isinstance(a,LazyFactorization):
            self.factored = copy(a.factored)
            self.unfactored = copy(a.unfactored)
        elif (isinstance(a,ELEMENT_TYPE)) or (isinstance(a, IDEAL_TYPE)):
            self.unfactored = [a]
        elif isinstance(a,list):
            self.unfactored = a
        elif isinstance(a,int) or a in ZZ:
            self.unfactored = [a]
        else:
            raise NotImplemented(f"Don't know how to lazy factor type {type(a)}")

    def __repr__(self):

        result = "LazyFactorization:"

        if self.factored:
            result += f"\n\t\tfactored  : {self.factored}"
        if self.unfactored:
            result += f"\n\t\tunfactored: {self.unfactored}"

        return result

    def __mul__(self, other):

        if type(self) != type(other):
            raise NotImplemented("Only can multiply LazyFactorization with each other")

        result = LazyFactorization(self)

        result.factored *= other.factored
        result.unfactored += other.unfactored

        return result

    def __truediv__(self, other):

        if type(self) != type(other):
            raise NotImplemented("Only can divide LazyFactorization with each other")

        result = LazyFactorization(self)

        result.factored /= other.factored
        result.unfactored += [1/o for o in other.unfactored]

        return result

def lazy_factor(n, trial_bound=2^15, ecm_limit=25, verbose=False):

    if isinstance(n, int) or n in ZZ:

        return lazy_factor_integer(n, trial_bound=trial_bound, ecm_limit=ecm_limit, verbose=verbose)

    elif isinstance(n, ELEMENT_TYPE):

        return lazy_factor_ideal(ideal(n), trial_bound=trial_bound, ecm_limit=ecm_limit, verbose=verbose)

    elif isinstance(n, IDEAL_TYPE):

        return lazy_factor_ideal(n, trial_bound=trial_bound, ecm_limit=ecm_limit, verbose=verbose)

    elif isinstance(n, LazyFactorization):

        for a in n.unfactored:

            fac_a = lazy_factor(a)
            n.factored *= fac_a

        n.unfactored = []

        return n

    elif isinstance(n, ObjectWithInfo):

        n.factors = lazy_factor(n.factors)

        return n

    else:

        raise NotImplemented(f"Don't know how to lazy factor type {type(n)}")


class ObjectWithInfo:

    def __init__(self,a):

        self.element = None
        self.ideal = None
        self.factors = None
        self.norm = None
        self.embedding = None
        self.basis = None

        if isinstance(a,ObjectWithInfo):
            self.element = a.element
            self.ideal = a.ideal
            self.factors = copy(a.factors)
            self.norm = a.norm
            self.embedding = a.embedding
            self.basis = copy(a.basis)
        elif isinstance(a,ELEMENT_TYPE):
            self.element = a
            self.ideal = ideal(a)
            self.factors = LazyFactorization(a)
        elif isinstance(a,IDEAL_TYPE):
            self.element = None
            self.ideal = a
            self.factors = LazyFactorization(a)
        else:
            raise NotImplemented("a doesn't have a type that ObjectWithInfo understands")

    def __repr__(self):

        result = "ObjectWithInfo:"

        if self.element:
            result += f"\n\telement  : {self.element}"
        if self.ideal:
            result += f"\n\tideal    : {self.ideal}"
        if self.factors:
            result += f"\n\tfactors  : {self.factors}"
        if self.norm:
            result += f"\n\tnorm     : {self.norm}"
        if self.embedding:
            result += f"\n\tembedding: {self.embedding}"
        if self.basis:
            result += f"\n\tbasis    : {self.basis}"

        return result

    def __mul__(self, other):

        if not isinstance(other,type(self)):
            raise NotImplemented("Only can multiply ObjectWithInfo with each other")

        result = ObjectWithInfo(self)

        if self.element == None or other.element == None:
            result.element = None
        else:
            result.element = self.element * other.element

        result.ideal *= other.ideal
        result.factors *= other.factors

        if self.norm and other.norm:
            result.norm *= other.norm
        else:
            result.norm = None

        if self.embedding and other.embedding:
            result.embedding = [s * o for s,o in zip(self.embedding,other.embedding)]

        result.basis = None

        return result

    def __truediv__(self,other):

        if not isinstance(other,type(self)):
            raise NotImplemented("Only can divide ObjectWithInfo with each other")

        result = ObjectWithInfo(self)

        if self.element == None or other.element == None:
            result.element = None
        else:
            result.element = self.element / other.element

        result.ideal /= other.ideal

        result.factors /= other.factors

        if self.norm and other.norm:
            result.norm /= other.norm
        else:
            result.norm = None

        if self.embedding and other.embedding:
            result.embedding = [s / o for s,o in zip(self.embedding,other.embedding)]

        result.basis = None

        return result


if __name__ == "__main__":

    f = x^2 - x - 7;

    K.<u> = NumberField(f)

    set_random_seed(0)

    bd = 16

    a = K(gen_random_coprime_tuple(bd, 2))
    b = K(gen_random_coprime_tuple(bd, 2))

    alpha = ObjectWithInfo(a)
    beta = ObjectWithInfo(ideal(b))
    gamma = ObjectWithInfo(a)

    # foo = lazy_factor(a)

    foo = alpha/beta

    print(lazy_factor(foo))
