#!/usr/bin/python3

class FlintName:
    def __init__(self,new_name,flint_name):
        self.new = new_name
        self.flint = flint_name

    def __repr__(self):
        return self.new

class BuiltInOp:
    def __init__(self,token,fun_name):
        self.token = token
        self.fun_name = fun_name

    def __repr__(self):
        return self.fun_name

    def prefix(self,prefix_str):
        return BuiltInOp(self.token,f"{prefix_str}_{self.fun_name}")

SI_NAMES = [f'int{b}_t' for b in [2**i for i in range(3,7)]]
UI_NAMES = [f'uint{b}_t' for b in [2**i for i in range(3,7)]]
INT_NAMES = SI_NAMES + UI_NAMES
FLOAT_NAMES = ['float', 'double']
BUILTIN_NAMES = ['string','bool'] + INT_NAMES + FLOAT_NAMES

FLINT_SUFFIXES = {'string' : 'str'}
for name in SI_NAMES:
    FLINT_SUFFIXES[name] = 'si'
for name in UI_NAMES:
    FLINT_SUFFIXES[name] = 'ui'
for name in FLOAT_NAMES:
    FLINT_SUFFIXES[name] = 'd'

def first_not_None(*args):
    for a in args:
        if not (a is None):
            return a
    return None

class CType:
    def __init__(self,name,is_builtin=None,has_data=None,flint_suffix=None):
        self.name = name
        if isinstance(name,FlintName):
            is_builtin = False
            has_data = True
        elif name in BUILTIN_NAMES:
            is_builtin = True
            has_data = False
        self.is_builtin = is_builtin
        self.has_data = has_data
        if self.is_builtin:
            flint_suffix = FLINT_SUFFIXES[self.name]
        self.flint_suffix = flint_suffix

    def __repr__(self):
        return str(self.name)

class CVariable:
    def __init__(self,ctype,name,is_const=True,by_ref=None,move=None):
        self.ctype = ctype
        self.name = name
        if by_ref is None:
            by_ref = not ctype.is_builtin
        self.by_ref = by_ref
        self.move = move
        if self.move and (is_const):
            raise ValueError("cannot move const")
        if self.move and (is_const is None):
            is_const = False
        self.is_const = is_const

    def input_str(self,index=None):

        result = ""
        if self.is_const:
            result = f"const "
        result += f"{self.ctype} "
        if self.move:
            result += "&&"
        elif self.by_ref:
            result += "&"
        result += f"{self.name}"

        return result

    def var_str(self):
        result = f"{self.name}"
        if self.ctype.has_data:
            result += f".data"
        return result;

class FuncDecl:

    def __init__(self,name,output_type=None,output_ref=None,input_type=None):
        self.name = name
        self.output_type = output_type
        self.output_ref = output_ref
        self.input_type = input_type

    def output(self):
        if self.output_type:
            return fun.output_type
        elif self.output_ref:
            return fun.output_ref
        return None

    def output_str(self):
        out = self.output()

        if out is None:
            return ""
        return str(out)


def input_var_str(input_type):

    if input_type is None:
        return ""

    if isinstance(input_type,list):
        if len(input_type)==0:
            return ""
        if len(input_type)==1:
            return input_type[0].input_str()
        return ", ".join(inp.input_str() for index,inp in
                         enumerate(input_type))

    return input_type.input_str()

def inputs_to_variables(arr):

    if isinstance(arr,list):
        if len(arr) == 0:
            return []
        if len(arr) == 1:
            return [CVariable(arr[0],"in")]
        return [CVariable(ctype,f"in_{index+1}") for index,ctype in
                enumerate(arr)]

    return [CVariable(arr,"in")]

def inputs_to_variables_eq(arr):

    if not isinstance(arr,list):
        raise ValueError("Expecting a list in inputs_to_variables_eq")

    return inputs_to_variables(arr[1:])


def fun_cpp(fun):

    input_vars = inputs_to_variables(fun.input_type)

    op_prefix = ""
    op_suffix = ""
    if isinstance(op,BuiltInOp):
        op_prefix = "operator"
        op_suffix = ""

    result  = f"{fun.output_str()} {op_prefix}{op.token}{op_suffix}("
    result += input_var_str(input_vars)
    result += f") {{\n"

    if fun.output_ref:
        if not fun.output_ref.has_data:
            raise ValueError("expecting output by reference to have data")
        result += f"auto result = {fun.output_str()}();\n"
    else:
        result += "return "

    result += f"{fun.name}("

    if fun.output_ref:
        result += "result.data, "

    result += ", ".join([inp.var_str() for inp in input_vars])

    result += ");\n"

    if fun.output_ref:
        result += f"return result;\n"

    result += f"}}\n"

    return result

def fun_eq_cpp(fun):

    if not fun.output_ref:
        print("expecting output_ref")
    if not fun.output_ref.has_data:
        print("expecting output_ref to have data")

    input_vars = inputs_to_variables_eq(fun.input_type)

    op_prefix = ""
    op_suffix = ""
    if isinstance(op,BuiltInOp):
        op_prefix = "operator"
        op_suffix = "="

    result  = f"{fun.output_str()} &{op_prefix}{op.token}{op_suffix}("
    result += input_var_str(input_vars)
    result += f") {{\n"
    result += f"{fun.name}(data,data,"
    result += ", ".join([inp.var_str() for inp in input_vars])
    result += ");\n"
    result += f"return *this;\n"
    result += f"}}\n"

    return result

if __name__ == "__main__":

    print("hello, world")

    ops = [BuiltInOp("+","add"),
           BuiltInOp("-","sub"),
           BuiltInOp("*","mul")]

    fl_name = FlintName("ZZ","fmpz")

    cl_type = CType(fl_name)

    body = []
    after = []

    for op in ops:

        fun = FuncDecl(op.prefix(fl_name.flint),output_ref=cl_type,
                       input_type=[cl_type,cl_type])

        body.append(fun_eq_cpp(fun))
        after.append(fun_cpp(fun))


    print("\n".join(body))
    print("\n".join(after))
