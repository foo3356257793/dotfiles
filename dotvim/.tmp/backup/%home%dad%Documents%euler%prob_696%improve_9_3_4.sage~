#!/usr/bin/sage

def _gen_all_hands(hand,S,i,n,T):

    if S==T:
        return [hand]
    elif i == n:
        return []

    branch_hand = copy(hand)

    ret = []
    for j in range(5):

        ret += _gen_all_hands(copy(branch_hand), S, i+1, n, T)

        branch_hand[i] += 1
        S += 1

        if S > T:
            break

    return ret

def gen_all_hands(n,T):

    hand = [0] * n

    return _gen_all_hands(hand, 0, 0, n, T)

# chow is a run of three
def remove_chow(hand, starting_index):

    if hand == None:
        return None

    # verify that this is possible
    if (starting_index + 2 >= len(hand)) or (hand[starting_index] < 1) or (hand[starting_index+1] < 1) or (hand[starting_index+2] < 1):
        return None

    red_hand = copy(hand)
    for j in range(3):
        red_hand[starting_index+j] -= 1

    return red_hand

# pung is a set of three
def remove_pung(hand, starting_index):

    if hand == None:
        return None

    if (starting_index >= len(hand)) or (hand[starting_index] < 3):
        return None

    red_hand = copy(hand)
    red_hand[starting_index] -= 3

    return red_hand

# pair is a set of two
def remove_pair(hand, starting_index):

    if hand == None:
        return None

    if (starting_index >= len(hand)) or (hand[starting_index] < 2):
        return None

    red_hand = copy(hand)
    red_hand[starting_index] -= 2

    return red_hand

def reduce_hand(hand,index,len_hand):

    if index == len_hand:
        return True

    red_hand = copy(hand)

    if hand[index] == 1:

        red_hand = remove_chow(red_hand,index)

    if hand[index] == 2:

        # already removed any pairs
        red_hand = remove_chow(red_hand,index)
        red_hand = remove_chow(red_hand,index)

    if hand[index] == 3:

        # can assume a pung is sufficient
        red_hand = remove_pung(red_hand,index)

    if hand[index] == 4:

        # can assume a pung is sufficient
        red_hand = remove_pung(red_hand,index)
        red_hand = remove_chow(red_hand,index)

    if red_hand == None:
        return False

    return reduce_hand(red_hand,index+1,len_hand)

def is_winning(hand):

    len_hand = len(hand)

    if (sum(hand) - 2) % 3 != 0:
        return False

    ret = False

    for i in range(len(hand)):

        if hand[i] >= 2:

            red_hand = remove_pair(hand,i)

            ret = reduce_hand(red_hand,0,len_hand)

            if ret:
                break

    return ret

def n_hands_for_triple_count_no_pair(n,t):

    T = 3*t

    hands = gen_all_hands(n,T)

    ret = 0
    for hand in hands:

        if reduce_hand(hand,0,len(hand)):
            ret += 1

    return ret

def n_hands_for_triple_count_pair(n,t):

    T = 3*t+2

    hands = gen_all_hands(n,T)

    ret = 0
    for hand in hands:

        if is_winning(hand):
            ret += 1

    return ret

def n_hands_for_triple_count(n,t,pair):

    if pair:
        return n_hands_for_triple_count_pair(n,t)

    return n_hands_for_triple_count_no_pair(n,t)

def coeff_config(tup):

    coeff = prod(range(3-len(tup),4))

    num_same = 1
    for j in range(1,len(tup)):

        if tup[j] == tup[j-1]:
            num_same += 1
        else:
            coeff //= factorial(num_same)
            num_same = 1

    coeff //= factorial(num_same)

    return coeff

if __name__ == "__main__":

    """
    First toy

    1. Exhaust the number of triples in the same suit as the pair
    2. Exhaust through the number of triples in the other two suits

    3. Number of hands with the specified number of triples (w/ or w/o the pair)
    """

    #n = 4
    #t = 2

    n = 9
    t = 4

    n_hands_by_triple_count_paired = []
    n_hands_by_triple_count_no_pair = []

    for i in range(0,t+1):

        print('pair', i)

        n_hands = n_hands_for_triple_count(n,i,True)

        n_hands_by_triple_count_paired.append(n_hands)

    for i in range(0,t+1):

        print('no pair', i)

        n_hands = n_hands_for_triple_count(n,i,False)

        n_hands_by_triple_count_no_pair.append(n_hands)

    # TODO:
    poss_configs = []

    # number of triples together w/pair
    for i in range(t+1):

        for j in range((t-i)+1):

            k = t-i-j

            poss_configs.append([i,j,k])

    S = 0

    for tup in poss_configs:

        pair_0_poss  = n_hands_by_triple_count_paired[tup[0]]
        pair_0_poss *= n_hands_by_triple_count_no_pair[tup[1]]
        pair_0_poss *= n_hands_by_triple_count_no_pair[tup[2]]

        S += 3 * pair_0_poss

    print(S)

    poss_configs = []

    for i in range(t+1):

        for tup in Partitions(t-i):

            if len(tup) <= 2:

                poss_configs.append(tup)

    S = 0

    for tup in poss_configs:

        d = t-sum(tup)

        tup_poss = n_hands_by_triple_count_paired[d]

        for i in tup:
            tup_poss *= n_hands_by_triple_count_no_pair[i]

        # what coefficient goes here
        coeff = coeff_config(tup)

        S += tup_poss * coeff


    print(S)
