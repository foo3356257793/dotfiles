#include "formal_sum.hpp"
#include "myflint_factor.hpp"
#include "myflint_poly.hpp"
#include "myflint_ZZ_mat.hpp"
#include "div_operator.hpp"

#include "yaml-cpp/yaml.h"

#include "myflint_lll.hpp"

#include <iomanip>
#include <iostream>
#include <string>
#include <type_traits>
#include <variant>
#include <vector>

#include <fstream>

// the variant to visit
using var_t = std::variant<ZZ, ZZ_poly>;
 
// helper constant for the visitor #3
template<class> inline constexpr bool always_false_v = false;

template<class... Ts> struct overloaded : Ts... { using Ts::operator()...; };
template<class... Ts> overloaded(Ts...) -> overloaded<Ts...>;

// testing
#include <gtest/gtest.h>

using Term = FormalSumTerm<int64_t,int64_t>;
using TermZZ = FormalSumTerm<ZZ,int64_t>;
using TermZZ_ZZ = FormalSumTerm<ZZ,ZZ>;

TEST(Tests, factorization) {

  auto foo = Factorization<int64_t>();

  foo.primes += Term(31,1);
  foo.composites += Term(94,-1);

  print("{}\n", foo);

  auto bar = Factorization<int64_t>();
  bar.composites += Term(94,1);
  bar.primes += Term(2,3);

  foo += bar;

  print("{}\n", foo);

  auto items = foo.sorted_items();

  ASSERT_EQ(items.size(), 2);
  ASSERT_EQ(items[0].value, 2);
  ASSERT_EQ(items[0].coeff, 3);
  ASSERT_EQ(items[1].value, 31);
  ASSERT_EQ(items[1].coeff, 1);

  foo *= 2;

  print("{}\n", foo);

  items = foo.sorted_items();

  ASSERT_EQ(items.size(), 2);
  ASSERT_EQ(items[0].value, 2);
  ASSERT_EQ(items[0].coeff, 6);
  ASSERT_EQ(items[1].value, 31);
  ASSERT_EQ(items[1].coeff, 2);

  foo *= 0;

  print("{} is zero? {}\n", foo, foo==0);

  ASSERT_EQ(foo,0);

  auto fooZZ = Factorization<ZZ>();

  fooZZ.primes += TermZZ(ZZ(31),1);
  fooZZ.composites += TermZZ(ZZ(94),-1);

  print("{}\n", fooZZ);

  auto items_ZZ = fooZZ.sorted_items();

  ASSERT_EQ(items_ZZ.size(), 2);
  ASSERT_EQ(items_ZZ[0].value, 31);
  ASSERT_EQ(items_ZZ[0].coeff, 1);
  ASSERT_EQ(items_ZZ[1].value, 94);
  ASSERT_EQ(items_ZZ[1].coeff, -1);

}

TEST(Tests, formal_sum) {

  auto foo = FormalSum<ZZ,ZZ>();

  foo += TermZZ_ZZ(10,3);
  foo += TermZZ_ZZ(70,-5);
  foo += TermZZ_ZZ(ZZ("123456789123456789"),-1);

  print("{}\n", foo);

  auto items = foo.sorted_items();

  ASSERT_EQ(items.size(), 3);
  ASSERT_EQ(items[0].value, 10);
  ASSERT_EQ(items[0].coeff, 3);
  ASSERT_EQ(items[1].value, 70);
  ASSERT_EQ(items[1].coeff, -5);
  ASSERT_EQ(items[2].value, ZZ("123456789123456789"));
  ASSERT_EQ(items[2].coeff, -1);

  print("minus foo: {}\n", -foo);

  items = (-foo).sorted_items();

  ASSERT_EQ(items.size(), 3);
  ASSERT_EQ(items[0].value, 10);
  ASSERT_EQ(items[0].coeff, -3);
  ASSERT_EQ(items[1].value, 70);
  ASSERT_EQ(items[1].coeff, 5);
  ASSERT_EQ(items[2].value, ZZ("123456789123456789"));
  ASSERT_EQ(items[2].coeff, 1);

  auto bar = FormalSum<ZZ,ZZ>();
  bar += TermZZ_ZZ(71,89);
  bar += TermZZ_ZZ(93,ZZ("90909090909090909090909090"));
  bar += TermZZ_ZZ(ZZ("37"),45);

  print("{}\n", bar);

  items = bar.sorted_items();

  ASSERT_EQ(items.size(), 3);
  ASSERT_EQ(items[0].value, 37);
  ASSERT_EQ(items[0].coeff, 45);
  ASSERT_EQ(items[1].value, 71);
  ASSERT_EQ(items[1].coeff, 89);
  ASSERT_EQ(items[2].value, 93);
  ASSERT_EQ(items[2].coeff, ZZ("90909090909090909090909090"));

  foo += move(bar);

  print("{}\n", foo);

  items = foo.sorted_items();

  ASSERT_EQ(items.size(), 6);
  ASSERT_EQ(items[0].value, 10);
  ASSERT_EQ(items[0].coeff, 3);
  ASSERT_EQ(items[1].value, 37);
  ASSERT_EQ(items[1].coeff, 45);
  ASSERT_EQ(items[2].value, 70);
  ASSERT_EQ(items[2].coeff, -5);
  ASSERT_EQ(items[3].value, 71);
  ASSERT_EQ(items[3].coeff, 89);
  ASSERT_EQ(items[4].value, 93);
  ASSERT_EQ(items[4].coeff, ZZ("90909090909090909090909090"));
  ASSERT_EQ(items[5].value, ZZ("123456789123456789"));
  ASSERT_EQ(items[5].coeff, -1);

  auto gobble = FormalSum<ZZ,ZZ>();
  gobble += TermZZ_ZZ(2,79);
  foo -= move(gobble);

  print("{}\n", foo);

  items = foo.sorted_items();

  ASSERT_EQ(items.size(), 7);
  ASSERT_EQ(items[0].value, 2);
  ASSERT_EQ(items[0].coeff, -79);
  ASSERT_EQ(items[1].value, 10);
  ASSERT_EQ(items[1].coeff, 3);
  ASSERT_EQ(items[2].value, 37);
  ASSERT_EQ(items[2].coeff, 45);
  ASSERT_EQ(items[3].value, 70);
  ASSERT_EQ(items[3].coeff, -5);
  ASSERT_EQ(items[4].value, 71);
  ASSERT_EQ(items[4].coeff, 89);
  ASSERT_EQ(items[5].value, 93);
  ASSERT_EQ(items[5].coeff, ZZ("90909090909090909090909090"));
  ASSERT_EQ(items[6].value, ZZ("123456789123456789"));
  ASSERT_EQ(items[6].coeff, -1);

}

TEST(Tests, factor) {

  auto foo = ZZ(2)*ZZ(3)*ZZ(5)*ZZ(7)*ZZ(11)*ZZ(11)*ZZ(13);

  auto foo_factors = factor(foo);

  print("{}\n", foo_factors);

  auto items = foo_factors.sorted_items();

  ASSERT_EQ(items.size(), 6);
  ASSERT_EQ(items[0].value, 2);
  ASSERT_EQ(items[0].coeff, 1);
  ASSERT_EQ(items[1].value, 3);
  ASSERT_EQ(items[1].coeff, 1);
  ASSERT_EQ(items[2].value, 5);
  ASSERT_EQ(items[2].coeff, 1);
  ASSERT_EQ(items[3].value, 7);
  ASSERT_EQ(items[3].coeff, 1);
  ASSERT_EQ(items[4].value, 11);
  ASSERT_EQ(items[4].coeff, 2);
  ASSERT_EQ(items[5].value, 13);
  ASSERT_EQ(items[5].coeff, 1);

  auto bar = ZZ("48222648924224528332090922912037930609472797631248617");

  auto bar_factors = factor(bar, (FactorParams) {.bits=30});

  print("{}\n", bar_factors);

  print("primes:\n{}\n", bar_factors.primes);
  print("composites:\n{}\n", bar_factors.composites);

  auto check = ZZ(1);
  for(auto &term : bar_factors.primes.items()){
    ASSERT_TRUE(is_prime(term.value));
    //check *= pow(term.value,term.coeff);
    check *= term.value<power>term.coeff;
  }
  for(auto &term : bar_factors.composites.items()){
    ASSERT_TRUE(!is_prime(term.value));
    check *= term.value<power>term.coeff;
  }

  ASSERT_EQ(check, bar);

}

TEST(Tests, coprime) {

  auto bar = Factorization<ZZ>();

  bar.composites += TermZZ((2*2*2*3*3*5*7),1);
  bar.composites += TermZZ((2*3*3*5*5*5*7*7),1);

  print("start  = {}\n", bar);

  auto starting_prod = ZZ(1);
  for(auto &term : bar.primes.items()){
    starting_prod *= pow(term.value,term.coeff);
  }
  for(auto &term : bar.composites.items()){
    starting_prod *= pow(term.value,term.coeff);
  }

  bar.make_factors_coprime();

  auto ending_prod = ZZ(1);
  for(auto &term : bar.primes.items()){
    ASSERT_TRUE(is_prime(term.value));
    ending_prod *= pow(term.value,term.coeff);
  }
  for(auto &term : bar.composites.items()){
    ASSERT_TRUE(!is_prime(term.value));
    ending_prod *= pow(term.value,term.coeff);
  }

  print("result = {}\n", bar);

  print("primes:\n{}\n", bar.primes);
  print("composites:\n{}\n", bar.composites);

  ASSERT_EQ(starting_prod, ending_prod);

}

TEST(Tests, poly) {

  vector<ZZ> coeffs = {ZZ(1),ZZ(2),ZZ(3)};

  auto poly = ZZ_poly(coeffs);

  print("poly:\n{}\n", poly);

  ASSERT_EQ(poly.degree(), 2);

  #if 0
  ASSERT_TRUE(fmpz_equal_si((const fmpz*) poly[0],1));
  ASSERT_TRUE(fmpz_equal_si((const fmpz*) poly[1],2));
  ASSERT_TRUE(fmpz_equal_si((const fmpz*) poly[2],3));
  #endif

  ASSERT_EQ(poly[0],1);
  ASSERT_EQ(poly[1],2);
  ASSERT_EQ(poly[2],3);

  poly[0] += 5;

  print("now poly is: {}\n", poly);

  ASSERT_EQ(poly[0],6);

  ZZ coeff_sum = poly[0];
  for(auto index=1; index<=poly.degree(); index++){
    coeff_sum += poly[index];
  }

  print("sum of coefficients = {}\n", coeff_sum);

  ASSERT_EQ(coeff_sum, 1+2+3+5);

}

variant<ZZ, ZZ_poly> foo(int64_t a){
  if (a & 1){
    return ZZ(a);
  }
  else{
    return ZZ_poly({ZZ(a),ZZ(1)});
  }
}

TEST(Tests, variant) {

  auto val_0 = foo(10);
  auto val_1 = foo(11);

  auto vec = vector<variant<ZZ,ZZ_poly>>();
  vec.push_back(val_0);
  vec.push_back(val_1);

  print("here!\n");

  for(auto &val : vec){
    if(holds_alternative<ZZ>(val)){
      print("This is a ZZ: {}\n", get<ZZ>(val));
    }
    else{
      print("This is a ZZ_poly: {}\n", get<ZZ_poly>(val));
    }
  }

  for(auto &val : vec){
    try{
      print("This is a ZZ: {}\n", get<ZZ>(val));
    }
    catch(bad_variant_access const& ex){
      print("This is a ZZ_poly: {}\n", get<ZZ_poly>(val));
    }
  }

}

#if 0
TEST(Tests, paste) {

    std::vector<var_t> vec = {ZZ(10), ZZ_poly({ZZ(11),ZZ(1)})};

    for(auto& v: vec) {
 
        // 1. void visitor, only called for side-effects (here, for I/O)
        std::visit([](auto&& arg){std::cout << arg;}, v);
 
        // 2. value-returning visitor, demonstrates the idiom of returning another variant
        var_t w = std::visit([](auto&& arg) -> var_t {return arg + arg;}, v);
 
        // 3. type-matching visitor: a lambda that handles each type differently
        std::cout << ". After doubling, variant holds ";
        std::visit([](auto&& arg) {
            using T = std::decay_t<decltype(arg)>;
            if constexpr (std::is_same_v<T, ZZ>)
                std::cout << "ZZ with value " << arg << '\n';
            else if constexpr (std::is_same_v<T, ZZ_poly>)
                std::cout << "ZZ_poly with value " << arg << '\n';
            else 
                static_assert(always_false_v<T>, "non-exhaustive visitor!");
        }, w);
    }
 
    for (auto& v: vec) {
        // 4. another type-matching visitor: a class with 3 overloaded operator()'s
        std::visit(overloaded {
            [](auto arg) { std::cout << arg << ' '; },
            [](ZZ_poly arg) { std::cout << "POLY: " << arg << ' '; },
        }, v);
    }
}
#endif

template <typename T>
string repr(const T& a){
  stringstream ss;
  ss << a;
  return ss.str();
}

YAML::Emitter& operator << (YAML::Emitter& out, const ZZ_mat& m){

  out << YAML::BeginSeq;
  for(auto row=0; row<m.nrows(); row++){
    out << YAML::BeginSeq;
    for(auto col=0; col<m.ncols(); col++){
      char *out_string = fmpz_get_str(NULL, 10, m(row,col));
      out << out_string;
      free(out_string);
    }
    out << YAML::EndSeq;
  }
  out << YAML::EndSeq;

  return out;
}

optional<vector<ZZ_mat>> read_yaml_file(string fname){

  YAML::Node node;
  try {
    node = YAML::LoadFile(fname);
  } catch (exception &e) {
    cout << "Error parsing file!" << endl;
    cout << e.what() << endl;

    cout << endl;
    return nullopt;
  }

  assert(node.IsSequence());

  auto result = vector<ZZ_mat>();

  for(size_t index=0; index<node.size(); index++){
    auto mat_as_vecs = node[index].as<vector<vector<string>>>();
    result.push_back(ZZ_mat(mat_as_vecs));
  }

  return result;

}


TEST(Tests, yaml) {

  auto a = ZZ("123456789123456789");

  auto num_trials = 8;

  auto vec = vector<ZZ_mat>();

  YAML::Emitter out;

  out << YAML::BeginSeq;

  for(auto trial=0; trial<num_trials; trial++){
    auto mat = ZZ_mat(3,3);
    for(auto row=0; row<3; row++){
      for(auto col=0; col<3; col++){
        mat[row][col] = a;
        a.next_prime();
      }
    }
    out << mat;
    vec.push_back(mat);
  }

  out << YAML::EndSeq;

  ofstream myfile;
  string fname = "example.yaml";
  myfile.open(fname);

  myfile << out.c_str();

  myfile.close();

  auto maybe_matching_vec = read_yaml_file(fname);

  ASSERT_TRUE(maybe_matching_vec.has_value());

  auto matching_vec = maybe_matching_vec.value();

  #if 0
  for(auto &mat : matching_vec){
    print("{}\n\n", mat);
  }
  #endif

  ASSERT_EQ(vec.size(),matching_vec.size());
  for(auto index=0; index<vec.size(); index++){
    ASSERT_EQ(vec[index],matching_vec[index]);
  }

}

ZZ_mat check_cob(const ZZ_mat &orig_mat, const ZZ_mat &new_mat){

  auto orig_transpose = transpose(orig_mat);
  auto new_transpose = transpose(new_mat);
  auto result = ZZ_mat(orig_mat.nrows(), orig_mat.ncols());
  auto den = ZZ();

  int success = fmpz_mat_solve(result.mat, (fmpz *) den, orig_transpose.mat, new_transpose.mat);

  EXPECT_EQ(success,1);

  // could have a non-trivial denominator
  for(auto row=0; row<result.nrows(); row++){
    for(auto col=0; col<result.ncols(); col++){
      EXPECT_TRUE(fmpz_divisible((const fmpz *)result[row][col],(const fmpz*) den));
      fmpz_divexact((fmpz*) result[row][col],(fmpz*) result[row][col],(const fmpz*) den);
    }
  }

  auto det = determinant(result);
  det = abs(det);

  EXPECT_EQ(det,1);

  return result;

}

TEST(Tests, LLL) {

  auto a = ZZ("123456789123456789");

  auto mat = ZZ_mat(3,3);
  for(auto row=0; row<3; row++){
    for(auto col=0; col<3; col++){
      mat[row][col] = a;
      a.next_prime();
    }
  }

  auto copy = mat;

  LLL_inplace(mat);

  // check that these are related by unimodular cob
  auto cob = check_cob(copy,mat);

  print("{}\n", cob);

}

TEST(Tests, mat) {

  auto mat = ZZ_mat(3,3);

  mat[0][0] = 16;
  for(int row=1; row<3; row++){
    mat[row][0] = 3*row;
    mat[row][row] = 1;
  }

  print("Here is the mat:\n{}\n", mat);

  ASSERT_EQ(mat.nrows(),3);
  ASSERT_EQ(mat[0][0], 16);
  ASSERT_EQ(mat[0][1], 0);
  ASSERT_EQ(mat[0][2], 0);
  ASSERT_EQ(mat[1][0], 3);
  ASSERT_EQ(mat[1][1], 1);
  ASSERT_EQ(mat[1][2], 0);
  ASSERT_EQ(mat[2][0], 6);
  ASSERT_EQ(mat[2][1], 0);
  ASSERT_EQ(mat[2][2], 1);

  auto red_mat = LLL(mat);

  print("reduced:\n{}\n", mat);

  // check that these are related by unimodular cob
  auto cob = check_cob(mat,red_mat);

  print("{}\n", cob);
}

TEST(Tests, div) {

  auto a = ZZ(12);
  auto b = ZZ(4);

  auto c = a <divexact> b;

  print("c = {}\n", c);
  ASSERT_EQ(c,3);

  c =divexact> 3;

  print("c = {}\n", c);
  ASSERT_EQ(c,1);

}

int main(int argc, char *argv[]){

  ::testing::InitGoogleTest(&argc, argv);
  return RUN_ALL_TESTS();

}
