#!/usr/bin/sage

import time

import itertools

def binary_search(min_val, max_val, test):

    if max_val == min_val:

        return min_val

    if max_val == min_val + 1:

        if test(min_val):
            return min_val
        else:
            return max_val

    mid_val = (max_val+min_val) // 2

    if test(mid_val):

        return binary_search(min_val, mid_val, test)

    else:

        return binary_search(mid_val+1, max_val, test)

def find_range(arr, x_min, x_max):

    len_arr = len(arr)

    if arr[-1] < x_min:
        return len_arr, len_arr

    if arr[0] >= x_max:
        return 0, 0


    i_min = 0
    i_max = len_arr-1
    i_mid = (i_min + i_max)//2

    while i_max-i_min > 1:

        if arr[i_mid] >= x_min:

            # the lowest i is at most i_mid
            i_max = i_mid

        else:

            # the lowest i is at least i_min + 1
            i_min = i_mid+1

        i_mid = (i_min + i_max)//2

    i = i_min

    if arr[i_min] < x_min:
        i += 1

    j_min = i
    j_max = len_arr-1
    j_mid = (j_min + j_max)//2

    while j_max-j_min > 1:

        if arr[j_mid] < x_max:

            # the greatest j is at least j_mid
            j_min = j_mid

        else:

            # the lowest j is at least j_min - 1
            j_max = j_mid-1

        j_mid = (j_min + j_max)//2

    j = j_max

    if arr[j_max] >= x_max:
        j -= 1

    j += 1

    return i, j


def valid_radical_factors(F):

    ret = []

    for f in range(6,F):

        if len(fac(f)) >= 2:
            ret.append(f)

def valid_factors_a(f):

    if moebius(f) == 0:
        return []

    ret = divisors(f)

    ret = [a for a in ret if a*a < f and a != 1]

    return ret

def _exhaust_radical_value(fac_a_min, index, a, a_max):

    if index >= len(fac_a_min):

        return [a]

    ret = exhaust_radical_value(fac_a_min, index+1, a, a_max)

    a *= fac_a_min[index]

    while a <= a_max:
        ret += exhaust_radical_value(fac_a_min, index+1, a, a_max)
        a *= fac_a_min[index]

def exhaust_radical_value(a_min, a_max):

    fac_a_min = factorization(r)

    fac_a_min = [tup[0] for tup in fac_a_min] # a_min squarefree

    return _exhaust_radical_value(fac_a_min, 0, a_min, a_max)

if __name__ == "__main__":

    #########################
    # Set bound (toy or real)
    #########################

    bd = 1000
    #bd = 120000

    ###########################
    # Compute radical of values
    ###########################

    radicals = [1] * bd
    radicals[0] = 0

    start_tm = time.perf_counter()

    primes = prime_range(bd)

    for p in primes:

        for m in range(p,bd,p):

            radicals[m] *= p

    end_tm = time.perf_counter()
    tot_tm = end_tm-start_tm
    print("radicals: TIME = %.3lf" % tot_tm)

    ###################
    # Gather rad(c) < c
    ###################

    sub_radical = []
    for c in range(bd):

        if radicals[c] < c:
            sub_radical.append(c)

    print('%d/%d radical' % (len(sub_radical), bd))


    ##########################
    # Gather abc hits with a=1
    ##########################

    hits_with_1 = []

    for c in sub_radical:

        if radicals[c] * radicals[c-1] < c:

            hits_with_1.append([1,c-1,c])

    ###############################################
    # divide sub_radical into bins by radical value
    ###############################################

    radical_val_bins = {}

    for s in range(2,bd):

        r = radicals[s]

        if not r in radical_val_bins:
            radical_val_bins[r] = [s]
        else:
            radical_val_bins[r].append(s)

    ################################
    # look at small radical products
    ################################

    bins = sorted(radical_val_bins.keys())

    hits_with_greater = []

    for i in range(len(bins)-1):
        print('...%6d/%d' % (i,len(bins)))
        rad_a = bins[i]
        bin_a = radical_val_bins[rad_a]
        for j in range(i+1, len(bins)):
            rad_b = bins[j]

            # can't have
            # a * b * c >= bd
            # a * b * c >= 2 * a * b
            # so need
            # a * b <= bd/2

            if rad_a * rad_b > bd//2:
                break

            if gcd(rad_a,rad_b) > 1:
                continue

            bin_b = radical_val_bins[rad_b]

            for a in bin_a:
                for b in bin_b:

                    c = a + b

                    if c >= bd:
                        break

                    val = rad_a * rad_b * radicals[c]

                    if val < c:

                        hits_with_greater.append([a,b,c])

    S = sum([tup[2] for tup in hits_with_1])
    S += sum([tup[2] for tup in hits_with_greater])

    print(S)


